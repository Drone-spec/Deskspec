/*! For license information please see index.min.js.LICENSE.txt */
(()=>{var e,t,r,s={1010:()=>{"toJSON"in Error.prototype||Object.defineProperty(Error.prototype,"toJSON",{value:function(){const e={};return Object.getOwnPropertyNames(this).forEach((function(t){"object"==typeof this[t]?"function"!=typeof this[t].toJSON?e[t]=JSON.parse(JSON.stringify(this[t])):e[t]=this[t].toJSON():e[t]=this[t]}),this),e},configurable:!0,writable:!0})},5571:(e,t,r)=>{"use strict";function s(){this._storage=chrome.storage.local,this._data={}}s.prototype.init=function(){const e=this;return new Promise(((t,r)=>{e._storage.get("_passbolt_data",(s=>{void 0!==chrome.runtime.lastError&&null!==chrome.runtime.lastError?r(chrome.runtime.lastError):void 0!==s._passbolt_data&&(e._data=JSON.parse(JSON.stringify(s._passbolt_data))),t()}))}))},s.prototype._store=function(){this._storage.set({_passbolt_data:this._data},(()=>{void 0!==chrome.runtime.lastError&&null!==chrome.runtime.lastError&&console.error(chrome.runtime.lastError.message)}))},s.prototype.getItem=function(e){const t=this._data[e];return void 0===t?null:t},s.prototype.setItem=function(e,t){this._data[e]=t,this._store()},s.prototype.removeItem=function(e,t){void 0===t?delete this._data[e]:delete this._data[e][t],this._store()};const i=new s;var o=r(3150),n=r.n(o);class a{executeScript(e){e.func?this._insertJsFunc(e):this._insertJsFiles(e)}insertCSS(e){let t=null;const r=e.files;for(let s=r.length-1;s>=0;--s){const i={file:r[s],runAt:"document_end",frameId:e.target?.frameId};t=this._createCssCallback(e.target.tabId,i,t)}t&&t()}_createJsCallback(e,t,r){return()=>chrome.tabs.executeScript(e,t,r)}_createCssCallback(e,t,r){return()=>chrome.tabs.insertCSS(e,t,r)}_insertJsFiles(e){let t=null;const r=e.files;for(let s=r.length-1;s>=0;--s){const i={file:r[s],runAt:"document_end",frameId:e.target?.frameId};t=this._createJsCallback(e.target.tabId,i,t)}t&&t()}_insertJsFunc(e){const t=JSON.stringify(e.args),r=`;${e.func.name}.apply(window, ${t});`,s={code:e.func.toString()+r,runAt:"document_end",frameId:e.target?.frameId};this._createJsCallback(e.target.tabId,s,null)()}}n().scripting||(n().scripting=new a);class c{constructor(){this._storedData={}}async get(e){const t=typeof e;if("string"!==t&&"undefined"!==t)throw new Error(`Expected keys type of "string" but received an unsopprted type: ${t}`);if(!e)return this._storedData;return this._storedData[e]?{[e]:this._storedData[e]}:{}}async set(e){if("object"!=typeof e)throw new Error('Expected keys type of "object" but received an unsopprted type: '+typeof e);for(const t in e)this._storedData[t]=JSON.parse(JSON.stringify(e[t]))}async remove(e){delete this._storedData[e]}async clear(){this._storedData={}}}n().storage.session||(n().storage.session=new c);const u=n();const p=e=>{const t="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}",r=`(.*)/setup/(install|recover)/(${t})/(${t})`;return Promise.all(e.map((e=>{if(e&&e.url.match(r)){const t=new URL(e.url);return t.searchParams.set("first-install",1),u.tabs.update(e.id,{url:t.href,active:!0})}return e})))},l=e=>Promise.all(e.map((e=>e.url.match("https://(chrome.google.com/webstore|addons.mozilla.org)/(.*)/passbolt")?u.tabs.remove(e.id):e))),d=class{static onInstall(e){e.reason===u.runtime.OnInstalledReason.INSTALL&&u.tabs.query({currentWindow:!0}).then(p).then(l)}};u.runtime.onInstalled.addListener(d.onInstall);var h=r(9650),g=r(6912),y=r(5538);let _;class m{static init(e,t){_=g.ZP.createInstance(),_.use(y.Z).init({lng:e,load:"currentOnly",backend:{loadPath:"/locales/{{lng}}/{{ns}}.json"},supportedLngs:t,fallbackLng:!1,ns:["common"],defaultNS:"common",keySeparator:!1,nsSeparator:!1,debug:!1})}static initWithDefaultLocale(){const e="en-UK",t=[e];m.init(e,t)}static t(){return _||m.initWithDefaultLocale(),_.t.apply(_,arguments)}}const w=m,f=async e=>{if("string"!=typeof e)throw new Error(w.t("The key should be a valid openpgp armored key string."));try{return await h.xh({armoredKey:e})}catch(e){throw new Error(w.t("The key should be a valid openpgp armored key string."))}},E=e=>{if(!(e instanceof h.nh||e instanceof h._q))throw new Error(w.t("The key should be a valid openpgp key."))},S=e=>{if(!(e instanceof h.nh)||e instanceof h.nh&&e.isPrivate())throw new Error(w.t("The key should be a valid openpgp public key."))},v=e=>{if(!(e instanceof h._q)||e instanceof h._q&&!e.isPrivate())throw new Error(w.t("The key should be a valid openpgp private key."))},b=e=>{if(v(e),!e.isDecrypted())throw new Error(w.t("The private key should be decrypted."))},A=e=>{if(v(e),e.isDecrypted())throw new Error(w.t("The private key should be encrypted."))},T=e=>{if(!(e instanceof h.v0))throw new Error(w.t("The message should be a valid openpgp message."))},I=A,R=e=>{if(!Array.isArray(e))throw new Error(w.t("The keys should be an array of valid decrypted openpgp private keys."));for(let t=0;t<e.length;t++)b(e[t])},C=b,O=v,k=S,N=e=>{if(!Array.isArray(e))throw new Error(w.t("The keys should be an array."));for(let t=0;t<e.length;t++)E(e[t])},P=E,U=async e=>{if("string"!=typeof e)throw new Error(w.t("The message should be of type string."));try{return await h.Rk({armoredMessage:e})}catch(e){throw new Error(w.t("The message should be a valid openpgp message."))}},x=async e=>{if("string"!=typeof e)throw new Error(w.t("The message should be of type string."));return h.tn({text:e,format:"utf8"})},M=f;var L=r(9911),D=r(648),F=r.n(D);const q=class{static randomValuesArray(e){const t=new Uint8Array(e);return self.crypto.getRandomValues(t),t}};const K=function(e){let t;if(void 0===e)t=function(e){let t,r="";const s="ABCDEF0123456789",i=q.randomValuesArray(e);for(t=e;t>0;t--)r+=s.charAt(Math.floor(i[t]%s.length));return r}(32);else{const r=new L.Z("SHA-1","TEXT");r.update(e),t=r.getHash("HEX").substring(0,32)}const r=F()("^(?<first>.{8})(?<second>.{4})(?<third>.{1})(?<fourth>.{3})(?<fifth>.{1})(?<sixth>.{3})(?<seventh>.{12}$)"),s=F()("${first}-${second}-3${fourth}-a${sixth}-${seventh}");return F().replace(t,r,s).replace(/\//g,"")},$=JSON.parse('{"debug":false,"log":{"level":0,"console":false}}'),j=function(){void 0!==i.getItem("config").debug&&(i.removeItem("config","setupBootstrapRegex"),i.removeItem("config","debug"),i.removeItem("config","log"),i.removeItem("config","baseUrl"),i.removeItem("config","extensionId"))},B=function(e){if(void 0!==$[e])return $[e]},G=function(){const e=i.getItem("config");if(null!==e){for(const t in e)void 0===$[t]&&($[t]=e[t]);j()}},Y=B,z=function(e,t){return"debug"!==e&&($[e]=t,i.setItem("config",$),!0)},V=function(){for(const e in $)delete $[e];for(const e in $)$[e]=$[e];i.removeItem("config")},H=function(){const e=B("debug");return void 0!==e&&e};var W=r(8966),J=r.n(W);const Q=class{isValid(){try{this.getSecurityToken(),this.getDomain()}catch(e){return!1}return!0}validateField(e,t){switch(e){case"securityToken":this.validateSecurityToken(t);break;case"domain":this.validateDomain(t);break;case"theme":this.validateTheme(t);break;case"locale":this.validateLocale(t);break;default:throw new Error(`No validation defined for field: ${e}.`)}}validateSecurityToken(e){if(void 0===e)throw Error("A token cannot be empty.");if(void 0===e.code||""===e.code)throw Error("A token code cannot be empty.");if(!J().isAscii(e.code))throw new Error("The token code should only contain ASCII characters.");if(!J().isLength(e.code,3,3))throw Error("The token code should only contain 3 characters.");if(void 0===e.color||""===e.color)throw Error("The token color cannot be empty.");if(!J().isHexColor(e.color))throw Error(`This is not a valid token color: ${e.color}.`);if(void 0===e.textcolor||""===e.textcolor)throw Error("The token text color cannot be empty.");if(!J().isHexColor(e.textcolor))throw Error(`This is not a valid token text color: ${e.textcolor}.`);return!0}validateDomain(e){if(void 0===e||""===e)throw new Error("A domain cannot be empty");if(!J().isURL(e,{require_tld:!1}))throw new Error("The trusted domain url is not valid.")}validateTheme(e){if(-1===["default","midgar","solarized_light","solarized_dark"].indexOf(e))throw new Error("The theme is not valid.")}validateLocale(e){const t=new RegExp("^[a-z]{2}-[A-Z]{2}$");if(!e.match(t))throw new Error("The locale is not valid.")}validate(e,t){void 0===t&&(t=["securityToken","domain"]);const r=[];for(const s in t){const i=t[s];try{this.validateField(i,e[i])}catch(e){const t={};t[i]=e.message,r.push(t)}}if(r.length>0){const e=new Error("settings could not be validated");throw e.validationErrors=r,e}return e}getSecurityToken(){const e={};if(e.code=Y("user.settings.securityToken.code"),e.color=Y("user.settings.securityToken.color"),e.textcolor=Y("user.settings.securityToken.textColor"),void 0===e.code||void 0===e.color||void 0===e.textcolor)throw new Error("Security token is not set");return e}setSecurityToken(e){return this.validateSecurityToken(e),z("user.settings.securityToken.code",e.code),z("user.settings.securityToken.color",e.color),z("user.settings.securityToken.textColor",e.textcolor),!0}setDomain(e){return this.validateDomain(e),z("user.settings.trustedDomain",e)}getDomain(){const e=Y("user.settings.trustedDomain");if(void 0===e)throw new Error("Trusted domain is not set");return e}setTheme(e){return this.validateTheme(e),z("user.settings.theme",e)}getTheme(){const e=Y("user.settings.theme");if(void 0===e)throw new Error("The user has no selected themes.");return e}async setLocale(e){return this.validateLocale(e),z("user.settings.locale",e)}getLocale(){const e=Y("user.settings.locale");if(void 0===e)throw new Error("The user has no locale language.");return e}get(e){const t={};return void 0===e&&(e=["domain","securityToken"]),-1!==e.indexOf("domain")&&(t.domain=this.getDomain()),-1!==e.indexOf("securityToken")&&(t.securityToken=this.getSecurityToken()),t}set(e){if(void 0===e)throw new Error("UserSettings cannot be empty");return this.setSecurityToken(e.securityToken),this.setDomain(e.domain),!0}setDefaults(){this.setTheme("default")}flush(){V()}async sync(){const e=`${this.getDomain()}/account/settings.json?api-version=v2`,t=await fetch(e,{method:"GET",credentials:"include",headers:{Accept:"application/json","Content-Type":"application/json"}}),r=await t.json();if(!t.ok){let e="Could not synchronize the account settings. The server responded with an error.";throw r.header.msg&&(e+=` ${r.header.msg}`),e+=`(${t.status})`,new Error(e)}if(!r.header)throw new Error("Could not synchronize account settings. The server response header is missing.");if(!r.body)throw new Error("Could not synchronize account settings. The server response body is missing.");let s,i;for(i in r.body)if(s=r.body[i],void 0!==s.property)switch(s.property){case"theme":this.setTheme(s.value);break;case"locale":this.setLocale(s.value);break;default:console.error(`Unknown property ${s.property}`)}return!0}};class Z{constructor(e){this._props=JSON.parse(JSON.stringify(e))}toDto(){return JSON.parse(JSON.stringify(this))}toJSON(){return this._props}_hasProp(e){if(!e.includes(".")){const t=Z._normalizePropName(e);return Object.prototype.hasOwnProperty.call(this._props,t)}try{return this._getPropByPath(e),!0}catch(e){return!1}}_getPropByPath(e){return Z._normalizePropName(e).split(".").reduce(((e,t)=>{if(Object.prototype.hasOwnProperty.call(e,t))return e[t];throw new Error}),this._props)}static _normalizePropName(e){return e.replace(/([A-Z])/g,((e,t)=>`_${t.toLowerCase()}`)).replace(/\._/,".").replace(/^_/,"").replace(/^\./,"")}}const X=Z;class ee extends Error{constructor(e){super(e=e||"Entity validation error."),this.name="EntityValidationError",this.details={}}addError(e,t,r){if("string"!=typeof e)throw new TypeError("EntityValidationError addError property should be a string.");if("string"!=typeof t)throw new TypeError("EntityValidationError addError rule should be a string.");if("string"!=typeof r)throw new TypeError("EntityValidationError addError message should be a string.");Object.prototype.hasOwnProperty.call(this.details,e)||(this.details[e]={}),this.details[e][t]=r}hasError(e,t){if("string"!=typeof e)throw new TypeError("EntityValidationError hasError property should be a string.");const r=this.details&&Object.prototype.hasOwnProperty.call(this.details,e);if(!t)return r;if("string"!=typeof t)throw new TypeError("EntityValidationError hasError rule should be a string.");return Object.prototype.hasOwnProperty.call(this.details[e],t)}hasErrors(){return Object.keys(this.details).length>0}}const te=ee;class re{static validateSchema(e,t){if(!t)throw new TypeError(`Could not validate entity ${e}. No schema for entity ${e}.`);if(!t.type)throw new TypeError(`Could not validate entity ${e}. Type missing.`);if("array"!==t.type){if("object"===t.type){if(!t.required||!Array.isArray(t.required))throw new TypeError(`Could not validate entity ${e}. Schema error: no required properties.`);if(!t.properties||!Object.keys(t).length)throw new TypeError(`Could not validate entity ${e}. Schema error: no properties.`);const r=t.properties;for(const e in r){if(!Object.prototype.hasOwnProperty.call(r,e)||!r[e].type&&!r[e].anyOf)throw TypeError(`Invalid schema. Type missing for ${e}...`);if(r[e].anyOf&&(!Array.isArray(r[e].anyOf)||!r[e].anyOf.length))throw new TypeError(`Invalid schema, prop ${e} anyOf should be an array`)}}}else if(!t.items)throw new TypeError(`Could not validate entity ${e}. Schema error: missing item definition.`)}static validate(e,t,r){if(!e||!t||!r)throw new TypeError(`Could not validate entity ${e}. No data provided.`);switch(r.type){case"object":return re.validateObject(e,t,r);case"array":return re.validateArray(e,t,r);default:throw new TypeError(`Could not validate entity ${e}. Unsupported type.`)}}static validateArray(e,t,r){return re.validateProp("items",t,r)}static validateObject(e,t,r){const s=r.required,i=r.properties,o={},n=new te(`Could not validate entity ${e}.`);for(const e in i)if(Object.prototype.hasOwnProperty.call(i,e)){if(s.includes(e)){if(!Object.prototype.hasOwnProperty.call(t,e)){n.addError(e,"required",`The ${e} is required.`);continue}}else if(!Object.prototype.hasOwnProperty.call(t,e))continue;try{o[e]=re.validateProp(e,t[e],i[e])}catch(t){if(!(t instanceof te))throw t;n.details[e]=t.details[e]}}if(n.hasErrors())throw n;return o}static validateProp(e,t,r){if(r.anyOf)return re.validateAnyOf(e,t,r.anyOf),t;if(re.validatePropType(e,t,r),r.enum)return re.validatePropEnum(e,t,r),t;switch(r.type){case"string":re.validatePropTypeString(e,t,r);break;case"array":case"object":case"number":case"integer":case"boolean":case"blob":case"null":break;case"x-custom":re.validatePropCustom(e,t,r);break;default:throw new TypeError(`Could not validate property ${e}. Unsupported prop type ${r.type}`)}return t}static validatePropType(e,t,r){if(!re.isValidPropType(t,r.type)){const t=new te(`Could not validate property ${e}.`);throw t.addError(e,"type",`The ${e} is not a valid ${r.type}.`),t}}static validatePropCustom(e,t,r){try{r.validationCallback(t)}catch(t){const r=new te(`Could not validate property ${e}.`);throw r.addError(e,"custom",`The ${e} is not valid: ${t.message}`),r}}static validatePropTypeString(e,t,r){const s=new te(`Could not validate property ${e}.`);if(r.format&&(re.isValidStringFormat(t,r.format)||s.addError(e,"format",`The ${e} is not a valid ${r.format}.`)),r.length&&(re.isValidStringLength(t,r.length,r.length)||s.addError(e,"length",`The ${e} should be ${r.length} character in length.`)),r.minLength&&(re.isValidStringLength(t,r.minLength)||s.addError(e,"minLength",`The ${e} should be ${r.minLength} character in length minimum.`)),r.maxLength&&(re.isValidStringLength(t,0,r.maxLength)||s.addError(e,"maxLength",`The ${e} should be ${r.maxLength} character in length maximum.`)),r.pattern&&(J().matches(t,r.pattern)||s.addError(e,"pattern",`The ${e} is not valid.`)),r.custom&&(r.custom(t)||s.addError(e,"custom",`The ${e} is not valid.`)),s.hasErrors())throw s}static validatePropEnum(e,t,r){if(!re.isPropInEnum(t,r.enum)){const t=new te(`Could not validate property ${e}.`);throw t.addError(e,"enum",`The ${e} value is not included in the supported list.`),t}}static validateAnyOf(e,t,r){for(let s=0;s<r.length;s++)try{return void re.validateProp(e,t,r[s])}catch(e){}const s=new te(`Could not validate property ${e}.`);throw s.addError(e,"type",`The ${e} does not match any of the supported types.`),s}static isValidPropType(e,t){if(Array.isArray(t))throw new TypeError("EntitySchema isValidPropType multiple types are not supported.");if("string"!=typeof t)throw new TypeError("EntitySchema isValidPropType type is invalid.");switch(t){case"null":return null===e;case"boolean":return"boolean"==typeof e;case"string":return"string"==typeof e;case"integer":return Number.isInteger(e);case"number":return"number"==typeof e;case"object":return"object"==typeof e;case"array":return Array.isArray(e);case"blob":return e instanceof Blob;case"x-custom":return!0;default:throw new TypeError("EntitySchema validation type not supported.")}}static isValidStringFormat(e,t){if("string"!=typeof t)throw new TypeError("EntitySchema validPropFormat format is invalid.");switch(t){case"uuid":return J().isUUID(e);case"email":case"idn-email":return J().isEmail(e);case"date-time":return J().isISO8601(e);case"x-url":return J().isURL(e,{require_tld:!1});case"x-hex-color":return J().isHexColor(e);case"x-base64":return J().isBase64(e);default:throw new TypeError(`EntitySchema string validation format ${t} is not supported.`)}}static isValidStringLength(e,t,r){return t=t||0,J().isLength(e,t,r)}static isPropInEnum(e,t){if(!t||!Array.isArray(t)||!t.length)throw new TypeError("EntitySchema enum schema cannot be empty.");return t.includes(e)}}const se=re;class ie extends X{constructor(e){const t=ie.sanitizeDto(e);super(se.validate(ie.ENTITY_NAME,t,ie.getSchema()))}static getSchema(){return{type:"object",required:["armored_key"],properties:{armored_key:{type:"string",minLength:1},key_id:{type:"string",minLength:8,maxLength:16},user_ids:{type:"array",items:{type:"object",required:["email","name"],properties:{email:{type:"string",format:"email"},name:{type:"string"}}}},fingerprint:{type:"string",minLength:40,maxLength:40},expires:{anyOf:[{type:"string",format:"date-time"},{type:"string",pattern:"^Infinity$"},{type:"null"}]},created:{type:"string",format:"date-time"},algorithm:{type:"string"},length:{type:"integer",minimum:1},curve:{anyOf:[{type:"string"},{type:"null"}]},private:{type:"boolean"},revoked:{type:"boolean"}}}}static sanitizeDto(e){const t=JSON.parse(JSON.stringify(e));if(e.key&&(t.armored_key=e.key,delete t.key),e.keyId&&(t.key_id=e.keyId,delete t.keyId),e.userIds&&(t.user_ids=e.userIds,delete t.userIds),e.created)try{const e=new Date(t.created);t.created=e.toISOString()}catch(e){delete t.created}if("Never"===e.expires)t.expires="Infinity";else if(e.expires&&"Infinity"!==e.expires)try{const e=new Date(t.expires);t.expires=e.toISOString()}catch(r){delete t.expires,console.error(`ExternalGpgKeyEntity::sanitizeDto Unable to sanitize the key for the user ${e.user_id}`)}return t}get armoredKey(){return this._props.armored_key}get keyId(){return this._props.key_id}get userIds(){return this._props.user_ids}get fingerprint(){return this._props.fingerprint}get expires(){return this._props.expires}get isValid(){return null!==this.expires}get created(){return this._props.created}get algorithm(){return this._props.algorithm}get length(){return this._props.length}get curve(){return this._props.curve}get revoked(){return this._props.revoked}get private(){return this._props.private}get isExpired(){const e=this.expires;if(null===e)return null;if("Infinity"===e)return!1;const t=Date.now();return new Date(e)<t}static get ENTITY_NAME(){return"externalGpgKey"}}const oe=ie,ne={string:{}};ne.string.Unicode={NBSP:" "},ne.string.startsWith=function(e,t){return 0==e.lastIndexOf(t,0)},ne.string.endsWith=function(e,t){const r=e.length-t.length;return r>=0&&e.indexOf(t,r)==r},ne.string.caseInsensitiveStartsWith=function(e,t){return 0==ne.string.caseInsensitiveCompare(t,e.substr(0,t.length))},ne.string.caseInsensitiveEndsWith=function(e,t){return 0==ne.string.caseInsensitiveCompare(t,e.substr(e.length-t.length,t.length))},ne.string.subs=function(e,t){for(let t=1;t<arguments.length;t++){const r=String(arguments[t]).replace(/\$/g,"$$$$");e=e.replace(/\%s/,r)}return e},ne.string.collapseWhitespace=function(e){return e.replace(/[\s\xa0]+/g," ").replace(/^\s+|\s+$/g,"")},ne.string.isEmpty=function(e){return/^[\s\xa0]*$/.test(e)},ne.string.isEmptySafe=function(e){return ne.string.isEmpty(ne.string.makeSafe(e))},ne.string.isBreakingWhitespace=function(e){return!/[^\t\n\r ]/.test(e)},ne.string.isAlpha=function(e){return!/[^a-zA-Z]/.test(e)},ne.string.isNumeric=function(e){return!/[^0-9]/.test(e)},ne.string.isAlphaNumeric=function(e){return!/[^a-zA-Z0-9]/.test(e)},ne.string.isSpace=function(e){return" "==e},ne.string.isUnicodeChar=function(e){return 1==e.length&&e>=" "&&e<="~"||e>=""&&e<="�"},ne.string.stripNewlines=function(e){return e.replace(/(\r\n|\r|\n)+/g," ")},ne.string.canonicalizeNewlines=function(e){return e.replace(/(\r\n|\r|\n)/g,"\n")},ne.string.normalizeWhitespace=function(e){return e.replace(/\xa0|\s/g," ")},ne.string.normalizeSpaces=function(e){return e.replace(/\xa0|[ \t]+/g," ")},ne.string.collapseBreakingSpaces=function(e){return e.replace(/[\t\r\n ]+/g," ").replace(/^[\t\r\n ]+|[\t\r\n ]+$/g,"")},ne.string.trim=function(e){return e.replace(/^[\s\xa0]+|[\s\xa0]+$/g,"")},ne.string.trimLeft=function(e){return e.replace(/^[\s\xa0]+/,"")},ne.string.trimRight=function(e){return e.replace(/[\s\xa0]+$/,"")},ne.string.caseInsensitiveCompare=function(e,t){const r=String(e).toLowerCase(),s=String(t).toLowerCase();return r<s?-1:r==s?0:1},ne.string.numerateCompareRegExp_=/(\.\d+)|(\d+)|(\D+)/g,ne.string.numerateCompare=function(e,t){if(e==t)return 0;if(!e)return-1;if(!t)return 1;const r=e.toLowerCase().match(ne.string.numerateCompareRegExp_),s=t.toLowerCase().match(ne.string.numerateCompareRegExp_),i=Math.min(r.length,s.length);for(let e=0;e<i;e++){const t=r[e],i=s[e];if(t!=i){const e=parseInt(t,10);if(!isNaN(e)){const t=parseInt(i,10);if(!isNaN(t)&&e-t)return e-t}return t<i?-1:1}}return r.length!=s.length?r.length-s.length:e<t?-1:1},ne.string.urlEncode=function(e){return encodeURIComponent(String(e))},ne.string.urlDecode=function(e){return decodeURIComponent(e.replace(/\+/g," "))},ne.string.newLineToBr=function(e,t){return e.replace(/(\r\n|\r|\n)/g,t?"<br />":"<br>")},ne.string.htmlEscape=function(e,t){return t?e.replace(ne.string.amperRe_,"&amp;").replace(ne.string.ltRe_,"&lt;").replace(ne.string.gtRe_,"&gt;").replace(ne.string.quotRe_,"&quot;"):ne.string.allRe_.test(e)?(-1!=e.indexOf("&")&&(e=e.replace(ne.string.amperRe_,"&amp;")),-1!=e.indexOf("<")&&(e=e.replace(ne.string.ltRe_,"&lt;")),-1!=e.indexOf(">")&&(e=e.replace(ne.string.gtRe_,"&gt;")),-1!=e.indexOf('"')&&(e=e.replace(ne.string.quotRe_,"&quot;")),e):e},ne.string.amperRe_=/&/g,ne.string.ltRe_=/</g,ne.string.gtRe_=/>/g,ne.string.quotRe_=/\"/g,ne.string.allRe_=/[&<>\"]/,ne.string.unescapeEntities=function(e){return ne.string.contains(e,"&")?"document"in ne.global?ne.string.unescapeEntitiesUsingDom_(e):ne.string.unescapePureXmlEntities_(e):e},ne.string.unescapeEntitiesUsingDom_=function(e){const t={"&amp;":"&","&lt;":"<","&gt;":">","&quot;":'"'},r=document.createElement("div");return e.replace(ne.string.HTML_ENTITY_PATTERN_,((e,s)=>{let i=t[e];if(i)return i;if("#"==s.charAt(0)){const e=Number(`0${s.substr(1)}`);isNaN(e)||(i=String.fromCharCode(e))}return i||(r.innerHTML=`${e} `,i=r.firstChild.nodeValue.slice(0,-1)),t[e]=i}))},ne.string.unescapePureXmlEntities_=function(e){return e.replace(/&([^;]+);/g,((e,t)=>{switch(t){case"amp":return"&";case"lt":return"<";case"gt":return">";case"quot":return'"';default:if("#"==t.charAt(0)){const e=Number(`0${t.substr(1)}`);if(!isNaN(e))return String.fromCharCode(e)}return e}}))},ne.string.HTML_ENTITY_PATTERN_=/&([^;\s<&]+);?/g,ne.string.whitespaceEscape=function(e,t){return ne.string.newLineToBr(e.replace(/ {2}/g," &#160;"),t)},ne.string.stripQuotes=function(e,t){const r=t.length;for(let s=0;s<r;s++){const i=1==r?t:t.charAt(s);if(e.charAt(0)==i&&e.charAt(e.length-1)==i)return e.substring(1,e.length-1)}return e},ne.string.truncate=function(e,t,r){return r&&(e=ne.string.unescapeEntities(e)),e.length>t&&(e=`${e.substring(0,t-3)}...`),r&&(e=ne.string.htmlEscape(e)),e},ne.string.truncateMiddle=function(e,t,r,s){if(r&&(e=ne.string.unescapeEntities(e)),s&&e.length>t){s>t&&(s=t);const r=e.length-s,i=t-s;e=`${e.substring(0,i)}...${e.substring(r)}`}else if(e.length>t){let r=Math.floor(t/2);const s=e.length-r;r+=t%2,e=`${e.substring(0,r)}...${e.substring(s)}`}return r&&(e=ne.string.htmlEscape(e)),e},ne.string.specialEscapeChars_={"\0":"\\0","\b":"\\b","\f":"\\f","\n":"\\n","\r":"\\r","\t":"\\t","\v":"\\x0B",'"':'\\"',"\\":"\\\\"},ne.string.jsEscapeCache_={"'":"\\'"},ne.string.quote=function(e){if((e=String(e)).quote)return e.quote();{const t=['"'];for(let r=0;r<e.length;r++){const s=e.charAt(r),i=s.charCodeAt(0);t[r+1]=ne.string.specialEscapeChars_[s]||(i>31&&i<127?s:ne.string.escapeChar(s))}return t.push('"'),t.join("")}},ne.string.escapeString=function(e){const t=[];for(let r=0;r<e.length;r++)t[r]=ne.string.escapeChar(e.charAt(r));return t.join("")},ne.string.escapeChar=function(e){if(e in ne.string.jsEscapeCache_)return ne.string.jsEscapeCache_[e];if(e in ne.string.specialEscapeChars_)return ne.string.jsEscapeCache_[e]=ne.string.specialEscapeChars_[e];let t=e;const r=e.charCodeAt(0);return r>31&&r<127?t=e:(r<256?(t="\\x",(r<16||r>256)&&(t+="0")):(t="\\u",r<4096&&(t+="0")),t+=r.toString(16).toUpperCase()),ne.string.jsEscapeCache_[e]=t},ne.string.toMap=function(e){const t={};for(let r=0;r<e.length;r++)t[e.charAt(r)]=!0;return t},ne.string.contains=function(e,t){return-1!=e.indexOf(t)},ne.string.countOf=function(e,t){return e&&t?e.split(t).length-1:0},ne.string.removeAt=function(e,t,r){let s=e;return t>=0&&t<e.length&&r>0&&(s=e.substr(0,t)+e.substr(t+r,e.length-t-r)),s},ne.string.remove=function(e,t){const r=new RegExp(ne.string.regExpEscape(t),"");return e.replace(r,"")},ne.string.removeAll=function(e,t){const r=new RegExp(ne.string.regExpEscape(t),"g");return e.replace(r,"")},ne.string.regExpEscape=function(e){return String(e).replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g,"\\$1").replace(/\x08/g,"\\x08")},ne.string.repeat=function(e,t){return new Array(t+1).join(e)},ne.string.padNumber=function(e,t,r){const s=ne.isDef(r)?e.toFixed(r):String(e);let i=s.indexOf(".");return-1==i&&(i=s.length),ne.string.repeat("0",Math.max(0,t-i))+s},ne.string.makeSafe=function(e){return null==e?"":String(e)},ne.string.buildString=function(e){return Array.prototype.join.call(arguments,"")},ne.string.getRandomString=function(){const e=2147483648;return Math.floor(Math.random()*e).toString(36)+Math.abs(Math.floor(Math.random()*e)^ne.now()).toString(36)},ne.string.compareVersions=function(e,t){let r=0;const s=ne.string.trim(String(e)).split("."),i=ne.string.trim(String(t)).split("."),o=Math.max(s.length,i.length);for(let e=0;0==r&&e<o;e++){const t=s[e]||"",o=i[e]||"",n=new RegExp("(\\d*)(\\D*)","g"),a=new RegExp("(\\d*)(\\D*)","g");do{const e=n.exec(t)||["","",""],s=a.exec(o)||["","",""];if(0==e[0].length&&0==s[0].length)break;const i=0==e[1].length?0:parseInt(e[1],10),c=0==s[1].length?0:parseInt(s[1],10);r=ne.string.compareElements_(i,c)||ne.string.compareElements_(0==e[2].length,0==s[2].length)||ne.string.compareElements_(e[2],s[2])}while(0==r)}return r},ne.string.compareElements_=function(e,t){return e<t?-1:e>t?1:0},ne.string.HASHCODE_MAX_=4294967296,ne.string.hashCode=function(e){let t=0;for(let r=0;r<e.length;++r)t=31*t+e.charCodeAt(r),t%=ne.string.HASHCODE_MAX_;return t},ne.string.uniqueStringCounter_=2147483648*Math.random()|0,ne.string.createUniqueString=function(){return"goog_"+ne.string.uniqueStringCounter_++},ne.string.toNumber=function(e){const t=Number(e);return 0==t&&ne.string.isEmpty(e)?NaN:t},ne.string.toCamelCase=function(e){return String(e).replace(/\-([a-z])/g,((e,t)=>t.toUpperCase()))},ne.string.toSelectorCase=function(e){return String(e).replace(/([A-Z])/g,"-$1").toLowerCase()},ne.string.toTitleCase=function(e,t){let r=ne.isString(t)?ne.string.regExpEscape(t):"\\s";r=r?`|[${r}]+`:"";const s=new RegExp(`(^${r})([a-z])`,"g");return e.replace(s,((e,t,r)=>t+r.toUpperCase()))},ne.string.parseInt=function(e){return isFinite(e)&&(e=String(e)),ne.isString(e)?/^\s*-?0x/i.test(e)?parseInt(e,16):parseInt(e,10):NaN};const ae=ne,ce={};ce.string=ae.string,ce.format={},ce.format.EmailAddress=function(e,t){this.name_=t||"",this.address_=e||""},ce.format.EmailAddress.OPENERS_='"<([',ce.format.EmailAddress.CLOSERS_='">)]',ce.format.EmailAddress.SPECIAL_CHARS_RE_=/[()<>@,;:\\\".\[\]]/,ce.format.EmailAddress.ALL_DOUBLE_QUOTES_=/\"/g,ce.format.EmailAddress.ESCAPED_DOUBLE_QUOTES_=/\\\"/g,ce.format.EmailAddress.ALL_BACKSLASHES_=/\\/g,ce.format.EmailAddress.ESCAPED_BACKSLASHES_=/\\\\/g,ce.format.EmailAddress.LOCAL_PART_REGEXP_STR_="[+a-zA-Z0-9_.!#$%&'*\\/=?^`{|}~-]+",ce.format.EmailAddress.DOMAIN_PART_REGEXP_STR_="([a-zA-Z0-9-]+\\.)+[a-zA-Z0-9]{2,63}",ce.format.EmailAddress.LOCAL_PART_=new RegExp(`^${ce.format.EmailAddress.LOCAL_PART_REGEXP_STR_}$`),ce.format.EmailAddress.DOMAIN_PART_=new RegExp(`^${ce.format.EmailAddress.DOMAIN_PART_REGEXP_STR_}$`),ce.format.EmailAddress.EMAIL_ADDRESS_=new RegExp(`^${ce.format.EmailAddress.LOCAL_PART_REGEXP_STR_}@${ce.format.EmailAddress.DOMAIN_PART_REGEXP_STR_}$`),ce.format.EmailAddress.prototype.getName=function(){return this.name_},ce.format.EmailAddress.prototype.getAddress=function(){return this.address_},ce.format.EmailAddress.prototype.setName=function(e){this.name_=e},ce.format.EmailAddress.prototype.setAddress=function(e){this.address_=e},ce.format.EmailAddress.prototype.toString=function(){let e=this.getName();e=e.replace(ce.format.EmailAddress.ALL_DOUBLE_QUOTES_,"");return ce.format.EmailAddress.SPECIAL_CHARS_RE_.test(e)&&(e=`"${e.replace(ce.format.EmailAddress.ALL_BACKSLASHES_,"\\\\")}"`),""==e?this.address_:""==this.address_?e:`${e} <${this.address_}>`},ce.format.EmailAddress.prototype.isValid=function(){return ce.format.EmailAddress.isValidAddrSpec(this.address_)},ce.format.EmailAddress.isValidAddress=function(e){return ce.format.EmailAddress.parse(e).isValid()},ce.format.EmailAddress.isValidAddrSpec=function(e){return ce.format.EmailAddress.EMAIL_ADDRESS_.test(e)},ce.format.EmailAddress.parse=function(e){let t="",r="";for(let s=0;s<e.length;){const i=ce.format.EmailAddress.getToken_(e,s);if("<"==i.charAt(0)&&-1!=i.indexOf(">")){const e=i.indexOf(">");r=i.substring(1,e)}else""==r&&(t+=i);s+=i.length}return""==r&&-1!=t.indexOf("@")&&(r=t,t=""),t=ce.string.collapseWhitespace(t),t=ce.string.stripQuotes(t,"'"),t=ce.string.stripQuotes(t,'"'),t=t.replace(ce.format.EmailAddress.ESCAPED_DOUBLE_QUOTES_,'"'),t=t.replace(ce.format.EmailAddress.ESCAPED_BACKSLASHES_,"\\"),r=ce.string.collapseWhitespace(r),new ce.format.EmailAddress(r,t)},ce.format.EmailAddress.parseList=function(e){const t=[];let r,s="";for(let i=0;i<e.length;)r=ce.format.EmailAddress.getToken_(e,i),","!=r&&";"!=r?(s+=r,i+=r.length):(ce.string.isEmpty(s)||t.push(ce.format.EmailAddress.parse(s)),s="",i++);return ce.string.isEmpty(s)||t.push(ce.format.EmailAddress.parse(s)),t},ce.format.EmailAddress.getToken_=function(e,t){const r=e.charAt(t),s=ce.format.EmailAddress.OPENERS_.indexOf(r);if(-1==s)return r;if(ce.format.EmailAddress.isEscapedDlQuote_(e,t))return r;const i=ce.format.EmailAddress.CLOSERS_.charAt(s);let o=e.indexOf(i,t+1);for(;o>=0&&ce.format.EmailAddress.isEscapedDlQuote_(e,o);)o=e.indexOf(i,o+1);return o>=0?e.substring(t,o+1):r},ce.format.EmailAddress.isEscapedDlQuote_=function(e,t){if('"'!=e.charAt(t))return!1;let r=0;for(let s=t-1;s>=0&&"\\"==e.charAt(s);s--)r++;return r%2!=0};const ue=ce;class pe extends Error{constructor(e){super(e),this.name="GpgKeyError"}}const le=pe;const de=class{static async getKeyInfo(e){P(e);const t=e.getUserIDs(),r=[];if(0===t.length)throw new le("No key user ID found");for(const e in t)if(Object.prototype.hasOwnProperty.call(t,e)){const s=ue.format.EmailAddress.parse(t[e]);r.push({name:s.name_,email:s.address_})}let s,i=e.getKeyID().toHex();i.length>8&&(i=i.substr(i.length-8));const o=await e.getExpirationTime();s=o instanceof Date?o.toISOString():o===1/0?o.toString():null;const n=e.getAlgorithmInfo(),a={armored_key:e.armor(),key_id:i,user_ids:r,fingerprint:e.getFingerprint().toUpperCase(),created:e.getCreationTime().toISOString(),expires:s,algorithm:this.formatAlgorithm(n.algorithm),length:this.getKeyLength(n),curve:n.curve||null,private:e.isPrivate(),revoked:await e.isRevoked()};return new oe(a)}static formatAlgorithm(e){switch(e){case"rsaEncryptSign":case"rsaEncrypt":case"rsaSign":return"rsa";case"elgamal":return"elgamal";case"dsa":return"dsa";case"ecdh":return"ecdh";case"ecdsa":return"ecdsa";case"eddsa":return"eddsa";case"aedh":return"aedh";case"aedsa":return"aedsa";default:throw new Error("Unknown algorithm.")}}static getKeyLength(e){if(void 0!==e.bits)return e.bits;const t=e?.curve.toString().toLowerCase();switch(t){case"p256":case"ed25519":case"secp256k1":case"curve25519":case"brainpoolp256r1":return 256;case"brainpoolp384r1":case"p384":return 384;case"brainpoolp512r1":return 512;case"p521":return 521}}};class he{findPublic(e){let t;const r=this.getPublicKeysFromStorage();for(t in r)if(Object.prototype.hasOwnProperty.call(r,t)&&r[t].user_id===e)return new oe(r[t])}findPrivate(){const e=he.MY_KEY_ID,t=this.getPrivateKeysFromStorage();return t[e]?new oe(t[e]):void 0}async importPublic(e,t){if(void 0===t)throw new Error("The user id is undefined");if(!J().isUUID(t))throw new Error("The user id is not valid");e=this.findArmoredKeyInText(e,he.PUBLIC);const r=await M(e);k(r);const s=(await de.getKeyInfo(r)).toDto(),i=this.getPublicKeysFromStorage();return i[t]=s,i[t].user_id=t,this.store(he.PUBLIC,i),!0}async importPrivate(e){this.flush(he.PRIVATE),e=this.findArmoredKeyInText(e,he.PRIVATE);const t=await M(e);O(t);const r=(await de.getKeyInfo(t)).toDto(),s=this.getPrivateKeysFromStorage();return s[he.MY_KEY_ID]=r,s[he.MY_KEY_ID].user_id=he.MY_KEY_ID,this.store(he.PRIVATE,s),!0}async importServerPublicKey(e,t){const r=K(t);return await this.importPublic(e,r),!0}findArmoredKeyInText(e,t){let r,s;if(t===he.PUBLIC){if(r=e.indexOf(he.PUBLIC_HEADER),-1!==r&&(s=e.indexOf(he.PUBLIC_FOOTER),-1!==s))return e.substr(r,s+he.PUBLIC_FOOTER.length)}else t===he.PRIVATE&&(r=e.indexOf(he.PRIVATE_HEADER),-1!==r&&(s=e.indexOf(he.PRIVATE_FOOTER),-1!==s&&(e=e.substr(r,s+he.PRIVATE_HEADER.length))));return e}async sync(){const e=i.getItem("latestSync");let t=`${(new Q).getDomain()}/gpgkeys.json?api-version=v2`;null!==e&&(t+=`&modified_after=${e}`);const r=await fetch(t,{method:"GET",credentials:"include",headers:{Accept:"application/json","Content-Type":"application/json"}}),s=await r.json();if(!r.ok){let e="Could not synchronize the keyring. The server responded with an error.";throw s.header.msg&&(e+=` ${s.header.msg}`),e+=`(${r.status})`,new Error(e)}if(!s.header)throw new Error("Could not synchronize the keyring. The server response header is missing.");if(!s.body)throw new Error("Could not synchronize the keyring. The server response body is missing.");let o,n;const a=[];for(n in s.body)Object.prototype.hasOwnProperty.call(s.body,n)&&(o=s.body[n],a.push(this.importPublic(o.armored_key,o.user_id)));return await Promise.all(a),i.setItem("latestSync",s.header.servertime),s.body.length}store(e,t){if(e!==he.PUBLIC&&e!==he.PRIVATE)throw new Error("Key type is incorrect");const r=e===he.PRIVATE?he.STORAGE_KEY_PRIVATE:he.STORAGE_KEY_PUBLIC;i.setItem(r,JSON.stringify(t))}getPrivateKeysFromStorage(){const e=i.getItem(he.STORAGE_KEY_PRIVATE);return e?JSON.parse(e):{}}getPublicKeysFromStorage(){const e=i.getItem(he.STORAGE_KEY_PUBLIC);return e?JSON.parse(e):{}}flush(e){void 0===e&&(e=he.PUBLIC),e===he.PUBLIC?this.store(he.PUBLIC,{}):e===he.PRIVATE&&this.store(he.PRIVATE,{}),i.removeItem("latestSync")}static get MY_KEY_ID(){return"MY_KEY_ID"}static get PUBLIC_HEADER(){return"-----BEGIN PGP PUBLIC KEY BLOCK-----"}static get PUBLIC_FOOTER(){return"-----END PGP PUBLIC KEY BLOCK-----"}static get PRIVATE_HEADER(){return"-----BEGIN PGP PRIVATE KEY BLOCK-----"}static get PRIVATE_FOOTER(){return"-----END PGP PRIVATE KEY BLOCK-----"}static get PUBLIC(){return"PUBLIC"}static get PRIVATE(){return"PRIVATE"}static get STORAGE_KEY_PUBLIC(){return"passbolt-public-gpgkeys"}static get STORAGE_KEY_PRIVATE(){return"passbolt-private-gpgkeys"}}const ge=he;const ye=class{static async encryptSymmetrically(e,t,r=null){r&&R(r);const s=await x(e);return h.HI({message:s,passwords:t,signingKeys:r})}static async encrypt(e,t,r=null){k(t),r&&R(r);const s=await x(e);return h.HI({message:s,encryptionKeys:t,signingKeys:r})}};const _e=class{static async decryptSymmetrically(e,t,r=null){r&&N(r),T(e);const{data:s,signatures:i}=await h.pe({message:e,passwords:[t],verificationKeys:r,expectSigned:Boolean(r)});return r&&await this._doSignatureVerification(i),s}static async decrypt(e,t,r=null){T(e),C(t),r&&N(r);const{data:s,signatures:i}=await h.pe({message:e,decryptionKeys:t,verificationKeys:r,expectSigned:Boolean(r)});return r&&await this._doSignatureVerification(i),s}static async _doSignatureVerification(e){const t=e.map((e=>e.verified));await Promise.all(t)}};const me=class{static async areKeysTheSame(e,t){P(e),P(t);const r=await de.getKeyInfo(e),s=await de.getKeyInfo(t);return r.fingerprint===s.fingerprint&&r.expires===s.expires}};class we extends Error{constructor(e,t){super(w.t("An internal error occurred. The server response could not be parsed. Please contact your administrator.")),this.name="PassboltBadResponseError",this.srcError=e,this.srcResponse=t}}const fe=we;class Ee extends Error{constructor(e,t){super(e),this.name="PassboltApiFetchError",this.data=t||{}}}const Se=Ee;class ve extends Error{constructor(e){super(e=e||w.t("The service is unavailable")),this.name="PassboltServiceUnavailableError"}}const be=ve;const Ae=class{constructor(e){if(this.options=e,!this.options.getBaseUrl())throw new TypeError("ApiClient constructor error: baseUrl is required.");if(!this.options.getResourceName())throw new TypeError("ApiClient constructor error: resourceName is required.");try{let e=this.options.getBaseUrl().toString();e.endsWith("/")&&(e=e.slice(0,-1)),this.baseUrl=`${e}/${this.options.getResourceName()}`,this.baseUrl=new URL(this.baseUrl)}catch(e){throw new TypeError("ApiClient constructor error: b.")}this.apiVersion="api-version=v2"}getDefaultHeaders(){return{Accept:"application/json","content-type":"application/json"}}buildFetchOptions(){return{credentials:"include",headers:{...this.getDefaultHeaders(),...this.options.getHeaders()}}}async get(e,t){this.assertValidId(e);const r=this.buildUrl(`${this.baseUrl}/${e}`,t||{});return this.fetchAndHandleResponse("GET",r)}async delete(e,t,r,s){let i;this.assertValidId(e),void 0===s&&(s=!1),i=s?this.buildUrl(`${this.baseUrl}/${e}/dry-run`,r||{}):this.buildUrl(`${this.baseUrl}/${e}`,r||{});const o=t?this.buildBody(t):void 0;return this.fetchAndHandleResponse("DELETE",i,o)}async findAll(e){const t=this.buildUrl(this.baseUrl.toString(),e||{});return await this.fetchAndHandleResponse("GET",t)}async create(e,t){const r=this.buildUrl(this.baseUrl.toString(),t||{}),s=this.buildBody(e);return this.fetchAndHandleResponse("POST",r,s)}async update(e,t,r,s){let i;this.assertValidId(e),void 0===s&&(s=!1),i=s?this.buildUrl(`${this.baseUrl}/${e}/dry-run`,r||{}):this.buildUrl(`${this.baseUrl}/${e}`,r||{});const o=t?this.buildBody(t):void 0;return this.fetchAndHandleResponse("PUT",i,o)}assertValidId(e){if(!e)throw new TypeError("ApiClient.assertValidId error: id cannot be empty");if("string"!=typeof e)throw new TypeError("ApiClient.assertValidId error: id should be a string")}assertMethod(e){"string"!=typeof e&&new TypeError("ApiClient.assertValidMethod method should be a string.");["GET","POST","PUT","DELETE"].indexOf(e)<0&&new TypeError(`ApiClient.assertValidMethod error: method ${e} is not supported.`)}assertUrl(e){if(!e)throw new TypeError("ApliClient.assertUrl error: url is required.");if(!(e instanceof URL))throw new TypeError("ApliClient.assertUrl error: url should be a valid URL object.")}assertBody(e){"string"==typeof e||e instanceof FormData||new TypeError("ApiClient.assertBody error: body should be a string or an instance of FormData.")}buildBody(e){return JSON.stringify(e)}buildUrl(e,t){if("string"!=typeof e)throw new TypeError("ApiClient.buildUrl error: url should be a string.");const r=new URL(`${e}.json?${this.apiVersion}`);t=t||{};for(const[e,s]of Object.entries(t)){if("string"!=typeof e)throw new TypeError("ApiClient.buildUrl error: urlOptions key should be a string.");if("string"==typeof s)r.searchParams.append(e,s);else{if(!Array.isArray(s))throw new TypeError("ApiClient.buildUrl error: urlOptions value should be a string or array.");s.forEach((t=>{r.searchParams.append(e,t)}))}}return r}async fetchAndHandleResponse(e,t,r,s){let i,o;this.assertUrl(t),this.assertMethod(e),r&&this.assertBody(r);const n={...this.buildFetchOptions(),...s};n.method=e,r&&(n.body=r);try{i=await fetch(t.toString(),n)}catch(e){throw new be(e.message)}try{o=await i.json()}catch(e){throw console.error(t.toString(),e),new fe(e,i)}if(!i.ok){const e=o.header.message;throw new Se(e,{code:i.status,body:o.body})}return o}};const Te=class{constructor(e,t){e.setResourceName(t),this.apiClient=new Ae(e)}formatContainOptions(e,t){const r={};for(const s in e){if("string"!=typeof s){const t=JSON.stringify(e);throw new TypeError(`Invalid contain ${t}, items should be a string.`)}t.includes(s)&&(r[`contain[${s}]`]=e[s]?"1":"0")}return r}formatFilterOptions(e,t){const r={};for(const s in e)if(Object.prototype.hasOwnProperty.call(e,s)&&t.includes(s))if("boolean"==typeof e[s])r[`filter[${s}]`]=e[s]?"1":"0";else if("string"==typeof e[s])r[`filter[${s}]`]=e[s];else{if(!Array.isArray(e[s]))throw new TypeError("Service error. Filter option should be an array or a string.");r[`filter[${s}][]`]=e[s]}return r}formatOrderOptions(e,t){const r={};for(const s in e)t.includes(s)&&(r["order[]"]=s);return r}assertValidId(e){if(!e||"string"!=typeof e||!J().isUUID(e))throw new TypeError(`Service error. The id '${e}' is not a valid uuid.`)}assertNonEmptyData(e){if(!e)throw new TypeError("Service error. Data cannot be empty.")}};class Ie extends Te{constructor(e){super(e,Ie.RESOURCE_NAME)}static get RESOURCE_NAME(){return"users"}static getSupportedContainOptions(){return["LastLoggedIn","is_mfa_enabled","last_logged_in","gpgkey","groups_users","profile","account_recovery_user_setting","pending_account_recovery_request"]}static getSupportedFiltersOptions(){return["search","has-groups","has-access","is-admin"]}static getSupportedOrdersOptions(){return["Profile.first_name DESC","Profile.first_name ASC","Profile.last_name DESC","Profile.last_name ASC","Profile.created DESC","Profile.created ASC","Profile.modified DESC","Profile.modified ASC"]}async get(e,t){this.assertValidId(e),t=t?this.formatContainOptions(t,Ie.getSupportedContainOptions()):null;const r={...t};return(await this.apiClient.get(e,r)).body}async findAll(e,t,r){const s=Ie.remapToLegacyContain(e);e=e?this.formatContainOptions(s,Ie.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,Ie.getSupportedFiltersOptions()):null,r=r?this.formatOrderOptions(r,Ie.getSupportedFiltersOptions()):null;const i={...e,...t,...r},o=await this.apiClient.findAll(i);return o.body&&o.body.length?o.body:[]}static remapToLegacyContain(e){if(e)return Object.prototype.hasOwnProperty.call(e,"last_logged_in")&&(e.LastLoggedIn=e.last_logged_in,delete e.last_logged_in),e}async create(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async update(e,t){this.assertValidId(e),this.assertNonEmptyData(t);return(await this.apiClient.update(e,t)).body}async updateAvatar(e,t,r){this.assertValidId(e),this.assertNonEmptyData(t),this.assertNonEmptyData(r);const s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e}`),i=new FormData;i.append("profile[avatar][file]",t,r);const o=this.apiClient.buildFetchOptions();delete o.headers["content-type"];return(await this.apiClient.fetchAndHandleResponse("POST",s,i,o)).body}async delete(e,t,r){this.assertValidId(e);const s=t?{transfer:t}:{};return(await this.apiClient.delete(e,s,{},r)).body}async resendInvite(e){const t=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover`),r={username:e},s=this.apiClient.buildBody(r);return this.apiClient.fetchAndHandleResponse("POST",t,s)}async findCsrfToken(){try{const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/csrf-token`,{});return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}catch(e){if(e instanceof Se&&e.data&&(404===e.data.code||403===e.data.code))return this.findLegacyCsrfToken();throw e}}async findLegacyCsrfToken(){const e=new URL(`${this.apiClient.baseUrl}/recover`);let t,r;try{t=await fetch(e.toString())}catch(e){throw new be}try{r=await t.text();const e=new DOMParser,s=e.parseFromString(r,"text/html").getElementsByName("_csrfToken");if(!s[0]||!/^[a-z0-9]{128}$/.test(s[0].value))throw new Error("No valid CSRF token found using legacy strategy.");return s[0].value}catch(e){throw new fe}}async keepSessionAlive(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/me`,{});return await this.apiClient.fetchAndHandleResponse("GET",e),!0}async requestHelpCredentialsLost(e){const t=this.apiClient.buildBody(e),r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover`,{});return(await this.apiClient.fetchAndHandleResponse("POST",r,t)).body}}const Re=Ie;const Ce=class{constructor(e){this.setToken(e)}setToken(e){this.validate(e),this.token=e}validate(e){if(!e)throw new TypeError("CSRF token cannot be empty.");if("string"!=typeof e)throw new TypeError("CSRF token should be a string.")}toFetchHeaders(){return{"X-CSRF-Token":this.token}}};const Oe=class{setBaseUrl(e){if(!e)throw new TypeError("ApiClientOption baseUrl is required.");if("string"==typeof e)try{this.baseUrl=new URL(e)}catch(e){throw new TypeError("ApiClientOption baseUrl is invalid.")}else{if(!(e instanceof URL))throw new TypeError("ApiClientOptions baseurl should be a string or URL");this.baseUrl=e}return this}setCsrfToken(e){if(!e)throw new TypeError("ApiClientOption csrfToken is required.");if("string"==typeof e)this.csrfToken=new Ce(e);else{if(!(e instanceof Ce))throw new TypeError("ApiClientOption csrfToken should be a string or a valid CsrfToken.");this.csrfToken=e}return this}setResourceName(e){if(!e)throw new TypeError("ApiClientOptions.setResourceName resourceName is required.");if("string"!=typeof e)throw new TypeError("ApiClientOptions.setResourceName resourceName should be a valid string.");return this.resourceName=e,this}getBaseUrl(){return this.baseUrl}getResourceName(){return this.resourceName}getCsrfToken(){return this.csrfToken}getHeaders(){if(this.csrfToken)return this.csrfToken.toFetchHeaders()}},ke=function(e){return"string"==typeof e&&!/[\u{10000}-\u{10FFFF}]/u.test(e)},Ne=function(e){return"string"==typeof e},Pe=Y("log"),Ue={error:1,warning:2,info:3,debug:4};let xe=[];const Me=function(){};Me.write=function(e){if(0==Pe.level||Pe.level<Ue[e.level])return;function t(e){return e<10?`0${e}`:e}e.date||(e.date=new Date);const r=t(e.date.getHours()),s=t(e.date.getMinutes()),i=t(e.date.getSeconds()),o=t(e.date.getMilliseconds());if(e.created=`${r}:${s}:${i}:${o}`,xe.push(e),Pe.console){const t=`${e.created} [${e.level}] ${e.message}`;"error"===e.level?console.error(t):"warning"===e.level?console.warn(t):console.log(t)}},Me.init=function(){xe=[]};const Le=Me;var De=r(7187);r(4889);const Fe=class{constructor(){this._locked=!1,this._ee=new De.EventEmitter}acquire(){return new Promise((e=>{if(!this._locked)return this._locked=!0,e();const t=()=>{if(!this._locked)return this._locked=!0,this._ee.removeListener("release",t),e()};this._ee.on("release",t)}))}release(){this._locked=!1,setImmediate((()=>this._ee.emit("release")))}},qe=new Fe,Ke="PassphraseStorageFlush",$e="SessionKeepAlive",je="passphrase";const Be=class{static async init(){this._handleFlushEvent=this._handleFlushEvent.bind(this),this._handleKeepSessionAlive=this._handleKeepSessionAlive.bind(this),await this.flush()}static async set(e,t){if(await qe.acquire(),await u.storage.session.set({[je]:e}),qe.release(),await this._clearFlushAlarms(),t>=0){const e=Date.now()+1e3*t;u.alarms.create(Ke,{when:e}),u.alarms.onAlarm.addListener(this._handleFlushEvent)}await u.alarms.get($e)||this._keepAliveSession()}static async get(){return(await u.storage.session.get(je))?.[je]||null}static async flushPassphrase(){await qe.acquire(),await u.storage.session.remove(je),qe.release()}static isSessionKeptUntilLogOut(){return!u.alarms.onAlarm.hasListener(this._handleFlushEvent)}static async flush(){return Le.write({level:"debug",message:"PassphraseStorageService flushed"}),Promise.all([this.flushPassphrase(),this._clearFlushAlarms(),this._clearKeepAliveAlarms()])}static async stopSessionKeepAlive(){this._clearKeepAliveAlarms()}static async _clearFlushAlarms(){await u.alarms.clear(Ke),u.alarms.onAlarm.hasListener(this._handleFlushEvent)&&u.alarms.onAlarm.removeListener(this._handleFlushEvent)}static async _clearKeepAliveAlarms(){await u.alarms.clear($e),u.alarms.onAlarm.hasListener(this._handleKeepSessionAlive)&&u.alarms.onAlarm.removeListener(this._handleKeepSessionAlive)}static async _handleFlushEvent(e){e.name===Ke&&await this.flush()}static async _handleKeepSessionAlive(e){if(e.name!==$e)return;if(null===await this.get())return;const t=Ye.getInstance(),r=await t.getApiClientOptions();new Re(r).keepSessionAlive()}static _keepAliveSession(){u.alarms.create($e,{delayInMinutes:15,periodInMinutes:15}),u.alarms.onAlarm.addListener(this._handleKeepSessionAlive)}},Ge=function(){this.settings=new Q,this._user={},this._csrfToken=null,this.validate=function(e,t){void 0===t&&(t=["id","username","firstname","lastname"]);const r=[];for(const s in t){const i=t[s];try{this.__validate(i,e[i])}catch(e){const t={};t[i]=e.message,r.push(t)}}if(r.length>0){const e=new Error("user could not be validated");throw e.validationErrors=r,e}return e},this.__validate=function(e,t){switch(e){case"firstname":if(void 0===t||""===t)throw new Error("The first name cannot be empty");if(!ke(t))throw new Error("The first name should be a valid UTF8 string");if(!J().isLength(t,0,255))throw new Error("The first name length should be maximum 255 characters.");break;case"lastname":if(void 0===t||""===t)throw new Error("The last name cannot be empty");if(!ke(t))throw new Error("The last name should be a valid UTF8 string");if(!J().isLength(t,0,255))throw new Error("The last name length should be maximum 255 characters.");break;case"username":if(void 0===t||""===t)throw new Error("The username cannot be empty");if(!J().isEmail(t))throw new Error("The username should be a valid email address");if(!J().isLength(t,0,255))throw new Error("The username length should be maximum 255 characters.");break;case"id":if(void 0===t||""===t)throw new Error("The user id cannot be empty");if(!J().isUUID(t))throw new Error("The user id should be a valid UUID");break;default:throw new Error(`No validation defined for field: ${e}`)}return!0},this.setName=function(e,t){return this.__validate("firstname",e),this.__validate("lastname",t),this._user.lastname=t,this._user.firstname=e,z("user.firstname",e)&&z("user.lastname",t)},this.setUsername=function(e){return this.__validate("username",e),this._user.username=e,z("user.username",e)},this.setId=function(e){return this.__validate("id",e),this._user.id=e,z("user.id",e)},this.set=function(e){if(void 0===e)throw new Error("The user cannot be empty");return this.setId(e.id),this.setUsername(e.username),this.setName(e.firstname,e.lastname),void 0!==e.settings&&this.settings.set(e.settings),this._user},this.get=function(e){try{void 0!==e&&void 0!==e.user?this._getLocal(e.user):this._getLocal();const t=this._user;return void 0!==e&&void 0!==e.user&&void 0!==e.settings?t.settings=this.settings.get(e.settings):void 0===e&&(t.settings=this.settings.get()),t}catch(e){throw new Error("The user is not set")}},this._getLocal=function(e){void 0===e&&(e=["id","username","firstname","lastname"]);for(const t in e){const r=e[t];this._user[r]=Y(`user.${r}`);try{this.__validate(r,this._user[r])}catch(e){throw this._user[r]={},new Error("The user is not set")}}return this._user},this.isValid=function(){try{this.get()}catch(e){return!1}return this.settings.isValid()},this.retrieveAndStoreCsrfToken=async function(){const e=(new Oe).setBaseUrl(this.settings.getDomain()),t=new Re(e),r=await t.findCsrfToken();this.setCsrfToken(r)},this.getCsrfToken=function(){return this._csrfToken},this.getOrFetchCsrfToken=async function(){return this._csrfToken||await this.retrieveAndStoreCsrfToken(),this._csrfToken},this.setCsrfToken=function(e){this._csrfToken=e},this.getApiClientOptions=async function(e){e=Object.assign({requireCsrfToken:!0},e);const t=(new Oe).setBaseUrl(this.settings.getDomain());return e.requireCsrfToken&&t.setCsrfToken(await this.getOrFetchCsrfToken()),t},this.updateSecurityToken=async function(e){this.settings.setSecurityToken(e)}},Ye=function(){let e;return{getInstance:function(){return e||(e=new Ge),e},init:function(){self.addEventListener("passbolt.auth.after-logout",(async()=>await Be.flush()))}}}(),ze=new Fe;class Ve{static async flush(){return Le.write({level:"debug",message:"AuthStatusLocalStorage flushed"}),await u.storage.local.remove(Ve.AUTH_STATUS_STORAGE_KEY)}static async get(){const e=await u.storage.local.get([Ve.AUTH_STATUS_STORAGE_KEY]);if(e)return e[Ve.AUTH_STATUS_STORAGE_KEY]}static async set(e,t){await ze.acquire(),e=!0===e,t=!1!==t;const r={};r[Ve.AUTH_STATUS_STORAGE_KEY]={isAuthenticated:e,isMfaRequired:t},await u.storage.local.set(r),ze.release()}static get AUTH_STATUS_STORAGE_KEY(){return"auth_status"}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const He=Ve;const We=class{constructor(e){if(void 0===e)this.token="gpgauthv1.3.0|36|",this.token+=K(),this.token+="|gpgauthv1.3.0";else{const t=this.validate("token",e);if(!0!==t)throw t;this.token=e}}validate(e,t){let r=[];return"token"===e?void 0===t||""===t?new Error("The user authentication token cannot be empty"):(r=t.split("|"),4!==r.length?new Error("The user authentication token is not in the right format"):r[0]!==r[3]&&"gpgauthv1.3.0"!==r[0]?new Error("Passbolt does not support this GPGAuth version"):"36"!==r[1]?new Error(`Passbolt does not support GPGAuth token nonce longer than 36 characters: ${r[2]}`):!!J().isUUID(r[2])||new Error("Passbolt does not support GPGAuth token nonce that are not UUIDs")):new Error(`No validation defined for field: ${e}`)}};class Je extends Error{constructor(e){super(e=e||w.t("MFA authentication is required.")),this.name="MfaAuthenticationRequiredError"}}const Qe=Je;class Ze extends Te{constructor(e){super(e,Ze.RESOURCE_NAME)}static get RESOURCE_NAME(){return"settings"}async find(){const e=await this.apiClient.findAll(),t=JSON.parse(JSON.stringify(e.body));if(t.serverTimeDiff=null,e.header.servertime){const r=new Date;t.serverTimeDiff=1e3*e.header.servertime-r.getTime()}return t}}const Xe=Ze;class et extends X{constructor(e){const t=Object.assign(et.getDefault(),e);super(se.validate(et.ENTITY_NAME,t,et.getSchema()))}static getDefault(){return{status:et.ORGANIZATION_ENABLED}}static getSchema(){return{type:"object",required:[],properties:{status:{type:"string",enum:[et.ORGANIZATION_ENABLED,et.ORGANIZATION_DISABLED,et.ORGANIZATION_NOT_FOUND]},app:{type:"object"},passbolt:{type:"object"},serverTimeDiff:{anyOf:[{type:"integer"},{type:"null"}]}}}}static get disabledOrganizationSettings(){return{status:this.ORGANIZATION_DISABLED}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get locale(){return this._props.app&&this._props.app.locale}isPluginEnabled(e){const t=this._props?.passbolt?.plugins?.[e];return t&&!1!==t?.enabled}getPluginSettings(e){if(this.isPluginEnabled(e))return this._props.passbolt.plugins[e]}isServerInPast(){return(this._props.serverTimeDiff||0)<0}get serverTime(){const e=new Date,t=this._props.serverTimeDiff||0;return new Date(e.getTime()+t).getTime()}static get ENTITY_NAME(){return"OrganizationSettings"}static get ORGANIZATION_ENABLED(){return"enabled"}static get ORGANIZATION_DISABLED(){return"disabled"}static get ORGANIZATION_NOT_FOUND(){return"not found"}}const tt=et;let rt;const st=class{constructor(e){this.organizationSettingsService=new Xe(e)}async getOrFind(e){return!e&&rt||(rt=await this.find()),rt}static flushCache(){rt=null}async find(){let e;try{e=await this.organizationSettingsService.find()}catch(t){t instanceof Se&&403===t?.data?.code&&(e=tt.disabledOrganizationSettings)}return new tt(e)}};class it extends Error{constructor(e){super(e),this.name="UserAlreadyLoggedInError"}}const ot=it,nt=function(e,t){this.headers={};const r=["x-gpgauth-version","x-gpgauth-authenticated","x-gpgauth-progress","x-gpgauth-user-auth-token","x-gpgauth-verify-response","x-gpgauth-refer","x-gpgauth-debug","x-gpgauth-error"];let s;for(let t=0;t<r.length;t++)s=r[t],e.has(s)&&(this.headers[s]=e.get(s));return this.__validate(t)};nt.prototype.__validate=function(e){const t=this.__validateCommonAllStage();if(t instanceof Error)throw t;const r=this.__validateByStage(e);if(r instanceof Error)throw r;return!0},nt.prototype.__validateCommonAllStage=function(){let e;return void 0===this.headers?new Error("No GPGAuth headers set."):"string"!=typeof this.headers["x-gpgauth-version"]||"1.3.0"!==this.headers["x-gpgauth-version"]?new Error(`That version of GPGAuth is not supported. (${this.headers["x-gpgauth-version"]})`):void 0===this.headers["x-gpgauth-error"]||(e=void 0!==this.headers["x-gpgauth-debug"]?this.headers["x-gpgauth-debug"]:"There was an error during authentication. Enable debug mode for more information",new Error(e))},nt.prototype.__validateByStage=function(e){switch(e){case"logout":if("string"!=typeof this.headers["x-gpgauth-authenticated"]||"false"!=this.headers["x-gpgauth-authenticated"])return new Error("x-gpgauth-authenticated should be set to false during the logout stage");break;case"verify":case"stage0":if("string"!=typeof this.headers["x-gpgauth-authenticated"]||"false"!=this.headers["x-gpgauth-authenticated"])return new Error("x-gpgauth-authenticated should be set to false during the verify stage");if("string"!=typeof this.headers["x-gpgauth-progress"]||"stage0"!=this.headers["x-gpgauth-progress"])return new Error("x-gpgauth-progress should be set to stage0 during the verify stage");if(void 0!==this.headers["x-gpgauth-user-auth-token"])return new Error("x-gpgauth-user-auth-token should not be set during the verify stage"+typeof this.headers["x-gpgauth-user-auth-token"]);if("string"!=typeof this.headers["x-gpgauth-verify-response"])return new Error("x-gpgauth-verify-response should be set during the verify stage");if(void 0!==this.headers["x-gpgauth-refer"])return new Error("x-gpgauth-refer should not be set during verify stage");break;case"stage1":return"string"!=typeof this.headers["x-gpgauth-authenticated"]||"false"!=this.headers["x-gpgauth-authenticated"]?new ot("x-gpgauth-authenticated should be set to false during stage1"):"string"!=typeof this.headers["x-gpgauth-progress"]||"stage1"!=this.headers["x-gpgauth-progress"]?new Error("x-gpgauth-progress should be set to stage1"):void 0===this.headers["x-gpgauth-user-auth-token"]?new Error("x-gpgauth-user-auth-token should be set during stage1"):void 0!==this.headers["x-gpgauth-verify-response"]?new Error("x-gpgauth-verify-response should not be set during stage1"):void 0===this.headers["x-gpgauth-refer"]||new Error("x-gpgauth-refer should not be set during stage1");case"complete":return"string"!=typeof this.headers["x-gpgauth-authenticated"]||"true"!=this.headers["x-gpgauth-authenticated"]?new Error("x-gpgauth-authenticated should be set to true when GPGAuth is complete"):"string"!=typeof this.headers["x-gpgauth-progress"]||"complete"!=this.headers["x-gpgauth-progress"]?new Error("x-gpgauth-progress should be set to complete during final stage"):void 0!==this.headers["x-gpgauth-user-auth-token"]?new Error("x-gpgauth-user-auth-token should not be set during final stage"):void 0!==this.headers["x-gpgauth-verify-response"]?new Error("x-gpgauth-verify-response should not be set during final stage"):"string"==typeof this.headers["x-gpgauth-refer"]||new Error("x-gpgauth-refer should be set during final stage");default:return new Error("Unknown GPGAuth stage")}};const at=nt;class ct extends Error{constructor(e){super(e=e||"NotFoundError"),this.name="NotFoundError"}}const ut=ct;class pt{}pt.useLegacyIsAuthenticatedEntryPoint=null,pt.isAuthenticated=async function(){let e;if(null===pt.useLegacyIsAuthenticatedEntryPoint)try{e=await lt(),pt.useLegacyIsAuthenticatedEntryPoint=!1}catch(t){if(!(t instanceof ut))throw t;e=await dt(),pt.useLegacyIsAuthenticatedEntryPoint=!0}else e=pt.useLegacyIsAuthenticatedEntryPoint?await dt():await lt();return e};const lt=async function(){const e={method:"GET",credentials:"include",headers:{Accept:"application/json","content-type":"application/json"}},t=`${Ye.getInstance().settings.getDomain()}/auth/is-authenticated.json`;let r;try{r=await fetch(t,e)}catch(e){throw new be(e.message)}try{await r.json()}catch(e){throw new fe}if(r.ok)return!0;if(/mfa\/verify\/error\.json$/.test(r.url))throw new Qe;if(404===r.status)throw new ut;return!1},dt=async function(){const e={method:"GET",credentials:"include",headers:{Accept:"application/json","content-type":"application/json"}},t=`${Ye.getInstance().settings.getDomain()}/auth/checksession.json`;let r;try{r=await fetch(t,e)}catch(e){throw new be(e.message)}try{await r.json()}catch(e){throw new fe}if(r.ok)return!0;if(/mfa\/verify\/error\.json$/.test(r.url))throw new Qe;if(404==r.status)throw new ut;return!1},ht=pt;class gt{}gt.setCsrfHeader=function(e,t){e=e||{};const r=t.getCsrfToken();return r&&gt.setHeader(e,"X-CSRF-Token",r),e},gt.setHeader=function(e,t,r){return(e=e||{}).headers=e.headers||{},e.headers[t]=r,e};const yt=gt;var _t=r(7626),mt=r.n(_t),wt=r(8380),ft=r.n(wt);const Et="/auth/verify.json?api-version=v2",St="/auth/login.json?api-version=v2",vt=6e4,bt=2147483647;const At=class{constructor(e){this.keyring=e||new ge,this.checkIsAuthenticatedTimeout=null,this.authStatus=null}getDomain(){return Ye.getInstance().settings.getDomain()}async verify(e,t,r){const s=e||this.getDomain();t=t||this.keyring.findPublic(K(s)).armoredKey;const i=r||this.keyring.findPrivate().fingerprint;let o,n;try{n=new We;const e=await M(t);o=await ye.encrypt(n.token,e)}catch(e){throw new Error(`Unable to encrypt the verify token. ${e.message}`)}const a=new FormData;a.append("data[gpg_auth][keyid]",i),a.append("data[gpg_auth][server_verify_token]",o);const c={method:"POST",credentials:"include",body:a};yt.setCsrfHeader(c,Ye.getInstance());const u=await fetch(s+Et,c);if(!u.ok){const e=await u.json();if(void 0!==e.header)throw new Error(e.header.message);{const e=`Server request failed (${u.status}) without providing additional information.`;throw new Error(e)}}const p=new at(u.headers,"verify");if(new We(p.headers["x-gpgauth-verify-response"]).token!==n.token)throw new Error("The server was unable to prove it can use the advertised OpenPGP key.")}async serverKeyChanged(){const e=(await this.getServerKey()).keydata,t=await M(e),r=this.getServerKeyFromKeyring().armoredKey,s=await M(r);return!await me.areKeysTheSame(t,s)}getServerKeyFromKeyring(){return this.keyring.findPublic(K(this.getDomain()))}isServerKeyExpired(){return this.getServerKeyFromKeyring().isExpired}async getServerKey(e){const t=e||this.getDomain(),r=await fetch(t+Et,{method:"GET",credentials:"include"});if(!r.ok){const e=`There was a problem when trying to communicate with the server (Code: ${r.status})`;throw new Error(e)}return(await r.json()).body}async login(e){const t=await de.getKeyInfo(e),r=await this.stage1(t);await this.stage2(r,t)}async stage1(e){const t=this.getDomain()+St,r=new FormData;r.append("data[gpg_auth][keyid]",e.fingerprint);const s={method:"POST",credentials:"include",body:r};yt.setCsrfHeader(s,Ye.getInstance());const i=await fetch(t,s);if(!i.ok)return this.onResponseError(i);const o=new at(i.headers,"stage1"),n=ft()(mt()(o.headers["x-gpgauth-user-auth-token"])),a=await M(e.armoredKey),c=await U(n),u=await _e.decrypt(c,a);return new We(u).token}async stage2(e,t){const r=this.getDomain()+St,s=Ye.getInstance().settings.getDomain(),i=new FormData;i.append("data[gpg_auth][keyid]",t.fingerprint),i.append("data[gpg_auth][user_token_result]",e);const o={method:"POST",credentials:"include",body:i};yt.setCsrfHeader(o,Ye.getInstance());const n=await fetch(r,o);n.ok||await this.onResponseError(n);return s+new at(n.headers,"complete").headers["x-gpgauth-refer"]}async onResponseError(e){const t=`There was a server error. No additional information provided(${e.status}`;let r;try{r=await e.json()}catch(e){throw new Error(t)}if(void 0!==r.header)throw new Error(r.header.message);throw new Error(t)}async isAuthenticated(e){return(await this.checkAuthStatus(e)).isAuthenticated}async isMfaRequired(){return(await this.checkAuthStatus()).isMfaRequired}async checkAuthStatus(e){let t,r;if(!(e=Object.assign({requestApi:!0},e)).requestApi)try{const e=await He.get();if(e)return this.authStatus=e,this.authStatus}catch(e){}try{t=await ht.isAuthenticated(),r=!1}catch(e){if(!(e instanceof Qe))throw e;t=!0,r=!0}return this.authStatus={isAuthenticated:t,isMfaRequired:r},await He.set(t,r),this.authStatus}async startCheckAuthStatusLoop(){const e=await this.getCheckAuthStatusTimeoutPeriod();this.checkAuthStatusTimeout&&clearTimeout(this.checkAuthStatusTimeout),this.checkAuthStatusTimeout=setTimeout((async()=>{await this.isAuthenticated()?this.startCheckAuthStatusLoop():self.dispatchEvent(new Event("passbolt.auth.after-logout"))}),e)}async getCheckAuthStatusTimeoutPeriod(){let e=vt;if(!0===ht.useLegacyIsAuthenticatedEntryPoint){const t=Ye.getInstance().settings.getDomain(),r=(new Oe).setBaseUrl(t),s=new st(r),i=await s.getOrFind();let o=24;i&&i.app&&i.app.session_timeout&&(o=i.app.session_timeout),e=1e3*(60*o+1),e>bt&&(e=bt),e<vt&&(e=vt)}return e}};class Tt extends X{constructor(e){super(se.validate(Tt.ENTITY_NAME,e,Tt.getSchema()))}static getSchema(){return{type:"object",required:["user_id","is_admin"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},group_id:{type:"string",format:"uuid"},is_admin:{type:"boolean"},created:{type:"string",format:"date-time"}}}}toDto(){return Object.assign({},this._props)}get id(){return this._props.id||null}get userId(){return this._props.user_id}get groupId(){return this._props.group_id||null}get isAdmin(){return this._props.is_admin}get created(){return this._props.created||null}set id(e){if(!J().isUUID(e))throw new TypeError("The group user id should be a valid UUID.");this._props.id=e}static get ENTITY_NAME(){return"GroupUser"}static get ALL_CONTAIN_OPTIONS(){return{}}}const It=Tt;class Rt extends X{constructor(e,t){super(e),t?(this._props=null,this._items=t):this._items=[]}toDto(){return JSON.parse(JSON.stringify(this._items))}toJSON(){return this.toDto()}get items(){return this._items}get length(){return this._items.length}[Symbol.iterator](){let e=0;return{next:()=>e<this._items.length?{value:this._items[e++],done:!1}:{done:!0}}}getAll(e,t){if("string"!=typeof e||"string"!=typeof t)throw new TypeError("EntityCollection find by expect propName and search to be strings");return this._items.filter((r=>Object.prototype.hasOwnProperty.call(r._props,e)&&r._props[e]===t))}getFirst(e,t){if("string"!=typeof e||"string"!=typeof t)throw new TypeError("EntityCollection getFirst by expect propName and search to be strings");const r=this.getAll(e,t);if(r&&r.length)return r[0]}push(e){return this._items.push(e),this._items.length}unshift(e){return this._items.unshift(e),this._items.length}}const Ct=Rt;class Ot extends Ct{constructor(e){super(se.validate(Ot.ENTITY_NAME,e,Ot.getSchema())),this._props.forEach((e=>{this.push(new It(e))})),this._props=null}static getSchema(){return{type:"array",items:It.getSchema()}}static sanitizeDto(e){if(!Array.isArray(e))return[];return e.filter((e=>{try{return new It(e),!0}catch(e){return!1}}))}get groupsUsers(){return this._items}static get ENTITY_NAME(){return"GroupsUsers"}push(e){if(!e||"object"!=typeof e)throw new TypeError("GroupUsersEntity push parameter should be an object.");e instanceof It&&(e=e.toDto(It.ALL_CONTAIN_OPTIONS)),e=new It(e),super.push(e)}getGroupUserByUserId(e){return this.groupsUsers.find((t=>t.userId===e))}getById(e){return this.items.find((t=>t.id===e))}}const kt=Ot;class Nt extends X{constructor(e){super(se.validate(Nt.ENTITY_NAME,e,Nt.getSchema()))}static getSchema(){return{type:"object",required:["id","name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",enum:[Nt.ROLE_ADMIN,Nt.ROLE_USER,Nt.ROLE_GUEST,Nt.ROLE_ROOT]},description:{type:"string",maxLength:255},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id}get name(){return this._props.name}get description(){return this._props.description||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"Role"}static get ROLE_ADMIN(){return"admin"}static get ROLE_USER(){return"user"}static get ROLE_GUEST(){return"guest"}static get ROLE_ROOT(){return"root"}}const Pt=Nt;class Ut extends X{constructor(e){super(se.validate(Ut.ENTITY_NAME,e,Ut.getSchema()))}static getSchema(){return{type:"object",required:["url"],properties:{id:{type:"string",format:"uuid"},url:{type:"object",required:[Ut.AVATAR_URL_SIZE_MEDIUM,Ut.AVATAR_URL_SIZE_SMALL],properties:{medium:{type:"string"},small:{type:"string"}}},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id||null}get userId(){return this._props.user_id||null}get urlMedium(){return this._props.url.medium}get urlSmall(){return this._props.url.small}getUrl(e){if(!e)throw new TypeError("A size is needed.");if("medium"!==e||"small"!==e)throw new TypeError("Invalid size, use small or medium.");return this._props.url[e]}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"Avatar"}static get AVATAR_URL_SIZE_MEDIUM(){return"medium"}static get AVATAR_URL_SIZE_SMALL(){return"small"}}const xt=Ut;class Mt extends X{constructor(e){super(se.validate(Mt.ENTITY_NAME,e,Mt.getSchema())),this._props.avatar&&(this._avatar=new xt(this._props.avatar),delete this._props.avatar)}static getSchema(){return{type:"object",required:["first_name","last_name"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},first_name:{type:"string",minLength:1,maxLength:255},last_name:{type:"string",minLength:1,maxLength:255},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},avatar:xt.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return this.avatar&&e&&e.avatar&&(t.avatar=this.avatar.toDto()),t}toJSON(){return this.toDto(Mt.ALL_CONTAIN_OPTIONS)}static get ENTITY_NAME(){return"Profile"}static get ALL_CONTAIN_OPTIONS(){return{avatar:!0}}get id(){return this._props.id}get name(){return`${this._props.first_name} ${this._props.last_name}`}get firstName(){return this._props.first_name}get lastName(){return this._props.last_name}get userId(){return this._props.user_id}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get avatar(){return this._avatar||null}}const Lt=Mt;class Dt extends X{constructor(e){super(se.validate(Dt.ENTITY_NAME,e,Dt.getSchema()))}static getSchema(){return{type:"object",required:["user_id","armored_key"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},fingerprint:{type:"string",minLength:40,maxLength:40},armored_key:{type:"string"},deleted:{type:"boolean"},type:{anyOf:[{type:"string"},{type:"null"}]},uid:{type:"string"},bits:{anyOf:[{type:"integer"},{type:"null"}]},key_id:{type:"string",minLength:8,maxLength:16},key_created:{type:"string",format:"date-time"},expires:{anyOf:[{type:"string",format:"date-time"},{type:"null"}]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id||null}get userId(){return this._props.user_id}get armoredKey(){return this._props.armored_key}get fingerprint(){return this._props.fingerprint}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}static get ENTITY_NAME(){return"gpgkey"}}const Ft=Dt;class qt extends X{constructor(e){super(se.validate(qt.ENTITY_NAME,e,qt.getSchema()))}static getSchema(){return{type:"object",required:["account_recovery_request_id","responder_foreign_key","responder_foreign_model","status"],properties:{id:{type:"string",format:"uuid"},account_recovery_request_id:{type:"string",format:"uuid"},responder_foreign_key:{type:"string",format:"uuid"},responder_foreign_model:{type:"string",enum:[this.RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY]},data:{type:"string"},status:{type:"string",enum:[this.STATUS_REJECTED,this.STATUS_APPROVED]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}get id(){return this._props.id||null}get status(){return this._props.status}get data(){return this._props.data||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}static get ENTITY_NAME(){return"AccountRecoveryResponse"}static get STATUS_APPROVED(){return"approved"}static get STATUS_REJECTED(){return"rejected"}static get RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY(){return"AccountRecoveryOrganizationKey"}}const Kt=qt;class $t extends Error{constructor(e,t,r){if(super(r=r||"Entity collection error."),"number"!=typeof e)throw new TypeError("EntityCollectionError requires a valid position");if(!t||"string"!=typeof t)throw new TypeError("EntityCollectionError requires a valid rule");if(!r||"string"!=typeof r)throw new TypeError("EntityCollectionError requires a valid rule");this.position=e,this.rule=t}}const jt=$t,Bt=(e,t)=>{if(!Array.isArray(e))throw new TypeError("deduplicateObjects first parameter should be an array.");if("string"!=typeof t)throw new TypeError("deduplicateObjects second parameter should be a string.");const r=e.filter((e=>Object.prototype.hasOwnProperty.call(e,t))).map((e=>e[t])).reduce(((e,t,r)=>(e[t]=Object.prototype.hasOwnProperty.call(e,t)?e[t]:r,e)),{});return e.filter(((e,s)=>!Object.prototype.hasOwnProperty.call(e,t)||r[e[t]]===s))};class Gt extends Ct{constructor(e){super(se.validate(Gt.ENTITY_NAME,e,Gt.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,Gt.RULE_UNIQUE_ID,`AccountRecoveryRequest id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Kt(e))})),this._props=null}static getSchema(){return{type:"array",items:Kt.getSchema()}}get accountRecoveryResponses(){return this._items}get ids(){return this._items.map((e=>e.id))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.accountRecoveryResponses.length;let r=0;for(;r<t;r++){const t=this.accountRecoveryResponses[r];if(t.id&&t.id===e.id)throw new jt(r,Gt.RULE_UNIQUE_ID,`account recovery private key password id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("accountRecoveryResponsesCollection push parameter should be an object.");e instanceof Kt&&(e=e.toDto());const t=new Kt(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"AccountRecoveryResponse"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Yt=Gt;class zt extends X{constructor(e){super(se.validate(zt.ENTITY_NAME,e,zt.getSchema()))}static getSchema(){return{type:"object",required:["recipient_foreign_model","recipient_fingerprint","data"],properties:{id:{type:"string",format:"uuid"},private_key_id:{type:"string",format:"uuid"},recipient_foreign_model:{type:"string",enum:[zt.FOREIGN_MODEL_ORGANIZATION_KEY]},recipient_foreign_key:{type:"string",format:"uuid"},recipient_fingerprint:{type:"string",length:40},data:{type:"string"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get id(){return this._props.id||null}get privateKeyId(){return this._props.private_key_id||null}get recipientForeignKey(){return this._props.recipient_foreign_key||null}get data(){return this._props.data}get recipientForeignModel(){return this._props.recipient_foreign_model}get recipientFingerprint(){return this._props.recipient_fingerprint}static get ENTITY_NAME(){return"AccountRecoveryPrivateKeyPassword"}static get FOREIGN_MODEL_ORGANIZATION_KEY(){return"AccountRecoveryOrganizationKey"}}const Vt=zt;class Ht extends Ct{constructor(e){super(se.validate(Ht.ENTITY_NAME,e,Ht.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,Ht.RULE_UNIQUE_ID,`AccountRecoveryPrivateKeyPassword id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Vt(e))})),this._props=null}static getSchema(){return{type:"array",items:Vt.getSchema()}}get accountRecoveryPrivateKeyPasswords(){return this._items}get ids(){return this._items.map((e=>e.id))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.accountRecoveryPrivateKeyPasswords.length;let r=0;for(;r<t;r++){const t=this.accountRecoveryPrivateKeyPasswords[r];if(t.id&&t.id===e.id)throw new jt(r,Ht.RULE_UNIQUE_ID,`account recovery private key password id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("accountRecoveryPrivateKeyPasswordsCollection push parameter should be an object.");e instanceof Vt&&(e=e.toDto());const t=new Vt(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}filterByForeignModel(e){return this.items.find((t=>t.recipientForeignModel===e))}static get ENTITY_NAME(){return"AccountRecoveryPrivateKeyPassword"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Wt=Ht;class Jt extends X{constructor(e){if(super(se.validate(Jt.ENTITY_NAME,e,Jt.getSchema())),this._props.account_recovery_private_key_passwords){const e=Wt.sanitizeDto(this._props.account_recovery_private_key_passwords);this._account_recovery_private_key_passwords=new Wt(e),delete this._props.account_recovery_private_key_passwords}}static getSchema(){return{type:"object",required:[],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},data:{type:"string"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},account_recovery_private_key_passwords:Wt.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._account_recovery_private_key_passwords&&e.account_recovery_private_key_passwords&&(t.account_recovery_private_key_passwords=this._account_recovery_private_key_passwords.toDto()),t):t}toJSON(){return this.toDto(Jt.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get userId(){return this._props.user_id||null}get data(){return this._props.data||null}get accountRecoveryPrivateKeyPasswords(){return this._account_recovery_private_key_passwords||null}static get ENTITY_NAME(){return"AccountRecoveryPrivateKey"}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_private_key_passwords:!0}}}const Qt=Jt;class Zt extends X{constructor(e){super(se.validate(Zt.ENTITY_NAME,e,Zt.getSchema())),this._props.account_recovery_private_key&&(this._account_recovery_private_key=new Qt(this._props.account_recovery_private_key),delete this._props.account_recovery_private_key),this._props.account_recovery_responses&&(this._account_recovery_responses=new Yt(this._props.account_recovery_responses),delete this._props.account_recovery_responses)}static getSchema(){return{type:"object",required:["id","status"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},armored_key:{type:"string"},fingerprint:{anyOf:[{type:"string",length:40},{type:"null"}]},status:{type:"string",enum:["pending","rejected","approved","completed"]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},account_recovery_private_key:Qt.getSchema(),creator:Zt.getUserEntitySchema(),account_recovery_responses:Yt.getSchema()}}}static getUserEntitySchema(){return{type:"object",required:["username"],properties:{id:{type:"string",format:"uuid"},role_id:{type:"string",format:"uuid"},username:{type:"string",format:"email"},role:Pt.getSchema(),profile:Lt.getSchema(),gpgkey:Ft.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.accountRecoveryPrivateKey&&e.account_recovery_private_key&&(t.account_recovery_private_key=this.accountRecoveryPrivateKey.toDto(Qt.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(Zt.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id}get userId(){return this._props.user_id}get status(){return this._props.status}get armoredKey(){return this._props.armored_key}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_private_key:!0}}get creator(){return this._creator||null}get accountRecoveryPrivateKey(){return this._account_recovery_private_key||null}get accountRecoveryResponses(){return this._account_recovery_responses||null}static get ENTITY_NAME(){return"AccountRecoveryRequest"}}const Xt=Zt;class er extends X{constructor(e){super(se.validate(er.ENTITY_NAME,e,er.getSchema())),this._props.account_recovery_private_key&&(this._account_recovery_private_key=new Qt(this._props.account_recovery_private_key),delete this._props.account_recovery_private_key)}static getSchema(){return{type:"object",required:["status"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},status:{type:"string",enum:[er.STATUS_APPROVED,er.STATUS_REJECTED]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},account_recovery_private_key:Qt.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return this._account_recovery_private_key&&e?.account_recovery_private_key&&(t.account_recovery_private_key=this._account_recovery_private_key.toDto(Qt.ALL_CONTAIN_OPTIONS)),t}toJSON(){return this.toDto()}get status(){return this._props.status}get isApproved(){return this.status===er.STATUS_APPROVED}get isRejected(){return this.status===er.STATUS_REJECTED}get accountRecoveryPrivateKey(){return this._account_recovery_private_key||null}static get ENTITY_NAME(){return"AccountRecoveryUserSetting"}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_private_key:!0}}static get STATUS_APPROVED(){return"approved"}static get STATUS_REJECTED(){return"rejected"}}const tr=er;class rr extends X{constructor(e,t){super(se.validate(rr.ENTITY_NAME,rr._cleanupLastLoginDate(e),rr.getSchema(t))),this._props.profile&&(this._profile=new Lt(this._props.profile),delete this._props.profile),this._props.role&&(this._role=new Pt(this._props.role),delete this._props.role),this._props.gpgkey&&(this._gpgkey=new Ft(this._props.gpgkey),delete this._props.gpgkey),this._props.groups_users&&(this._groups_users=new kt(this._props.groups_users),delete this._props.groups_users),this._props.account_recovery_user_setting&&(this._account_recovery_user_setting=new tr(this._props.account_recovery_user_setting),delete this._props.account_recovery_user_setting),this._props.pending_account_recovery_request&&(this._pending_account_recovery_request=new Xt(this._props.pending_account_recovery_request),delete this._props.pending_account_recovery_request)}static getSchema(){return{type:"object",required:["username"],properties:{id:{type:"string",format:"uuid"},role_id:{type:"string",format:"uuid"},username:{type:"string",format:"email"},active:{type:"boolean"},deleted:{type:"boolean"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},last_logged_in:{anyOf:[{type:"string",format:"date-time"},{type:"null"}]},is_mfa_enabled:{anyOf:[{type:"boolean"},{type:"null"}]},locale:{anyOf:[{type:"string",pattern:/^[a-z]{2}-[A-Z]{2}$/},{type:"null"}]},role:Pt.getSchema(),profile:Lt.getSchema(),gpgkey:Ft.getSchema(),groups_users:kt.getSchema(),account_recovery_user_setting:tr.getSchema(),pending_account_recovery_request:Xt.getSchema()}}}static _cleanupLastLoginDate(e){return e&&""===e.last_logged_in&&(e.last_logged_in=null),e}static sanitizeDto(e){return"object"!=typeof e||Object.prototype.hasOwnProperty.call(e,"groups_users")&&(e.groups_users=kt.sanitizeDto(e.groups_users)),e}toDto(e){const t=Object.assign({},this._props);return e?(this.role&&e.role&&(t.role=this.role.toDto()),this.profile&&e.profile&&(!0===e.profile?t.profile=this.profile.toDto():t.profile=this.profile.toDto(e.profile)),this.gpgkey&&e.gpgkey&&(t.gpgkey=this.gpgkey.toDto()),this.groupsUsers&&e.groups_users&&(t.groups_users=this.groupsUsers.toDto()),this.accountRecoveryUserSetting&&e.account_recovery_user_setting&&(t.account_recovery_user_setting=this.accountRecoveryUserSetting.toDto()),this.pendingAccountRecoveryUserRequest&&e.pending_account_recovery_request&&(t.pending_account_recovery_request=this.pendingAccountRecoveryUserRequest.toDto(Xt.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(rr.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get roleId(){return this._props.role_id}get username(){return this._props.username}get isActive(){return void 0===this._props.active?null:this._props.active}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get lastLoggedIn(){return this._props.last_logged_in||null}get isMfaEnabled(){return void 0===this._props.is_mfa_enabled?null:this._props.is_mfa_enabled}get locale(){return this._props.locale||null}set locale(e){this._props.locale=e}static get ALL_CONTAIN_OPTIONS(){return{profile:Lt.ALL_CONTAIN_OPTIONS,role:!0,gpgkey:!0,groups_users:!0,account_recovery_user_setting:!0,pending_account_recovery_request:!0}}static get ENTITY_NAME(){return"User"}get profile(){return this._profile||null}get role(){return this._role||null}get gpgkey(){return this._gpgkey||null}get groupsUsers(){return this._groups_users||null}get accountRecoveryUserSetting(){return this._account_recovery_user_setting||null}get pendingAccountRecoveryUserRequest(){return this._pending_account_recovery_request||null}}const sr=rr;class ir extends X{constructor(e){super(se.validate(ir.ENTITY_NAME,e,ir.getSchema())),this._props.groups_users&&(this._groups_users=new kt(this._props.groups_users),delete this._props.groups_users),this._props.my_group_user&&(this._my_group_user=new It(this._props.my_group_user),delete this._props.my_group_user),this._props.creator&&(this._creator=new sr(this._props.creator),delete this._props.creator),this._props.modifier&&(this._modifier=new sr(this._props.modifier),delete this._props.modifier)}static getSchema(){return{type:"object",required:["name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",minLength:1,maxLength:255},deleted:{type:"boolean"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},groups_users:kt.getSchema(),my_group_user:It.getSchema(),creator:sr.getSchema(),modifier:sr.getSchema()}}}static sanitizeDto(e){return"object"!=typeof e||Object.prototype.hasOwnProperty.call(e,"groups_users")&&(e.groups_users=kt.sanitizeDto(e.groups_users)),e}toDto(e){const t=Object.assign({},this._props);return e?(this._groups_users&&e.groups_users&&(!0===e.groups_users?t.groups_users=this._groups_users.toDto():t.groups_users=this._groups_users.toDto(e.groups_users)),this._my_group_user&&e.my_group_user&&(t.my_group_user=this._my_group_user.toDto()),this._creator&&e.creator&&(!0===e.creator?t.creator=this._creator.toDto():t.creator=this._creator.toDto(e.user)),this._modifier&&e.modifier&&(!0===e.modifier?t.modifier=this._modifier.toDto():t.modifier=this._modifier.toDto(e.modifier)),t):t}toJSON(){return this.toDto(ir.ALL_CONTAIN_OPTIONS)}static get ALL_CONTAIN_OPTIONS(){return{creator:sr.ALL_CONTAIN_OPTIONS,modifier:sr.ALL_CONTAIN_OPTIONS,groups_users:It.ALL_CONTAIN_OPTIONS,my_group_user:It.ALL_CONTAIN_OPTIONS}}get id(){return this._props.id||null}get name(){return this._props.name}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}get groupsUsers(){return this._groups_users||null}get myGroupUser(){return this._my_group_user||null}static get ENTITY_NAME(){return"Group"}}const or=ir;class nr extends X{constructor(e){super(se.validate(nr.ENTITY_NAME,e,nr.getSchema())),this._props.user&&(this._user=new sr(this._props.user),delete this._props.user),this._props.group&&(this._group=new or(this._props.group),delete this._props.group)}static getSchema(){return{type:"object",required:["aco","aro","aco_foreign_key","aro_foreign_key","type"],properties:{id:{type:"string",format:"uuid"},aco:{type:"string",enum:[nr.ACO_FOLDER,nr.ACO_RESOURCE]},aco_foreign_key:{type:"string",format:"uuid"},aro:{type:"string",enum:[nr.ARO_GROUP,nr.ARO_USER]},aro_foreign_key:{type:"string",format:"uuid"},type:{type:"integer",enum:nr.PERMISSION_TYPES},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},user:sr.getSchema(),group:or.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._user&&e.user&&(!0===e.user?t.user=this._user.toDto():t.user=this._user.toDto(e.user)),this._group&&e.group&&(t.group=this._group.toDto()),t):t}toJSON(){return this.toDto(nr.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get aco(){return this._props.aco}get aro(){return this._props.aro}get aroForeignKey(){return this._props.aro_foreign_key}get acoForeignKey(){return this._props.aco_foreign_key}get type(){return this._props.type}isOwner(){return this.type===nr.PERMISSION_OWNER}static get ENTITY_NAME(){return"Permission"}static get PERMISSION_OWNER(){return 15}static get PERMISSION_UPDATE(){return 7}static get PERMISSION_READ(){return 1}static get ARO_GROUP(){return"Group"}static get ARO_USER(){return"User"}static get ACO_RESOURCE(){return"Resource"}static get ACO_FOLDER(){return"Folder"}static get ALL_CONTAIN_OPTIONS(){return{user:{profile:{avatar:!0}},group:!0}}static get PERMISSION_TYPES(){return[nr.PERMISSION_READ,nr.PERMISSION_UPDATE,nr.PERMISSION_OWNER]}get user(){return this._user||null}get group(){return this._group||null}set id(e){if(!J().isUUID(e))throw new TypeError("The permission id should be a valid UUID.");this._props.id=e}set type(e){if(!e||!nr.PERMISSION_TYPES.includes(e))throw new TypeError("The type should be a valid integer.");this._props.type=e}static assertIsPermission(e){if(!(e&&e instanceof nr))throw new TypeError("Failed to assert the parameter is a valid permission")}static assertArePermissions(e,t){nr.assertIsPermission(e),nr.assertIsPermission(t)}static isIdMatching(e,t){return nr.assertArePermissions(e,t),e.id===t.id}static isAroMatching(e,t){return nr.assertArePermissions(e,t),e.aro===t.aro&&e.aroForeignKey===t.aroForeignKey}static isAcoMatching(e,t){return nr.assertArePermissions(e,t),e.aco===t.aco&&e.acoForeignKey===t.acoForeignKey}static isAcoAndAroMatching(e,t){return nr.assertArePermissions(e,t),nr.isAcoMatching(e,t)&&nr.isAroMatching(e,t)}static isTypeMatching(e,t){return nr.assertArePermissions(e,t),e.type===t.type}static isMatchingAroAcoType(e,t){return nr.assertArePermissions(e,t),nr.isAcoAndAroMatching(e,t)&&nr.isTypeMatching(e,t)}static getHighestPermissionType(e,t){return nr.assertArePermissions(e,t),e.type>t.type?e.type:t.type}static getHighestPermission(e,t){return nr.assertArePermissions(e,t),e.type>t.type?e:t}copyForAnotherAco(e,t){return new nr({aro:this.aro,aro_foreign_key:this.aroForeignKey,aco:e,aco_foreign_key:t,type:this.type})}}const ar=nr;class cr extends Ct{constructor(e,t){super(se.validate(cr.ENTITY_NAME,e,cr.getSchema())),this._props.forEach((e=>{this.push(e)})),(void 0===t||t)&&this.assertAtLeastOneOwner(),this._props=null}toDto(e){const t=[];e||(e=ar.ALL_CONTAIN_OPTIONS);for(const r of this)t.push(r.toDto(e));return t}toJSON(){return this.toDto(ar.ALL_CONTAIN_OPTIONS)}static getSchema(){return{type:"array",items:ar.getSchema()}}get permissions(){return this._items}getByAroMatchingPermission(e){return this._items.find((t=>ar.isAroMatching(t,e)))}getByAro(e,t){return this._items.find((r=>r.aro===e&&r.aroForeignKey===t))}push(e){if(!e||"object"!=typeof e)throw new TypeError("PermissionsCollection push expect a permission DTO.");e instanceof ar&&(e=e.toDto(ar.ALL_CONTAIN_OPTIONS));const t=new ar(e);this.assertSameAco(t),this.assertUniqueId(t),this.assertUniqueAro(t),super.push(t)}addOrReplace(e){try{this.push(e)}catch(t){if(![cr.RULE_UNIQUE_ID,cr.RULE_UNIQUE_ARO].includes(t.rule))throw t;const r=this.permissions[t.position];if(!ar.isAcoAndAroMatching(r,e))throw t;this.permissions[t.position]=ar.getHighestPermission(r,e)}}assertSameAco(e){if(this.permissions.length&&!ar.isAcoMatching(e,this.permissions[0])){const e=`The collection is already composed of this type of ACO: ${this.permissions[0].aco}.`;throw new jt(0,cr.RULE_SAME_ACO,e)}}assertUniqueId(e){if(!e.id)return;const t=this.permissions.length;let r=0;for(;r<t;r++){const t=this.permissions[r];if(t.id&&t.id===e.id)throw new jt(r,cr.RULE_UNIQUE_ID,`Permission id ${e.id} already exists.`)}}assertUniqueAro(e){const t=this.permissions.length;let r=0;for(;r<t;r++){const t=this.permissions[r];if(ar.isAroMatching(e,t)){const t=`${e.aro} id ${e.aroForeignKey} already exists in the permission list.`;throw new jt(r,cr.RULE_UNIQUE_ARO,t)}}}assertAtLeastOneOwner(){for(const e of this)if(e.isOwner())return;throw new jt(0,cr.RULE_ONE_OWNER,"Permission collection should contain at least one owner.")}static sum(e,t,r){const s=new cr(e.toDto(),!1);for(const e of t)s.addOrReplace(e);return(void 0===r||r)&&s.assertAtLeastOneOwner(),s}static diff(e,t,r){const s=new cr([],!1);for(const r of e)t.containAtLeastPermission(r.aro,r.aroForeignKey,r.type)||s.push(r);return(void 0===r||r)&&s.assertAtLeastOneOwner(),s}containAtLeastPermission(e,t,r){for(const s of this.items)if(s.aro===e&&s.aroForeignKey===t&&s.type>=r)return!0;return!1}containAtMostPermission(e,t,r){for(const s of this.items)if(s.aro===e&&s.aroForeignKey===t&&s.type<=r)return!0;return!1}cloneForAco(e,t,r){const s=new cr([],!1);for(const r of this.permissions){const i=r.copyForAnotherAco(e,t);s.addOrReplace(i)}return(void 0===r||r)&&this.assertAtLeastOneOwner(),s}static get ENTITY_NAME(){return"Permissions"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_ARO(){return"unique_aro"}static get RULE_SAME_ACO(){return"same_aco"}static get RULE_ONE_OWNER(){return"owner"}}const ur=cr,pr="Resource";class lr extends X{constructor(e){super(se.validate(lr.ENTITY_NAME,e,lr.getSchema()))}static getSchema(){return{type:"object",required:["id","user_id","foreign_key","created"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},foreign_key:{type:"string",format:"uuid"},created:{type:"string",format:"date-time"}}}}get id(){return this._props.id}get userId(){return this._props.user_id}get foreignKey(){return this._props.foreign_key}get foreignModel(){return this._props.foreign_model}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"Favorite"}static get FAVORITE_RESOURCE(){return pr}static get ALLOWED_FOREIGN_MODELS(){return[pr]}}const dr=lr;class hr extends X{constructor(e){super(se.validate(hr.ENTITY_NAME,e,hr.getSchema()))}static getSchema(){return{type:"object",required:["id","name","slug"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",minLength:1,maxLength:255},slug:{type:"string",minLength:1,maxLength:64},definition:{type:"object"},description:{anyOf:[{type:"string",maxLength:255},{type:"null"}]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id}get name(){return this._props.name}get slug(){return this._props.slug}get definition(){return this._props.definition}get description(){return this._props.description||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"ResourceType"}}const gr=hr;class yr extends X{constructor(e){if(super(se.validate(yr.ENTITY_NAME,e,yr.getSchema())),void 0===this._props.is_shared&&(this._props.is_shared=this.slug.startsWith("#")),this.slug.startsWith("#")&&!this.isShared){new te("Invalid tag").addError("is_shared","hashtag","A shared tag should start with a hashtag.")}}static getSchema(){return{type:"object",required:["slug"],properties:{id:{type:"string",format:"uuid"},slug:{type:"string",minLength:1,maxLength:128},is_shared:{type:"boolean"}}}}get id(){return this._props.id||null}get slug(){return this._props.slug}get isShared(){return this._props.is_shared}static get ENTITY_NAME(){return"Tag"}}const _r=yr;class mr extends Ct{constructor(e){super(se.validate(mr.ENTITY_NAME,e,mr.getSchema())),this._props.forEach((e=>{this.push(new _r(e))})),this._props=null}static getSchema(){return{type:"array",items:_r.getSchema()}}get tags(){return this._items}assertUniqueId(e){if(!e.id)return;const t=this.tags.length;let r=0;for(;r<t;r++){const t=this.tags[r];if(t.id&&t.id===e.id)throw new jt(r,mr.RULE_UNIQUE_ID,`Tag id ${e.id} already exists.`)}}assertUniqueSlug(e){const t=this.tags.length;let r=0;for(;r<t;r++){const t=this.tags[r];if(t.slug&&t.slug===e.slug)throw new jt(r,mr.RULE_UNIQUE_SLUG,`Tag slug ${e.slug} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("TagsCollection push parameter should be an object.");e instanceof _r&&(e=e.toDto());const t=new _r(e);this.assertUniqueId(t),super.push(t)}removeById(e){const t=this.tags.length;let r=0;for(;r<t;r++){if(this.tags[r].id===e)return this._items.splice(r,1),!0}return!1}replaceTag(e,t){if(!e)return!1;const r=this.tags.length;let s=0;for(;s<r;s++){if(this.tags[s].id===e)return this._items[s]=t,!0}return!1}static get ENTITY_NAME(){return"Tags"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_SLUG(){return"unique_slug"}}const wr=mr;class fr extends X{constructor(e){super(se.validate(fr.ENTITY_NAME,e,fr.getSchema())),fr.assertValidMessage(this._props.data)}static getSchema(){return{type:"object",required:["data"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},resource_id:{type:"string",format:"uuid"},data:{type:"string"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}get id(){return this._props.id||null}get data(){return this._props.data}get userId(){return this._props.user_id}get resourceId(){return this._props.resource_id}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"Secret"}static assertValidMessage(e){const t=new te("This is not a valid OpenPGP armored message");if(!e||"string"!=typeof e||""===e)throw t.addError("data","empty","The OpenPGP armored message should not be empty."),t;if(!e.match(/-----BEGIN PGP MESSAGE-----/))throw t.addError("data","begin","The OpenPGP armored message should contain a start delimiter."),t;if(!e.match(/-----END PGP MESSAGE-----/))throw t.addError("data","end","The OpenPGP armored message should contain an end delimiter."),t}}const Er=fr;class Sr extends Ct{constructor(e){super(se.validate(Sr.ENTITY_NAME,e,Sr.getSchema())),this._props.forEach((e=>{this.push(new Er(e))})),this._props=null}static getSchema(){return{type:"array",items:Er.getSchema()}}get secrets(){return this._items}assertUniqueId(e){if(!e.id)return;const t=this.secrets.length;let r=0;for(;r<t;r++){const t=this.secrets[r];if(t.id&&t.id===e.id)throw new jt(r,Sr.RULE_UNIQUE_ID,`Secret id ${e.id} already exists.`)}}assertUniqueUserId(e){if(!e.userId)return;const t=this.secrets.length;let r=0;for(;r<t;r++){const t=this.secrets[r];if(t.userId&&t.userId===e.userId)throw new jt(r,Sr.RULE_UNIQUE_USER_ID,`Secret for user id ${e.userId} already exists.`)}}assertSameResource(e){if(this.secrets.length&&e.resourceId&&e.resourceId!==this.secrets[0].resourceId){const e=`The collection is already used for another resource with id ${this.secrets[0].resourceId}.`;throw new jt(0,Sr.RULE_SAME_RESOURCE,e)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("ResourceSecretsCollection push parameter should be an object.");e instanceof Er&&(e=e.toDto());const t=new Er(e);this.assertUniqueId(t),this.assertUniqueUserId(t),this.assertSameResource(t),super.push(t)}static get ENTITY_NAME(){return"ResourceSecrets"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_USER_ID(){return"unique_user_id"}static get RULE_SAME_RESOURCE(){return"same_resource"}}const vr=Sr;class br extends X{constructor(e){super(se.validate(br.ENTITY_NAME,e,br.getSchema())),this._props.permission&&(this._permission=new ar(this._props.permission),br.assertValidPermission(this._permission,this.id),delete this._props.permission),this._props.permissions&&(this._permissions=new ur(this._props.permissions),br.assertValidPermissions(this._permissions,this.id),delete this._props.permissions),this._props.secrets&&(this._secrets=new vr(this._props.secrets),br.assertValidSecrets(this._secrets,this.id),delete this._props.secrets),this._props.favorite&&(this._favorite=new dr(this._props.favorite),br.assertValidFavorite(this._favorite,this.id),delete this._props.favorite),this._props.tags&&(this._tags=new wr(this._props.tags),delete this._props.tags)}static getSchema(){return{type:"object",required:["name"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",maxLength:255},username:{anyOf:[{type:"string",maxLength:255},{type:"null"}]},uri:{anyOf:[{type:"string",maxLength:1024},{type:"null"}]},description:{anyOf:[{type:"string",maxLength:1e4},{type:"null"}]},deleted:{type:"boolean"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},folder_parent_id:{anyOf:[{type:"string",format:"uuid"},{type:"null"}]},permission:ar.getSchema(),permissions:ur.getSchema(),personal:{type:"boolean"},resource_type_id:{type:"string",format:"uuid"},resource_type:gr.getSchema(),favorite:{anyOf:[dr.getSchema(),{type:"null"}]},secrets:vr.getSchema(),tags:wr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._permission&&e.permission&&(t.permission=this._permission.toDto()),this._permissions&&e.permissions&&(t.permissions=this._permissions.toDto()),this._tags&&e.tag&&(t.tags=this._tags.toDto()),this._secrets&&e.secrets&&(t.secrets=this._secrets.toDto()),void 0!==this._favorite&&e.favorite&&(t.favorite=null===this._favorite?null:this._favorite.toDto()),t):t}toJSON(){return this.toDto(br.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get name(){return this._props.name}get username(){return this._props.username}get description(){return this._props.description||null}get isDeleted(){return void 0===this._props.deleted?null:this._props.deleted}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}get folderParentId(){return this._props.folder_parent_id||null}get resourceTypeId(){return this._props.resource_type_id||null}get uri(){return this._props.uri||null}isPersonal(){return Object.prototype.hasOwnProperty.call(this._props,"personal")?this._props.personal:this.permissions?1===this.permissions.length:null}isShared(){return null===this.isPersonal()?null:!this.isPersonal()}get permission(){return this._permission||null}get permissions(){return this._permissions||null}isOwner(){return null===this.permission?null:this.permission.type===ar.PERMISSION_OWNER}canUpdate(){return this.permission.type>=ar.PERMISSION_UPDATE}isReadOnly(){return null===this.permission?null:this.permission.type===ar.PERMISSION_READ}static canResourceMove(e,t,r){return e.isReadOnly()?(null===t||t.isPersonal())&&(null===r||r.isPersonal()):null===r||!r.isReadOnly()}get tags(){return this._tags||null}get favorite(){return this._favorite||null}isFavorited(){return!0===this.favorite}get secrets(){return this._secrets||null}get secret(){for(const e of this._secrets)return e;return null}set secrets(e){br.assertValidSecrets(e),this._secrets=new vr(e.toDto())}set folderParentId(e){const t="folder_parent_id";if(null===e)return void(this._props[t]=null);const r=br.getSchema().properties[t];this._props[t]=se.validateProp(t,e,r)}set permissions(e){this._permissions=e}set tags(e){this._tags=e}set favorite(e){this._favorite=e}static assertValidPermission(e,t){if(!e)throw new te("ResourceEntity assertValidPermission expect a permission.");if(e.aco!==ar.ACO_RESOURCE)throw new te("ResourceEntity assertValidPermission not a valid resource permission.");if(t&&e.acoForeignKey!==t)throw new te("ResourceEntity assertValidPermission resource id doesnt not match foreign key permission.")}static assertValidPermissions(e,t){if(!e||!e.length)throw new te("ResourceEntity assertValidPermissions expect an array of permissions.");for(const r of e)br.assertValidPermission(r,t)}static assertValidSecrets(e,t){if(!e||!e.length)throw new te("ResourceEntity assertValidSecrets cannot be empty.");if(!(e instanceof vr))throw new te("ResourceEntity assertValidSecrets expect a ResourceSecretsCollection.");for(const r of e)if(r.resourceId&&r.resourceId!==t)throw new te("ResourceEntity assertValidSecrets secret resourceId should match the resource id.")}static assertValidFavorite(e,t){if(e.foreignKey!==t)throw new te("ResourceEntity assertValidFavorite favorite foreign key should match the resource id.")}static get ENTITY_NAME(){return"Resource"}static get ALL_CONTAIN_OPTIONS(){return{permission:!0,permissions:!0,secrets:!0,favorite:!0,tag:!0}}static get URI_MAX_LENGTH(){return 1024}}const Ar=br;var Tr=r(1476),Ir=r.n(Tr);const Rr=function(e){let t,r="",s="",i="",o=!1;/^[a-zA-Z\-]*:\/\//.test(e)||(o=!0,e=`fake://${e}`);try{t=new URL(e)}catch(e){return!1}return i=t.port,o?(t.protocol="https:",s=t.hostname):(r=t.protocol,s=t.hostname),{protocol:r,hostname:s,port:i}},Cr=F()("^[\\p{L}\\p{N}.-]*$"),Or=function(e,t){if(!(t&&e&&Cr.test(t)&&Cr.test(e)))return!1;const r=t.lastIndexOf(e);return-1!==r&&r+e.length===t.length&&(void 0===t[r-1]||"."===t[r-1])},kr=function(e,t){let r;try{r=new URL(e)}catch(e){return!1}const s=Rr(t);if(!r||!r.hostname)return!1;if(!s||!s.hostname)return!1;if(s.protocol&&r.protocol!==s.protocol)return!1;if(s.port&&r.port!==s.port)return!1;if(r.hostname===s.hostname)return!0;const i=Ir()({exact:!0}).test(r.hostname),o=Ir()({exact:!0}).test(s.hostname);return i||o?r.hostname===s.hostname:-1!==s.hostname.indexOf(".")&&Or(s.hostname,r.hostname)};class Nr extends Ct{constructor(e){super(se.validate(Nr.ENTITY_NAME,e,Nr.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,Nr.RULE_UNIQUE_ID,`Resource id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Ar(e))})),this._props=null}static getSchema(){return{type:"array",items:Ar.getSchema()}}get resources(){return this._items}get ids(){return this._items.map((e=>e.id))}get folderParentIds(){return this._items.filter((e=>null!==e.folderParentId)).map((e=>e.folderParentId))}getFirstById(e){return this._items.find((t=>t.id===e))}getFirstIndexById(e){return this._items.findIndex((t=>t.id===e))}getAllWhereOwner(){return new Nr(this._items.filter((e=>e.isOwner())))}findSuggestedResources(e){const t=[];for(let r=0;r<this._items.length;r++)if(this._items[r].uri){if(kr(e,this._items[r].uri)&&t.push(this._items[r]),6===t.length)break}return t}countSuggestedResources(e){let t=0;for(let r=0;r<this._items.length;r++)if(this._items[r].uri){if(t=kr(e,this._items[r].uri)?t+1:t,6===t)break}return t}filterByTagNotPresent(e){const t=t=>t.id!==e;return this._items.filter((e=>e.tags.tags.every(t)))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.resources.length;let r=0;for(;r<t;r++){const t=this.resources[r];if(t.id&&t.id===e.id)throw new jt(r,Nr.RULE_UNIQUE_ID,`Resource id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("ResourcesCollection push parameter should be an object.");e instanceof Ar&&(e=e.toDto(Ar.ALL_CONTAIN_OPTIONS));const t=new Ar(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}removeTagById(e){let t=!1;for(const r of this.resources)r.tags&&(t=r.tags.removeById(e)||t);return t}replaceTag(e,t){let r=!1;for(const s of this.resources)s.tags&&(r=s.tags.replaceTag(e,t)||r);return r}bulkReplaceTagsCollection(e,t){if(!e||!Array.isArray(e)||!e.length)throw new Error("Resource ids should be provided to bulk update tags in resource collection.");if(!t||!Array.isArray(t)||!t.length)throw new Error("Tag collections should be provided to bulk update tags in resource collection.");if(e.length!==t.length)throw new Error("Bulk update requires matching tags collections and list of resource ids.");let r,s=0,i=0;for(;i<e.length;i++)if(i in t){const o=e[i],n=t[i];r=this.getFirstIndexById(o),r>=0&&(this.items[r].tags=n,s++)}return s}static get ENTITY_NAME(){return"Resources"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Pr=Nr,Ur=new Fe,xr="resources";class Mr{static async flush(){return Le.write({level:"debug",message:"ResourceLocalStorage flushed"}),await u.storage.local.remove(xr)}static async get(){const{resources:e}=await u.storage.local.get([xr]);return e}static async set(e){await Ur.acquire();const t=[];if(e){if(!(e instanceof Pr))throw new TypeError("ResourceLocalStorage::set expects a ResourcesCollection");for(const r of e)Mr.assertEntityBeforeSave(r),t.push(r.toDto(Mr.DEFAULT_CONTAIN))}await u.storage.local.set({resources:t}),Ur.release()}static async getResourceById(e){return(await Mr.get()).find((t=>t.id===e))}static async addResource(e){await Ur.acquire();try{Mr.assertEntityBeforeSave(e);const t=await Mr.get();t.push(e.toDto(Mr.DEFAULT_CONTAIN)),await u.storage.local.set({resources:t}),Ur.release()}catch(e){throw Ur.release(),e}}static async addResources(e){await Ur.acquire();try{const t=await Mr.get();e.forEach((e=>{Mr.assertEntityBeforeSave(e),t.push(e.toDto(Mr.DEFAULT_CONTAIN))})),await u.storage.local.set({resources:t}),Ur.release()}catch(e){throw Ur.release(),e}}static async updateResource(e){await Ur.acquire();try{Mr.assertEntityBeforeSave(e);const t=await Mr.get(),r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The resource could not be found in the local storage");t[r]=e.toDto(Mr.DEFAULT_CONTAIN),await u.storage.local.set({resources:t}),Ur.release()}catch(e){throw Ur.release(),e}}static async updateResourcesCollection(e){await Ur.acquire();try{const t=await Mr.get();for(const r of e){Mr.assertEntityBeforeSave(r);const e=t.findIndex((e=>e.id===r.id));if(-1===e)throw new Error("The resource could not be found in the local storage");t[e]=r.toDto(Mr.DEFAULT_CONTAIN)}await u.storage.local.set({resources:t}),Ur.release()}catch(e){throw Ur.release(),e}}static async delete(e){await Ur.acquire();try{const t=await Mr.get();if(t){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await u.storage.local.set({resources:t}),Ur.release()}}catch(e){throw Ur.release(),e}}static get DEFAULT_CONTAIN(){return{permission:!0,favorite:!0,tag:!0}}static assertEntityBeforeSave(e){if(!e)throw new TypeError("ResourceLocalStorage expects a ResourceEntity to be set");if(!(e instanceof Ar))throw new TypeError("ResourceLocalStorage expects an object of type ResourceEntity");if(!e.id)throw new TypeError("ResourceLocalStorage expects ResourceEntity id to be set");if(!e.permission)throw new TypeError("ResourceLocalStorage::set expects ResourceEntity permission to be set")}static async updateResourceLegacy(e){await Ur.acquire();try{const t=await Mr.get(),r=t.findIndex((t=>t.id===e.id));t[r]=e,await u.storage.local.set({resources:t}),Ur.release()}catch(e){throw Ur.release(),e}}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const Lr=Mr;class Dr extends Ct{constructor(e){super(se.validate(Dr.ENTITY_NAME,e,Dr.getSchema())),this._props.forEach((e=>{this.push(new gr(e))})),this._props=null}static getSchema(){return{type:"array",items:gr.getSchema()}}get resourceTypes(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.resourceTypes.length;let r=0;for(;r<t;r++){const t=this.resourceTypes[r];if(t.id&&t.id===e.id)throw new jt(r,Dr.RULE_UNIQUE_ID,`Resource type id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("ResourceTypesCollection push parameter should be an object.");e instanceof gr&&(e=e.toDto());const t=new gr(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"ResourceTypes"}static get RULE_UNIQUE_ID(){return"unique_id"}}const Fr=Dr,qr=new Fe,Kr="resourceTypes";class $r{static async flush(){return Le.write({level:"debug",message:"ResourceTypeLocalStorage flushed"}),await u.storage.local.remove(Kr)}static async get(){const{resourceTypes:e}=await u.storage.local.get([Kr]);return e}static async set(e){await qr.acquire();const t=[];if(e){if(!(e instanceof Fr))throw new TypeError("ResourceTypeLocalStorage::set expects a ResourceTypesCollection");for(const r of e)$r.assertEntityBeforeSave(r),t.push(r.toDto())}await u.storage.local.set({resourceTypes:t}),qr.release()}static async getResourceById(e){return(await $r.get()).find((t=>t.id===e))}static async addResourceType(e){await qr.acquire();try{$r.assertEntityBeforeSave(e);const t=await $r.get();t.push(e.toDto()),await u.storage.local.set({resourceTypes:t}),qr.release()}catch(e){throw qr.release(),e}}static assertEntityBeforeSave(e){if(!e)throw new TypeError("ResourceTypeLocalStorage expects a ResourceTypeEntity to be set");if(!(e instanceof gr))throw new TypeError("ResourceTypeLocalStorage expects an object of type ResourceTypeEntity");if(!e.id)throw new TypeError("ResourceTypeLocalStorage expects ResourceTypeEntity id to be set")}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const jr=$r;class Br extends X{constructor(e){super(se.validate(Br.ENTITY_NAME,e,Br.getSchema())),Object.prototype.hasOwnProperty.call(this._props,"folder_parent_id")||(this._props.folder_parent_id=null),this._props.permission&&(this._permission=new ar(this._props.permission),Br.assertValidPermission(this._permission,this.id),delete this._props.permission),this._props.permissions&&(this._permissions=new ur(this._props.permissions),Br.assertValidPermissions(this._permissions,this.id),delete this._props.permissions)}static getSchema(){return{type:"object",required:["name"],properties:{id:{type:"string",format:"uuid"},folder_parent_id:{anyOf:[{type:"string",format:"uuid"},{type:"null"}]},name:{type:"string",minLength:1,maxLength:256},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},personal:{type:"boolean"},permission:ar.getSchema(),permissions:ur.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._permission&&e.permission&&(t.permission=this._permission.toDto(ar.ALL_CONTAIN_OPTIONS)),this._permissions&&e.permissions&&(t.permissions=this._permissions.toDto(ar.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(Br.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get name(){return this._props.name}get folderParentId(){return this._props.folder_parent_id||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get permission(){return this._permission||null}get permissions(){return this._permissions||null}isOwner(){return null!==this.permission&&this.permission.type===ar.PERMISSION_OWNER}canUpdate(){return!(!this.permission||!this.permission.type)&&this.permission.type>=ar.PERMISSION_UPDATE}isReadOnly(){return null!==this.permission&&this.permission.type===ar.PERMISSION_READ}isPersonal(){return Object.prototype.hasOwnProperty.call(this._props,"personal")?this._props.personal:this.permissions?1===this.permissions.length:null}isShared(){return null===this.isPersonal()?null:!this.isPersonal()}static assertValidPermission(e,t){if(!e)throw new te("FolderEntity assertValidPermission expect a permission.");if(e.aco!==ar.ACO_FOLDER)throw new te("FolderEntity assertValidPermission not a valid folder permission.");if(t&&e.acoForeignKey!==t)throw new te("FolderEntity assertValidPermission folder id doesnt not match foreign key permission.")}static assertValidPermissions(e,t){if(!e||!e.length)throw new te("FolderEntity assertValidPermissions expect an array of permissions.");for(const r of e)Br.assertValidPermission(r,t)}static canFolderMove(e,t,r){return e.isReadOnly()?(null===t||t.isPersonal())&&(null===r||r.isPersonal()):null===r||!r.isReadOnly()}set folderParentId(e){const t="folder_parent_id";if(!e)return void(this._props[t]=null);const r=Br.getSchema().properties[t];this._props[t]=se.validateProp(t,e,r)}static get ENTITY_NAME(){return"Folder"}static get ALL_CONTAIN_OPTIONS(){return{permission:!0,permissions:!0}}}const Gr=Br;class Yr extends Ct{constructor(e){super(se.validate(Yr.ENTITY_NAME,e,Yr.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,Yr.RULE_UNIQUE_ID,`Folder id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Gr(e))})),this._props=null}static getSchema(){return{type:"array",items:Gr.getSchema()}}static get ENTITY_NAME(){return"Folders"}static get RULE_UNIQUE_ID(){return"unique_id"}get folders(){return this._items}get ids(){return this._items.map((e=>e.id))}get folderParentIds(){return this._items.map((e=>e.folderParentIds))}getAllWhereOwner(){return new Yr(this._items.filter((e=>e.isOwner())))}getFolderParentPath(e){return this.getAllParents(e).items.reverse().map((e=>e.name)).join("/")}getById(e){const t=this._items.filter((t=>t.id===e));return t.length?t[0]:void 0}getAllChildren(e){return Yr.getAllChildren(e,this,new Yr([]))}static getAllChildren(e,t,r){const s=t.folders.filter((t=>t.folderParentId===e));if(s.length){try{s.forEach((e=>r.push(e)))}catch(e){}s.map((e=>e.id)).forEach((e=>Yr.getAllChildren(e,t,r)))}return r}getFolderPath(e){if(null===e)return"/";const t=this.folders.find((t=>t.id===e));if(!t){let t="FoldersCollection::getAllParentsAsPath the folder is missing in the inputCollection.";throw t+=`(id: ${e})`,new Error(t)}const r=this.getAllParents(t);return r.unshift(t),`/${r.folders.map((e=>e.name)).reverse().join("/")}`}getAllParents(e){return Yr.getAllParents(e,this,new Yr([]))}static getAllParents(e,t,r){if(null!==e.folderParentId){const s=t.folders.find((t=>t.id===e.folderParentId));void 0!==s&&(r.push(s),Yr.getAllParents(s,t,r))}return r}push(e){if(!e||"object"!=typeof e)throw new TypeError("FoldersCollection push parameter should be an object.");e instanceof Gr&&(e=e.toDto(Gr.ALL_CONTAIN_OPTIONS));const t=new Gr(e);return this.assertUniqueId(t),super.push(t),this}merge(e){for(const t of e)try{this.push(t)}catch(e){}return this}assertUniqueId(e){if(!e.id)return;const t=this.folders.length;let r=0;for(;r<t;r++){const t=this.folders[r];if(t.id&&t.id===e.id)throw new jt(r,Yr.RULE_UNIQUE_ID,`Folder id ${e.id} already exists.`)}}}const zr=Yr,Vr=new Fe;class Hr{static async flush(){return Le.write({level:"debug",message:"FolderLocalStorage flushed"}),await u.storage.local.remove(Hr.FOLDER_LOCAL_STORAGE_KEY)}static async get(){const{folders:e}=await u.storage.local.get([Hr.FOLDER_LOCAL_STORAGE_KEY]);return e}static async set(e){await Vr.acquire();const t=[];if(!(e instanceof zr))throw new TypeError("FolderLocalStorage::set expects a FoldersCollection");for(const r of e)Hr.assertEntityBeforeSave(r),t.push(r.toDto(Hr.DEFAULT_CONTAIN));await u.storage.local.set({folders:t}),Vr.release()}static async getFolderById(e){return(await Hr.get()).find((t=>t.id===e))}static async getFolderByParentId(e){return(await Hr.get()).find((t=>t.folderParentId===e))}static async addFolder(e){await Vr.acquire();try{Hr.assertEntityBeforeSave(e);const t=await Hr.get();t.push(e.toDto(Hr.DEFAULT_CONTAIN)),await u.storage.local.set({folders:t}),Vr.release()}catch(e){throw Vr.release(),e}}static async addFolders(e){await Vr.acquire();try{const t=await Hr.get();e.forEach((e=>{Hr.assertEntityBeforeSave(e),t.push(e.toDto(Hr.DEFAULT_CONTAIN))})),await u.storage.local.set({folders:t}),Vr.release()}catch(e){throw Vr.release(),e}}static async updateFolder(e){await Vr.acquire();try{Hr.assertEntityBeforeSave(e);const t=await Hr.get(),r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The folder could not be found in the local storage");t[r]=Object.assign(t[r],e.toDto(Hr.DEFAULT_CONTAIN)),await u.storage.local.set({folders:t}),Vr.release()}catch(e){throw Vr.release(),e}}static async delete(e){await Vr.acquire();try{const t=await Hr.get();if(t){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await u.storage.local.set({folders:t}),Vr.release()}}catch(e){throw Vr.release(),e}}static get DEFAULT_CONTAIN(){return{permission:!0}}static get FOLDER_LOCAL_STORAGE_KEY(){return"folders"}static assertEntityBeforeSave(e){if(!e)throw new TypeError("FolderLocalStorage expects a FolderEntity to be set");if(!(e instanceof Gr))throw new TypeError("FolderLocalStorage expects an object of type FolderEntity");if(!e.id)throw new TypeError("FolderLocalStorage expects FolderEntity id to be set");if(!e.permission)throw new TypeError("FolderLocalStorage::set expects FolderEntity permission to be set")}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const Wr=Hr;class Jr extends Ct{constructor(e){super(se.validate(Jr.ENTITY_NAME,e,Jr.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,Jr.RULE_UNIQUE_ID,`User id ${e} already exists.`)}));this._props.map((e=>e.username)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,Jr.RULE_UNIQUE_USERNAME,`User username ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new sr(e))})),this._props=null}static getSchema(){return{type:"array",items:sr.getSchema()}}get users(){return this._items}get ids(){return this._items.map((e=>e.id))}getFirstById(e){return this._items.find((t=>t.id===e))}static sanitizeDto(e){if(!Array.isArray(e))return[];return e.map((e=>sr.sanitizeDto(e)))}assertUniqueId(e){if(!e.id)return;const t=this.users.length;let r=0;for(;r<t;r++){const t=this.users[r];if(t.id&&t.id===e.id)throw new jt(r,Jr.RULE_UNIQUE_ID,`User id ${e.id} already exists.`)}}assertUniqueUsername(e){const t=this.users.length;let r=0;for(;r<t;r++){if(this.users[r].username===e.username)throw new jt(r,Jr.RULE_UNIQUE_USERNAME,`The username ${e.username} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("UsersCollection push parameter should be an object.");e instanceof sr&&(e=e.toDto(sr.ALL_CONTAIN_OPTIONS));const t=new sr(e);this.assertUniqueId(t),this.assertUniqueUsername(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"Users"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_USERNAME(){return"unique_username"}}const Qr=Jr,Zr=new Fe;class Xr{static async flush(){return Le.write({level:"debug",message:"UserLocalStorage flushed"}),await u.storage.local.remove(Xr.USER_LOCAL_STORAGE_KEY)}static async get(){const{users:e}=await u.storage.local.get([Xr.USER_LOCAL_STORAGE_KEY]);return e}static async set(e){await Zr.acquire();const t=[];if(!(e instanceof Qr))throw new TypeError("UserLocalStorage::set expects a UsersCollection");for(const r of e)Xr.assertEntityBeforeSave(r),t.push(r.toDto(Xr.DEFAULT_CONTAIN));await u.storage.local.set({users:t}),Zr.release()}static async getUserById(e){return(await Xr.get()).find((t=>t.id===e))}static async addUser(e){await Zr.acquire();try{Xr.assertEntityBeforeSave(e);const t=await Xr.get();t.push(e.toDto(Xr.DEFAULT_CONTAIN)),await u.storage.local.set({users:t}),Zr.release()}catch(e){throw Zr.release(),e}}static async updateUser(e){await Zr.acquire();try{Xr.assertEntityBeforeSave(e);const t=await Xr.get();if(t){const r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The user could not be found in the local storage");t[r]=Object.assign(t[r],e.toDto(Xr.DEFAULT_CONTAIN)),await u.storage.local.set({users:t})}Zr.release()}catch(e){throw Zr.release(),e}}static async delete(e){await Zr.acquire();try{const t=await Xr.get();if(t){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await u.storage.local.set({users:t}),Zr.release()}}catch(e){throw Zr.release(),e}}static get DEFAULT_CONTAIN(){return{profile:{avatar:!0},pending_account_recovery_request:!0,account_recovery_user_setting:!0}}static get USER_LOCAL_STORAGE_KEY(){return"users"}static assertEntityBeforeSave(e){if(!e)throw new TypeError("UserLocalStorage expects a UserEntity to be set");if(!(e instanceof sr))throw new TypeError("UserLocalStorage expects an object of type UserEntity");if(!e.id)throw new TypeError("UserLocalStorage expects UserEntity id to be set");if(!e.profile)throw new TypeError("UserLocalStorage::set expects UserEntity profile to be set");if(!e.profile.avatar)throw new TypeError("UserLocalStorage::set expects UserEntity avatar to be set")}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const es=Xr;class ts extends Ct{constructor(e){super(se.validate(ts.ENTITY_NAME,e,ts.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,ts.RULE_UNIQUE_ID,`Group id ${e} already exists.`)}));this._props.map((e=>e.name)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,ts.RULE_UNIQUE_GROUP_NAME,`Group name ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new or(e))})),this._props=null}static getSchema(){return{type:"array",items:or.getSchema()}}get groups(){return this._items}get ids(){return this._items.map((e=>e.id))}getFirstById(e){return this._items.find((t=>t.id===e))}static sanitizeDto(e){if(!Array.isArray(e))return[];let t=Bt(e,"name");return t=Bt(t,"id"),t=t.map((e=>or.sanitizeDto(e))),t}assertUniqueId(e){if(!e.id)return;const t=this.groups.length;let r=0;for(;r<t;r++){const t=this.groups[r];if(t.id&&t.id===e.id)throw new jt(r,ts.RULE_UNIQUE_ID,`Group id ${e.id} already exists.`)}}assertUniqueGroupName(e){const t=this.groups.length;let r=0;for(;r<t;r++){if(this.groups[r].name===e.name)throw new jt(r,ts.RULE_UNIQUE_GROUP_NAME,`The group name ${e.name} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("GroupsCollection push parameter should be an object.");e instanceof or&&(e=e.toDto(or.ALL_CONTAIN_OPTIONS));const t=new or(e);this.assertUniqueId(t),this.assertUniqueGroupName(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"Groups"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_GROUP_NAME(){return"unique_group_name"}}const rs=ts,ss=new Fe;class is{static async flush(){return Le.write({level:"debug",message:"GroupLocalStorage flushed"}),await u.storage.local.remove(is.GROUP_LOCAL_STORAGE_KEY)}static async get(){const{groups:e}=await u.storage.local.get([is.GROUP_LOCAL_STORAGE_KEY]);return e}static async set(e){await ss.acquire();const t=[];if(!(e instanceof rs))throw new TypeError("GroupLocalStorage::set expects a GroupsCollection");for(const r of e)is.assertEntityBeforeSave(r),t.push(r.toDto(is.DEFAULT_CONTAIN));await u.storage.local.set({groups:t}),ss.release()}static async getGroupById(e){return(await is.get()).find((t=>t.id===e))}static async addGroup(e){await ss.acquire();try{is.assertEntityBeforeSave(e);const t=await is.get();t.push(e.toDto(is.DEFAULT_CONTAIN)),await u.storage.local.set({groups:t}),ss.release()}catch(e){throw ss.release(),e}}static async updateGroup(e){await ss.acquire();try{is.assertEntityBeforeSave(e);const t=await is.get(),r=t.findIndex((t=>t.id===e.id));if(-1===r)throw new Error("The group could not be found in the local storage");t[r]=Object.assign(t[r],e.toDto(is.DEFAULT_CONTAIN)),await u.storage.local.set({groups:t}),ss.release()}catch(e){throw ss.release(),e}}static async delete(e){await ss.acquire();try{const t=await is.get();if(t){const r=t.findIndex((t=>t.id===e));-1!==r&&t.splice(r,1),await u.storage.local.set({groups:t}),ss.release()}}catch(e){throw ss.release(),e}}static get DEFAULT_CONTAIN(){return{my_group_user:!0,groups_users:!0}}static get GROUP_LOCAL_STORAGE_KEY(){return"groups"}static assertEntityBeforeSave(e){if(!e)throw new TypeError("GroupLocalStorage expects a GroupEntity to be set");if(!(e instanceof or))throw new TypeError("GroupLocalStorage expects an object of type GroupEntity");if(!e.id)throw new TypeError("GroupLocalStorage expects GroupEntity id to be set")}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const os=is;class ns extends Ct{constructor(e){super(se.validate(ns.ENTITY_NAME,e,ns.getSchema())),this._props.forEach((e=>{this.push(new Pt(e))})),this._props=null}static getSchema(){return{type:"array",items:Pt.getSchema()}}get roles(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.roles.length;let r=0;for(;r<t;r++){const t=this.roles[r];if(t.id&&t.id===e.id)throw new jt(r,ns.RULE_UNIQUE_ID,`Role id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("RolesCollection push parameter should be an object.");e instanceof Pt&&(e=e.toDto());const t=new Pt(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"Roles"}static get RULE_UNIQUE_ID(){return"unique_id"}}const as=ns,cs=new Fe,us="roles";class ps{static async flush(){return Le.write({level:"debug",message:"RolesLocalStorage flushed"}),await u.storage.local.remove(us)}static async get(){const{roles:e}=await u.storage.local.get([us]);return e}static async set(e){await cs.acquire();const t=[];if(e){if(!(e instanceof as))throw new TypeError("RolesLocalStorage::set expects a RolesCollection");for(const r of e)ps.assertEntityBeforeSave(r),t.push(r.toDto())}await u.storage.local.set({roles:t}),cs.release()}static async getResourceById(e){return(await ps.get()).find((t=>t.id===e))}static async addResourceType(e){await cs.acquire();try{ps.assertEntityBeforeSave(e);const t=await ps.get();t.push(e.toDto()),await u.storage.local.set({roles:t}),cs.release()}catch(e){throw cs.release(),e}}static assertEntityBeforeSave(e){if(!e)throw new TypeError("RolesLocalStorage expects a RoleEntity to be set");if(!(e instanceof Pt))throw new TypeError("RolesLocalStorage expects an object of type RoleEntity");if(!e.id)throw new TypeError("RolesLocalStorage expects RoleEntity id to be set")}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}}const ls=ps,ds=new Fe,hs="passwordGenerator";const gs=class{static async flush(){return Le.write({level:"debug",message:"PasswordGeneratorLocalStorage flushed"}),await u.storage.local.remove(hs)}static async get(){const{passwordGenerator:e}=await u.storage.local.get([hs]);return e}static async set(e){await ds.acquire(),await u.storage.local.set({passwordGenerator:e}),ds.release()}static init(){this.flush(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.flush()}))}};function ys(e){u.browserAction.setIcon({path:{32:e||"/webAccessibleResources/img/icons/icon-32.png"}})}const _s={activate:function(){ys("/webAccessibleResources/img/icons/icon-32.png")},deactivate:function(){ys("/webAccessibleResources/img/icons/icon-32-signout.png")},setSuggestedResourcesCount:function(e){if(e>0){ys(e<=5?`/webAccessibleResources/img/icons/icon-32-badge-${e}.png`:"/webAccessibleResources/img/icons/icon-32-badge-5+.png")}else ys("/webAccessibleResources/img/icons/icon-32.png")}};class ms extends Te{constructor(e){super(e,ms.RESOURCE_NAME)}static get RESOURCE_NAME(){return"resource-types"}async get(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}}const ws=ms;const fs=class{constructor(e){this.resourceTypeService=new ws(e)}async updateLocalStorage(){let e=[];try{e=await this.resourceTypeService.findAll()}catch(e){if(!(e instanceof Se&&e.data&&404===e.data.code))throw e;console.error(e)}const t=new Fr(e);return await jr.set(t),t}async getOrFindAll(){const e=await jr.get();return void 0!==e?new Fr(e):this.updateLocalStorage()}async getSecretSchemaById(e){if(!J().isUUID(e))throw new TypeError("The resource type id should be a valid UUID");const t=(await this.getOrFindAll()).getFirst("id",e);if(t&&t.definition&&t.definition.secret)return t.definition.secret}};class Es extends X{constructor(e){super(se.validate(Es.ENTITY_NAME,e,Es.getSchema()))}static getSchema(){const e=ar.getSchema(),t=e.required,r={type:"object",required:e.required,properties:{id:{type:"string",format:"uuid"},delete:{type:"boolean"}}};return t.forEach((t=>{r.properties[t]=e.properties[t]})),r}static createFromPermission(e,t){if(!(e&&e instanceof ar))throw new TypeError("PermissionChangeEntity createFromPermission expect a permission entity.");const r={aco:e.aco,aro:e.aro,aco_foreign_key:e.acoForeignKey,aro_foreign_key:e.aroForeignKey,type:e.type};switch(t){case Es.PERMISSION_CHANGE_CREATE:break;case Es.PERMISSION_CHANGE_UPDATE:if(!e.id)throw new TypeError("PermissionChangeEntity createFromPermission update expect a permission id.");r.id=e.id;break;case Es.PERMISSION_CHANGE_DELETE:if(!e.id)throw new TypeError("PermissionChangeEntity createFromPermission delete expect a permission id.");r.id=e.id,r.delete=!0;break;default:throw new TypeError("PermissionChangeEntity createFromPermission unsupported operation")}return new Es(r)}copyForAnotherAco(e,t){return new ar({aro:this.aro,aro_foreign_key:this.aroForeignKey,aco:e,aco_foreign_key:t,type:this.type})}get id(){return this._props.id||null}get aco(){return this._props.aco}get aro(){return this._props.aro}get aroForeignKey(){return this._props.aro_foreign_key}get acoForeignKey(){return this._props.aco_foreign_key}get type(){return this._props.type}get isDeleted(){return void 0===this._props.delete?null:this._props.delete}get scenario(){return this.isDeleted?Es.PERMISSION_CHANGE_DELETE:this.id?Es.PERMISSION_CHANGE_UPDATE:Es.PERMISSION_CHANGE_CREATE}static get ENTITY_NAME(){return"PermissionChange"}static get PERMISSION_CHANGE_CREATE(){return"create"}static get PERMISSION_CHANGE_UPDATE(){return"update"}static get PERMISSION_CHANGE_DELETE(){return"delete"}}const Ss=Es;class vs extends Ct{constructor(e){super(se.validate(vs.ENTITY_NAME,e,vs.getSchema())),this._props.forEach((e=>{this.push(e)})),this._props=null}static getSchema(){return{type:"array",items:Ss.getSchema()}}static get ENTITY_NAME(){return"PermissionChanges"}filterByAcoForeignKey(e){const t=this._items.filter((t=>t.acoForeignKey===e));return new vs(t)}filterByAroForeignKey(e){const t=this._items.filter((t=>t.aroForeignKey===e));return new vs(t)}push(e){if(!e||"object"!=typeof e)throw new TypeError("PermissionChangesCollection push parameter should be an object.");e instanceof Ss&&(e=e.toDto()),e=new Ss(e),super.push(e)}merge(e){for(const t of e)this.push(t)}copyForAnotherAco(e,t){const r=new vs([]);for(const s of this.items)r.push(s.copyForAnotherAco(e,t));return r}static reuseChanges(e,t,r,s,i){if(!(e&&t&&r&&i&&s))throw new TypeError("PermissionChangesCollection reuseChanges call is missing parameter(s).");const o=new vs([]);for(const n of s){const s=r.getByAro(n.aro,n.aroForeignKey);switch(n.scenario){case Ss.PERMISSION_CHANGE_DELETE:s&&s.type===n.type&&o.push(Ss.createFromPermission(s,Ss.PERMISSION_CHANGE_DELETE));break;case Ss.PERMISSION_CHANGE_CREATE:s||o.push(new Ss({aco:e,aco_foreign_key:t,aro:n.aro,aro_foreign_key:n.aroForeignKey,type:n.type}));break;case Ss.PERMISSION_CHANGE_UPDATE:if(s&&s.type!==n.type){if(i.items.find((e=>e.id===n.id)).type===s.type){const e=new ar(s.toDto());e.type=n.type,o.push(Ss.createFromPermission(e,Ss.PERMISSION_CHANGE_UPDATE))}}}}return o}static calculateChanges(e,t){if(!(e&&e instanceof ur&&t&&t instanceof ur))throw new TypeError("PermissionChangesCollection calculateChanges invalid parameters");const r=new vs([]);for(const s of t){const t=e.getByAroMatchingPermission(s);if(t){if(s.type!==t.type){s.id=t.id;const e=Ss.createFromPermission(s,Ss.PERMISSION_CHANGE_UPDATE);r.push(e)}}else{const e=Ss.createFromPermission(s,Ss.PERMISSION_CHANGE_CREATE);r.push(e)}}for(const s of e)if(!t.getByAroMatchingPermission(s)){const e=Ss.createFromPermission(s,Ss.PERMISSION_CHANGE_DELETE);r.push(e)}return r}}const bs=vs;class As extends Te{constructor(e){super(e,As.RESOURCE_NAME)}static get RESOURCE_NAME(){return"move"}async move(e){let t;if(e instanceof Gr)t="Folder";else{if(!(e instanceof Ar))throw new TypeError("The entity must be a FolderEntity or a ResourceEntity");t="Resource"}const r=`${t.toLowerCase()}/${e.id}`,s=e.toDto();return(await this.apiClient.update(r,s)).body}}const Ts=As;class Is extends Te{constructor(e){super(e,Is.RESOURCE_NAME)}static get RESOURCE_NAME(){return"resources"}static getSupportedContainOptions(){return["creator","favorite","modifier","secret","permission","permissions.user.profile","permissions.group","tag","resource-type"]}static getSupportedFiltersOptions(){return["is-favorite","is-shared-with-group","is-owned-by-me","is-shared-with-me","has-id","has-tag"]}static getSupportedOrdersOptions(){return["Resource.modified DESC","Resource.modified ASC"]}async get(e,t){this.assertValidId(e);const r=t?this.formatContainOptions(t,Is.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}async findAll(e,t,r){e=e?this.formatContainOptions(e,Is.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,Is.getSupportedFiltersOptions()):null,r=r?this.formatOrderOptions(r,Is.getSupportedFiltersOptions()):null;const s={...e,...t,...r},i=await this.apiClient.findAll(s);return i.body&&i.body.length?i.body:[]}async create(e,t){this.assertNonEmptyData(e);const r=t?this.formatContainOptions(t,Is.getSupportedContainOptions()):null;return(await this.apiClient.create(e,r)).body}async update(e,t,r){this.assertValidId(e),this.assertNonEmptyData(t);const s=r?this.formatContainOptions(r,Is.getSupportedContainOptions()):null;return(await this.apiClient.update(e,t,s)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}async findAllForShare(e){if(e.length>80){let t=[];const r=Math.ceil(e.length/80);for(let s=0;s<r;s++){const r=e.splice(0,80),s=await this.findAllForShare(r);t=[...t,...s]}return t}const t=this.apiClient.buildUrl(this.apiClient.baseUrl.toString());e.forEach((e=>{t.searchParams.append("filter[has-id][]",e)})),t.searchParams.append("contain[permission]","1"),t.searchParams.append("contain[permissions.user.profile]","1"),t.searchParams.append("contain[permissions.group]","1"),t.searchParams.append("contain[secret]","1");return(await this.apiClient.fetchAndHandleResponse("GET",t)).body}}const Rs=Is;class Cs extends X{constructor(e,t){super(se.validate(Cs.ENTITY_NAME,e,t))}static getSchema(){throw new TypeError("Plaintext only support dynamic schemas, defined from resource type.")}get props(){return this._props}get password(){return this._props.password||null}get description(){return this._props.description||null}static get ENTITY_NAME(){return"Plaintext"}}const Os=Cs,ks=(e,t)=>e.reduce(((e,r,s)=>(s%t?e[e.length-1].push(r):e.push([r]),e)),[]);const Ns=class{constructor(e){this.resourceService=new Rs(e),this.moveService=new Ts(e),this.resourceTypeModel=new fs(e)}async updateLocalStorage(){const e=await this.findAll({permission:!0,favorite:!0,tag:!0},null,null,!0);return await Lr.set(e),e}async getAllByParentIds(e){const t=await Lr.get(),r=new Pr([]);for(const s in t){const i=t[s];e.includes(i.folder_parent_id)&&r.push(i)}return r}async getAllByIds(e){const t=(await Lr.get()).filter((t=>e.includes(t.id)));return new Pr(t)}async getById(e){const t=await Lr.getResourceById(e);return new Ar(t)}async getOrFindAll(){const e=await Lr.get();return e?new Pr(e):this.findAll()}calculatePermissionsChangesForMove(e,t,r){let s=new ur([],!1);if(null!==t){if(!e.permissions||!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires permissions to be set.");s=ur.diff(e.permissions,t.permissions,!1)}let i=new ur([],!1);if(r){if(!r.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");i=r.permissions.cloneForAco(ar.ACO_RESOURCE,e.id,!1)}const o=ur.sum(s,i,!1);return r||o.addOrReplace(new ar({aco:ar.ACO_RESOURCE,aro:e.permission.aro,aco_foreign_key:e.id,aro_foreign_key:e.permission.aroForeignKey,type:ar.PERMISSION_OWNER})),o.assertAtLeastOneOwner(),bs.calculateChanges(e.permissions,o)}async calculatePermissionsChangesForCreate(e,t){let r=null;if(t){if(!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");const s=new ur([e.permission]),i=t.permissions.cloneForAco(ar.ACO_RESOURCE,e.id);r=bs.calculateChanges(s,i)}return r}async findAll(e,t,r,s){let i=await this.resourceService.findAll(e,t,r);return s&&(i=Pr.sanitizeDto(i)),new Pr(i)}async findAllForShare(e){const t=await this.resourceService.findAllForShare(e);return new Pr(t)}async findAllForDecrypt(e){let t=[];const r=ks(e,80);for(const e of r){const r=await this.resourceService.findAll({secret:!0,"resource-type":!0},{"has-id":e});t=[...t,...r]}return new Pr(t)}async findForDecrypt(e){const t=await this.resourceService.get(e,{secret:!0,"resource-type":!0});return new Ar(t)}async findResourcePermissions(e){const t={"has-id":[e]},r=await this.resourceService.findAll({"permissions.user.profile":!0,"permissions.group":!0},t);return new Ar(r[0]).permissions}async countSuggestedResources(e){return e?(await this.getOrFindAll()).countSuggestedResources(e):0}async findSuggestedResources(e){if(!e)return 0;return(await this.getOrFindAll()).findSuggestedResources(e).map((e=>e.toDto()))}async create(e){const t=e.toDto({secrets:!0}),r=await this.resourceService.create(t,{permission:!0,favorite:!0,tags:!0,folder:!0}),s=new Ar(r);return await Lr.addResource(s),s}async update(e){const t=e.toDto({secrets:!0}),r=await this.resourceService.update(e.id,t,Lr.DEFAULT_CONTAIN),s=new Ar(r);return await Lr.updateResource(s),s}async updateCollection(e){await Lr.updateResourcesCollection(e)}async delete(e){await this.resourceService.delete(e),await Lr.delete(e)}async move(e,t){e.folderParentId=t,await this.moveService.move(e)}async bulkCreate(e,t){let r=[];const s=ks(e.resources,5);for(const e in s){const i=s[e].map((async(r,s)=>{const i=5*e+s;return this._bulkCreate_createResource(r,i,t)})),o=(await Promise.allSettled(i)).map((e=>e.value));r=[...r,...o]}const i=r.filter((e=>e instanceof Ar));return await Lr.addResources(i),r}async _bulkCreate_createResource(e,t,r){const s=(r=r||{}).successCallback||(()=>{}),i=r.errorCallback||(()=>{});try{const r=e.toDto({secrets:!0}),i={permission:!0,favorite:!0,tags:!0,folder:!0},o=await this.resourceService.create(r,i),n=new Ar(o);return s(n,t),n}catch(e){throw console.error(e),i(e,t),e}}async bulkDelete(e,t){let r=[];const s=ks(e,5);for(const e in s){const i=s[e].map((async(r,s)=>{const i=5*e+s;return this._bulkDelete_deleteResource(r,i,t)})),o=(await Promise.allSettled(i)).map((e=>e.value));r=[...r,...o]}return r}async _bulkDelete_deleteResource(e,t,r){const s=(r=r||{}).successCallback||(()=>{}),i=r.errorCallback||(()=>{});try{await this.delete(e),s(t)}catch(e){throw console.error(e),i(e,t),e}}async serializePlaintextDto(e,t){if(!e||"string"==typeof t){if(t.length>4096)throw new TypeError("The secret should be maximum 4096 characters in length.");return t}const r=await this.resourceTypeModel.getSecretSchemaById(e);if(!r)throw new TypeError("Could not find the schema definition for the requested resource type.");const s=new Os(t,r);return JSON.stringify(s)}async deserializePlaintext(e,t){if("string"!=typeof t)throw new TypeError("Could not deserialize secret, plaintext is not a string.");if(!e)return t;const r=await this.resourceTypeModel.getSecretSchemaById(e);if(!r)throw new TypeError("Could not find the schema definition for the requested resource type.");if("string"===r.type)return t;try{const e=JSON.parse(t);return new Os(e,r)}catch(e){return console.error(e),t}}async replaceTagLocally(e,t){const r=await Lr.get(),s=new Pr(r);return!!s.replaceTag(e,t)&&(await Lr.set(s),!0)}async replaceResourceTagsLocally(e,t){const r=await Lr.getResourceById(e),s=new Ar(r);return s.tags=t,await Lr.updateResource(s),s}async bulkReplaceResourceTagsLocally(e,t){const r=await Lr.get(),s=new Pr(r);await s.bulkReplaceTagsCollection(e,t),await Lr.set(s)}async deleteTagsLocally(e){const t=await Lr.get(),r=new Pr(t);return!!r.removeTagById(e)&&(await Lr.set(r),!0)}async updateFavoriteLocally(e,t){const r=await Lr.getResourceById(e),s=new Ar(r);s.favorite=t,await Lr.updateResource(s)}async assertResourcesExist(e){const t=await Lr.get();if(!Array.isArray(e))throw new TypeError("Resources exist check expect an array of uuid.");for(const r in e)if(!t.find((t=>t.id===e[r])))return!1;return!0}},Ps=function(){};Ps.getToolbarUrl=function(){let e="";const t=Ye.getInstance();return e=t.isValid()?t.settings.getDomain():"https://www.passbolt.com/start",e};const Us=Ps,xs=function(e){chrome.tabs.create({url:e})},Ms="UpdateSuggestedResourceBadgeCacheFlush";const Ls=class{constructor(){_s.deactivate(),this.bindCallbacks(),this.addEventListeners()}bindCallbacks(){this.handleButtonClick=this.handleButtonClick.bind(this),this.handleShortcutPressed=this.handleShortcutPressed.bind(this),this.handleUserLoggedOut=this.handleUserLoggedOut.bind(this),this.handleUserLoggedIn=this.handleUserLoggedIn.bind(this),this.handleSuggestedResourcesOnUpdatedTabBound=this.handleSuggestedResourcesOnUpdatedTab.bind(this),this.handleSuggestedResourcesOnActivatedTabBound=this.handleSuggestedResourcesOnActivatedTab.bind(this),this.handleSuggestedResourcesOnFocusedWindowBound=this.handleSuggestedResourcesOnFocusedWindow.bind(this),this.handleFlushEvent=this.handleFlushEvent.bind(this)}addEventListeners(){u.browserAction.onClicked.addListener(this.handleButtonClick),u.commands.onCommand.addListener(this.handleShortcutPressed),self.addEventListener("passbolt.auth.after-logout",this.handleUserLoggedOut),self.addEventListener("passbolt.auth.after-login",this.handleUserLoggedIn)}handleButtonClick(){this.openPassboltTab()}handleShortcutPressed(e){"passbolt-open"===e&&this.openPassboltTab()}async handleUserLoggedIn(){const e=Ye.getInstance(),t=await e.getApiClientOptions();this.resourceModel=new Ns(t),_s.activate(),this.updateSuggestedResourcesBadge(),u.tabs.onUpdated.addListener(this.handleSuggestedResourcesOnUpdatedTabBound),u.tabs.onActivated.addListener(this.handleSuggestedResourcesOnActivatedTabBound),u.windows.onFocusChanged.addListener(this.handleSuggestedResourcesOnFocusedWindowBound)}handleUserLoggedOut(){_s.deactivate(),u.tabs.onUpdated.removeListener(this.handleSuggestedResourcesOnUpdatedTabBound),u.tabs.onActivated.removeListener(this.handleSuggestedResourcesOnActivatedTabBound),u.windows.onFocusChanged.removeListener(this.handleSuggestedResourcesOnFocusedWindowBound)}async handleSuggestedResourcesOnUpdatedTab(e,t){t.url&&this.updateSuggestedResourcesBadge()}handleSuggestedResourcesOnActivatedTab(){this.updateSuggestedResourcesBadge()}handleSuggestedResourcesOnFocusedWindow(e){e===u.windows.WINDOW_ID_NONE?_s.setSuggestedResourcesCount(0):this.updateSuggestedResourcesBadge()}openPassboltTab(){const e=Us.getToolbarUrl();xs(e)}async updateSuggestedResourcesBadge(){let e;try{this.clearAlarm();e=(await u.tabs.query({active:!0,lastFocusedWindow:!0}))[0]}catch(e){if(u.runtime.lastError)return void this.createAlarm();throw e}if(e){const t=await this.resourceModel.countSuggestedResources(e.url);_s.setSuggestedResourcesCount(t)}}createAlarm(){u.alarms.create(Ms,{when:Date.now()+50}),u.alarms.onAlarm.addListener(this.handleFlushEvent)}clearAlarm(){u.alarms.onAlarm.removeListener(this.handleFlushEvent),u.alarms.clear(Ms)}handleFlushEvent(e){e.name===Ms&&this.updateSuggestedResourcesBadge()}};class Ds extends X{constructor(e){Ds.marshal(e),super(se.validate(Ds.ENTITY_NAME,e,Ds.getSchema()))}static marshal(e){e.keySize||(e.keySize=this.DEFAULT_KEY_SIZE),e.type||(e.type=this.DEFAULT_TYPE)}static getSchema(){return{type:"object",required:["name","email","passphrase","keySize","type"],properties:{name:{type:"string",minLength:1},email:{type:"string",custom:ue.format.EmailAddress.isValidAddress},passphrase:{type:"string",minLength:8},type:{type:"string",enum:[Ds.TYPE_RSA]},keySize:{type:"integer",minLength:this.DEFAULT_KEY_SIZE},date:{type:"integer"}}}}toGenerateOpenpgpKeyDto(){return{userIDs:[this.userId],rsaBits:this.rsaBits,passphrase:this.passphrase,type:this.type,date:this.date}}get userId(){return{name:this.name,email:this.email}}get name(){return this._props.name}get email(){return this._props.email}get type(){return this._props.type}get rsaBits(){return this._props.keySize}get passphrase(){return this._props.passphrase}get date(){return void 0!==this._props.date?new Date(this._props.date):new Date}static get ENTITY_NAME(){return"GenerateGpgKeyPairOptionsEntity"}static get DEFAULT_KEY_SIZE(){return 3072}static get DEFAULT_TYPE(){return"rsa"}static get TYPE_RSA(){return"rsa"}}const Fs=Ds;class qs extends Te{constructor(e){super(e,qs.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/organization-policies"}static getSupportedContainOptions(){return["creator","creator.gpgkey"]}async find(e){const t=e?this.formatContainOptions(e,qs.getSupportedContainOptions()):null;return(await this.apiClient.findAll(t)).body}async saveOrganizationPolicy(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}static async validatePublicKey(e,t){const r=await M(e),s=await de.getKeyInfo(r);if(!s.isValid)throw new Error("The key should be a valid openpgp key.");if(s.algorithm!==Fs.TYPE_RSA)throw new Error("The key algorithm should be RSA.");if(s.private)throw new Error("The key should be public.");if(s.revoked)throw new Error("The key should not be revoked.");if("Infinity"!==s.expires)throw new Error("The key should not have an expiry date.");if(s.length<4096)throw new Error("The key should be at least 4096 bits.");const i=new ge,o=new At(i);if((await o.getServerKey()).fingerprint.toUpperCase()===s.fingerprint)throw new Error("The key is the current server key, the organization recovery key must be a new one.");await i.sync();const n=i.getPublicKeysFromStorage();for(const e in n){if(n[e].fingerprint.toUpperCase()===s.fingerprint)throw new Error("The key is already being used, the organization recovery key must be a new one.")}if(!t)return;if((await M(t)).getFingerprint().toUpperCase()===s.fingerprint)throw new Error("The key is the current organization recovery key, you must provide a new one.")}}const Ks=qs;class $s extends X{constructor(e){e=$s.sanitizeDto(e),super(se.validate($s.ENTITY_NAME,e,$s.getSchema()))}static getSchema(){return{type:"object",required:["armored_key"],properties:{id:{type:"string",format:"uuid"},armored_key:{type:"string"},fingerprint:{anyOf:[{type:"string",length:40},{type:"null"}]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"},deleted:{type:"string",format:"date-time"}}}}static sanitizeDto(e){return(e=Object.assign({},e)).fingerprint&&(e.fingerprint=this.sanitizeFingerPrint(e.fingerprint)),e}static sanitizeFingerPrint(e=""){return e.toUpperCase()}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get armoredKey(){return this._props.armored_key}get fingerprint(){return this._props.fingerprint}set fingerprint(e){se.validateProp("fingerprint",e,$s.getSchema().properties.fingerprint),this._props.fingerprint=$s.sanitizeFingerPrint(e)}static get ENTITY_NAME(){return"AccountRecoveryOrganizationPublicKey"}}const js=$s;class Bs extends X{constructor(e){super(se.validate(Bs.ENTITY_NAME,e,Bs.getSchema())),this._props.account_recovery_organization_public_key&&(this._account_recovery_organization_public_key=new js(this._props.account_recovery_organization_public_key),Bs.assertValidAccountRecoveryOrganizationPublicKey(this._account_recovery_organization_public_key,this.public_key_id),delete this._props.account_recovery_organization_public_key),this._props.account_recovery_organization_revoked_key&&(this._account_recovery_organization_revoked_key=new js(this._props.account_recovery_organization_revoked_key),delete this._props.account_recovery_organization_revoked_key),this._props.account_recovery_private_key_passwords&&(this._account_recovery_private_key_passwords=new Wt(this._props.account_recovery_private_key_passwords),delete this._props.account_recovery_private_key_passwords),this._props.creator&&(this._creator=new sr(this._props.creator),delete this._props.creator)}static getSchema(){return{type:"object",required:["policy"],properties:{id:{type:"string",format:"uuid"},policy:{type:"string",enum:[Bs.POLICY_DISABLED,Bs.POLICY_MANDATORY,Bs.POLICY_OPT_IN,Bs.POLICY_OPT_OUT]},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"},public_key_id:{anyOf:[{type:"string",format:"uuid"},{type:"null"}]},account_recovery_organization_public_key:js.getSchema(),account_recovery_organization_revoked_key:js.getSchema(),account_recovery_private_key_passwords:Wt.getSchema(),creator:sr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._account_recovery_organization_public_key&&e.account_recovery_organization_public_key&&(t.account_recovery_organization_public_key=this._account_recovery_organization_public_key.toDto()),this._account_recovery_organization_revoked_key&&e.account_recovery_organization_revoked_key&&(t.account_recovery_organization_revoked_key=this._account_recovery_organization_revoked_key.toDto()),this._account_recovery_private_key_passwords&&e.account_recovery_private_key_passwords&&(t.account_recovery_private_key_passwords=this._account_recovery_private_key_passwords.toDto()),this._creator&&e.creator&&(t.creator=this._creator.toDto(sr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto({account_recovery_organization_public_key:!0,account_recovery_organization_revoked_key:!0,account_recovery_private_key_passwords:!0,creator:!0})}static assertValidAccountRecoveryOrganizationPublicKey(e,t){if(!e)throw new te("AccountRecoveryOrganizationPolicyEntity assertValidAccountRecoveryOrganizationPublicKey expect an accountRecoveryOrganizationPublicKey.");if(t&&e.id!==t)throw new te("AccountRecoveryOrganizationPolicyEntity assertValidPermission resource id doesnt not match foreign key permission.")}static async assertValidCreatorGpgkey(e){const t=e.creator;if(!t)throw new te("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects a creator to be defined.");const r=t.gpgkey;if(!r)throw new te("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects a creator.gpgkey to be defined.");if(t.id!==r.userId)throw new te("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects the creator's id to match the gpgkey.user_id.");if((await M(r.armoredKey)).getFingerprint().toUpperCase()!==r.fingerprint.toUpperCase())throw new te("AccountRecoveryOrganizationPolicyEntity assertValidCreatorGpgkey expects the gpgkey armoredKey's fingerprint to match the given fingerprint.")}get accountRecoveryOrganizationPublicKey(){return this._account_recovery_organization_public_key||null}get publicKeyId(){return this._props.public_key_id}get armoredKey(){return this._account_recovery_organization_public_key?this._account_recovery_organization_public_key.armoredKey:null}get revokedKey(){return this._account_recovery_organization_revoked_key?this._account_recovery_organization_revoked_key.armoredKey:null}get policy(){return this._props.policy}get privateKeyPasswords(){return this._account_recovery_private_key_passwords?this._account_recovery_private_key_passwords:null}get isDisabled(){return this.policy===Bs.POLICY_DISABLED}get isEnabled(){return!this.isDisabled}get isOptIn(){return this.policy===Bs.POLICY_OPT_IN}get isOptOut(){return this.policy===Bs.POLICY_OPT_OUT}get creator(){return this._creator}static get ENTITY_NAME(){return"AccountRecoveryOrganizationPolicy"}static get POLICY_DISABLED(){return"disabled"}static get POLICY_MANDATORY(){return"mandatory"}static get POLICY_OPT_IN(){return"opt-in"}static get POLICY_OPT_OUT(){return"opt-out"}static get ALL_CONTAIN_OPTIONS(){return{account_recovery_organization_public_key:!0,account_recovery_organization_revoked_key:!0,account_recovery_private_key_passwords:!0,creator:!0}}}const Gs=Bs;class Ys extends Te{constructor(e){super(e,Ys.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/requests"}static getSupportedContainOptions(){return["creator","creator.gpgkey","account_recovery_private_key_passwords","armored_key"]}static getSupportedFiltersOptions(){return["has-users"]}async findById(e,t={}){const r=t?this.formatContainOptions(t,Ys.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}async findRequestByIdAndUserIdAndAuthenticationToken(e,t,r){this.assertValidId(e),this.assertValidId(t),this.assertValidId(r);const s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e}/${t}/${r}`);return(await this.apiClient.fetchAndHandleResponse("GET",s)).body}async findByUser(e){e=e?this.formatFilterOptions(e,Ys.getSupportedFiltersOptions()):null;const t={...e};return(await this.apiClient.findAll(t)).body}async create(e){return(await this.apiClient.create(e)).body}}const zs=Ys;class Vs extends Te{constructor(e){super(e,Vs.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/user-settings"}async saveUserSetting(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}}const Hs=Vs;class Ws extends Te{constructor(e){super(e,Ws.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/responses"}async saveReview(e){return(await this.apiClient.create(e)).body}}const Js=Ws;class Qs extends Te{constructor(e){super(e,Qs.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/private-key-passwords"}async findAll(){return(await this.apiClient.findAll()).body}}const Zs=Qs;class Xs extends Te{constructor(e){super(e,Xs.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/account-recovery/continue"}async continue(e,t){this.assertValidId(e),this.assertValidId(t),await this.apiClient.get(`${e}/${t}`)}}const ei=Xs;class ti extends Te{constructor(e){super(e,ti.RESOURCE_NAME)}static get RESOURCE_NAME(){return"setup"}async complete(e,t){this.assertValidId(e);const r=new URL(`${this.apiClient.baseUrl}/complete/${e}`),s=this.apiClient.buildBody(t);return this.apiClient.fetchAndHandleResponse("POST",r,s)}async completeRecover(e,t){this.assertValidId(e);const r=new URL(`${this.apiClient.baseUrl}/recover/complete/${e}`),s=this.apiClient.buildBody(t);return this.apiClient.fetchAndHandleResponse("POST",r,s)}async findSetupInfo(e,t){this.assertValidId(e),this.assertValidId(t);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/start/${e}/${t}`,{});return(await this.apiClient.fetchAndHandleResponse("GET",r)).body}async findRecoverInfo(e,t){this.assertValidId(e),this.assertValidId(t);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover/start/${e}/${t}`,{});return(await this.apiClient.fetchAndHandleResponse("GET",r)).body}async abort(e,t){this.assertValidId(e);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/recover/abort/${e}`,{}),s=this.apiClient.buildBody(t);return(await this.apiClient.fetchAndHandleResponse("POST",r,s)).body}async findLegacySetupInfo(e,t){this.assertValidId(e),this.assertValidId(t);const r=new URL(`${this.apiClient.baseUrl}/install/${e}/${t}`);let s,i,o,n,a;try{s=await fetch(r.toString())}catch(e){throw new be(e.message)}try{i=await s.text();const e=(new DOMParser).parseFromString(i,"text/html");o=e.getElementById("js_setup_user_username").value,n=e.getElementById("js_setup_user_first_name").value,a=e.getElementById("js_setup_user_last_name").value}catch(e){throw new fe}return{username:o,profile:{first_name:n,last_name:a}}}async findLegacyRecoverInfo(e,t){this.assertValidId(e),this.assertValidId(t);const r=new URL(`${this.apiClient.baseUrl}/recover/${e}/${t}`);let s,i,o,n,a;try{s=await fetch(r.toString())}catch(e){throw new be(e.message)}try{i=await s.text();const e=(new DOMParser).parseFromString(i,"text/html");o=e.getElementById("js_setup_user_username").value,n=e.getElementById("js_setup_user_first_name").value,a=e.getElementById("js_setup_user_last_name").value}catch(e){throw new fe}return{username:o,profile:{first_name:n,last_name:a}}}}const ri=ti;class si extends Ct{constructor(e){super(se.validate(si.ENTITY_NAME,e,si.getSchema()));this._props.map((e=>e.id)).sort().sort(((e,t)=>{if(e===t)throw new jt(0,si.RULE_UNIQUE_ID,`AccountRecoveryRequest id ${e} already exists.`)})),this._props.forEach((e=>{this._items.push(new Xt(e))})),this._props=null}static getSchema(){return{type:"array",items:Xt.getSchema()}}get accountRecoveryRequests(){return this._items}get ids(){return this._items.map((e=>e.id))}static sanitizeDto(e){return Array.isArray(e)?Bt(e,"id"):[]}assertUniqueId(e){if(!e.id)return;const t=this.accountRecoveryRequests.length;let r=0;for(;r<t;r++){const t=this.accountRecoveryRequests[r];if(t.id&&t.id===e.id)throw new jt(r,si.RULE_UNIQUE_ID,`account recovery private key password id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("accountRecoveryRequestsCollection push parameter should be an object.");e instanceof Xt&&(e=e.toDto());const t=new Xt(e);this.assertUniqueId(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}removeMany(e){for(const t in e)this.remove(e[t])}static get ENTITY_NAME(){return"AccountRecoveryRequest"}static get RULE_UNIQUE_ID(){return"unique_id"}}const ii=si;const oi=class{constructor(e){this.accountRecoveryOrganizationPolicyService=new Ks(e),this.accountRecoveryRequestService=new zs(e),this.accountRecoveryUserService=new Hs(e),this.accountRecoveryResponseService=new Js(e),this.accountRecoveryPrivateKeyPasswordService=new Zs(e),this.accountRecoveryContinueService=new ei(e),this.setupService=new ri(e)}async findOrganizationPolicy(e={}){const t=await this.accountRecoveryOrganizationPolicyService.find(e);if(!t)return null;const r=new Gs(t);return r.isDisabled&&r.creator&&await Gs.assertValidCreatorGpgkey(r),r}async findUserRequests(e={}){const t=await this.accountRecoveryRequestService.findByUser(e);return new ii(t)}async findRequestById(e,t={}){if(!J().isUUID(e))throw new TypeError("id should be a valid uuid.");const r=await this.accountRecoveryRequestService.findById(e,t);return new Xt(r)}async findAccountRecoveryPrivateKeyPasswords(){const e=await this.accountRecoveryPrivateKeyPasswordService.findAll();return new Wt(e)}async saveUserSetting(e){const t=e.toDto(tr.ALL_CONTAIN_OPTIONS),r=await this.accountRecoveryUserService.saveUserSetting(t);return new tr(r)}async saveOrganizationPolicy(e){const t=e.toDto(Gs.ALL_CONTAIN_OPTIONS),r=await this.accountRecoveryOrganizationPolicyService.saveOrganizationPolicy(t);return new Gs(r)}async saveReview(e){const t=e.toDto(),r=await this.accountRecoveryResponseService.saveReview(t);return new Kt(r)}async continue(e,t){if(!J().isUUID(e))throw new TypeError("userId should be a valid uuid.");if(!J().isUUID(t))throw new TypeError("authenticationTokenToken should be a valid uuid.");await this.accountRecoveryContinueService.continue(e,t)}async findRequestByIdAndUserIdAndAuthenticationToken(e,t,r){if(!J().isUUID(e))throw new TypeError("requestId should be a valid uuid.");if(!J().isUUID(t))throw new TypeError("userId should be a valid uuid.");if(!J().isUUID(r))throw new TypeError("authenticationTokenToken should be a valid uuid.");const s=await this.accountRecoveryRequestService.findRequestByIdAndUserIdAndAuthenticationToken(e,t,r);return new Xt(s)}};const ni=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.accountRecoveryModel.findOrganizationPolicy({creator:!0,"creator.gpgkey":!0})}},ai={},ci="WorkerExistFlush",ui=function(e,t){li(e,t)?(Le.write({level:"debug",message:`model/worker::remove ${e}, tab:${t}`}),delete ai[t][e]):Le.write({level:"warning",message:`model/worker::remove unable to remove ${e}, it does not exist for tab ${t}`})},pi=function(e,t,r=!0){if(!li(e,t)){const s=new Error(`Could not find worker ID ${e} for tab ${t}.`);throw r&&console.error(s,ai),s}return ai[t][e]},li=function(e,t){return!(!ai[t]||!ai[t][e])},di=function(e){u.alarms.create(ci,{when:Date.now()+100}),u.alarms.onAlarm.addListener(e)},hi=function(e){u.alarms.onAlarm.removeListener(e),u.alarms.clear(ci)},gi={waitExists:function(e,t,r=1e4){const s=Date.now()+r;return new Promise(((r,i)=>{const o=n=>{if(n.name===ci)try{hi(o),pi(e,t,!1),r()}catch(e){n.scheduledTime>=s?i(e):di(o)}};di(o)}))},exists:li,get:pi,add:function(e,t){const r=t?.tab?.id||-1;li(e,r)&&ai[r][e].destroy(`from model/worker::add because ${e} already exist at tab ${r}`),Le.write({level:"debug",message:`model/worker:: Add worker ${e}, tab:${r}, url:${t?.tab?.url}`}),ai[r]=ai[r]||{},ai[r][e]=t;t.on("detach",(()=>ui(e,r)))}};class yi extends X{constructor(e){if(super(se.validate(yi.ENTITY_NAME,e,yi.getSchema())),!e.policy&&!e.account_recovery_organization_public_key)throw new te("AccountRecoveryOrganizationPolicyChangeEntity expects a policy or an account_recovery_organization_public_key set to be valid.");if(e.policy===Gs.POLICY_DISABLED&&e.account_recovery_organization_public_key)throw new te("AccountRecoveryOrganizationPolicyChangeEntity expects not to have an account recovery organization public key if the policy type is disabled.");this._props.account_recovery_organization_public_key&&(this._account_recovery_organization_public_key=new js(this._props.account_recovery_organization_public_key),Gs.assertValidAccountRecoveryOrganizationPublicKey(this._account_recovery_organization_public_key,this.public_key_id),delete this._props.account_recovery_organization_public_key)}static getSchema(){return{type:"object",required:[],properties:{policy:Gs.getSchema().properties.policy,account_recovery_organization_public_key:js.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._account_recovery_organization_public_key&&e.account_recovery_organization_public_key&&(t.account_recovery_organization_public_key=this._account_recovery_organization_public_key.toDto()),t):t}toJSON(){return this.toDto({account_recovery_organization_public_key:!0})}get policy(){return this._props.policy||null}get accountRecoveryOrganizationPublicKey(){return this._account_recovery_organization_public_key||null}get armoredKey(){return this._account_recovery_organization_public_key?.armoredKey||null}get isDisabled(){return!!this.policy&&this.policy===Gs.POLICY_DISABLED}static get ENTITY_NAME(){return"AccountRecoveryOrganizationChangePolicy"}}const _i=yi;class mi extends Error{constructor(e){super(e=e||w.t("This is not a valid passphrase")),this.name="InvalidMasterPasswordError"}}const wi=mi,fi=/[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}/i,Ei=(e,t="The given parameter is not a valid UUID")=>{if(!fi.test(e))throw new Error(t)},Si=e=>{if(!Ne(e))throw new Error("The given parameter should be a valid UTF8 string.")},vi=e=>{if(!(e instanceof CryptoKey))throw new Error("The given parameter is not a CryptoKey");const t=e.algorithm;if("AES-GCM"!==t.name)throw new Error("The given key should use the algorithm 'AES-GCM'");if(t.length<256)throw new Error("The given key length should be of 256 bits");const r=e.usages;if(!(2===r.length&&r.includes("encrypt")&&r.includes("decrypt")))throw new Error("The given key should be usable for encryption and decryption only")},bi=e=>{if(vi(e),e.extractable)throw new Error("The given key should not be extractable")},Ai=e=>{if(vi(e),!e.extractable)throw new Error("The given key should be extractable")},Ti=e=>{if(!(e instanceof Uint8Array))throw new Error("The given initialisation vector should be a Uint8Array");if(12!==e.length)throw new Error("The initialisation vector should be 12 bytes long")};const Ii=class{static async decrypt(e,t){I(e),Si(t);try{return await h.IM({privateKey:e,passphrase:t})}catch(e){throw new wi}}};const Ri=class{static async sign(e,t){return k(e),R(t),e.signAllUsers(t)}};const Ci=class{static async revoke(e){C(e);const{publicKey:t}=await h.c4({key:e,format:"object"});return t}};const Oi={openInDetachedMode:async function(e=[]){const t=await async function(e){const t=await u.browserAction.getPopup({}),r=new URL(t);return e.forEach((e=>r.searchParams.append(e.name,e.value))),r.href}(e),{top:r,left:s}=await async function(){const e=await u.windows.getCurrent(),t=e.left+e.width-380,r=e.top;return{top:r,left:t}}(),i={url:t,type:"panel",left:s,top:r,width:380,height:400},o=await u.windows.create(i);return u.windows.update(o.id,{left:s,top:r}),o}};class ki extends Error{constructor(e){super(e),this.name="UserAbortsOperationError"}}const Ni=ki,Pi=async function(e){const t=await e.port.request("passbolt.passphrase.request"),{passphrase:r,rememberMe:s}=t;return await Mi(r),await xi(r,s),r},Ui=async function(e,t){const r=t?.tabs?.[0]?.id;await gi.waitExists("QuickAccess",r);const s=gi.get("QuickAccess",r);let i=!1;const o=new Promise(((t,r)=>{s.port.on(e,((e,s)=>{i=!0,"SUCCESS"===e?t(s):r(s)})),s.port._port.onDisconnect.addListener((()=>{if(!i){i=!0;const e=new Ni("The dialog has been closed.");r(e)}}))}));return o},xi=async function(e,t){t&&Number.isInteger(t)&&await Be.set(e,t)},Mi=async function(e){if(!ke(e))throw new Error(w.t("The passphrase should be a valid UTF8 string."));const t=(new ge).findPrivate().armoredKey,r=await M(t);await Ii.decrypt(r,e)},Li={get:async function(e){const t=await Be.get();return t||Pi(e)},request:Pi,requestFromQuickAccess:async function(){const e=await Be.get();if(e)return e;const t=Math.round(Math.random()*Math.pow(2,32)).toString(),r=[{name:"uiMode",value:"detached"},{name:"feature",value:"request-passphrase"},{name:"requestId",value:t}],s=await Oi.openInDetachedMode(r),{passphrase:i,rememberMe:o}=await Ui(t,s);return await Mi(i),await xi(i,o),i}};class Di extends X{constructor(e){super(se.validate(Di.ENTITY_NAME,e,Di.getSchema()))}static getSchema(){return{type:"object",required:["type","version","domain","private_key_user_id","private_key_fingerprint","private_key_secret","created"],properties:{type:{type:"string",enum:["account-recovery-private-key-password-decrypted-data"]},version:{type:"string",enum:["v1"]},domain:{type:"string"},private_key_user_id:{type:"string",format:"uuid"},private_key_fingerprint:{type:"string",minLength:40,maxLength:40},private_key_secret:{type:"string",minLength:128,maxLength:128},created:{type:"string",format:"date-time"}}}}get type(){return this._props.type}get version(){return this._props.version}get domain(){return this._props.domain}get privateKeyUserId(){return this._props.private_key_user_id}get privateKeyFingerprint(){return this._props.private_key_fingerprint}get privateKeySecret(){return this._props.private_key_secret}get created(){return this._props.created}static get ENTITY_NAME(){return"AccountRecoveryPrivateKeyPasswordDecryptedData"}}const Fi=Di;const qi=class{static async decrypt(e,t,r,s,i){let o;if(t.getFingerprint().toUpperCase()!==e.recipientFingerprint)throw new Error("The decryption key fingerprint does not match the private key password recipient fingerprint.");const n=await U(e.data),a=await _e.decrypt(n,t);try{o=JSON.parse(a)}catch(e){throw new Error("Unable to parse the decrypted private key password data.")}const c=new Fi(o);if(c.domain!==r)throw new Error("The domain contained in the private key password data does not match the expected target domain.");if(s&&c.privateKeyUserId!==s)throw new Error("The user id contained in the private key password data does not match the private key target used id.");if(i&&c.privateKeyFingerprint!==i.getFingerprint().toUpperCase())throw new Error("The private key password data fingerprint should match the user public fingerprint.");return c}};class Ki extends X{constructor(e){super(se.validate(Ki.ENTITY_NAME,e,Ki.getSchema()))}static getSchema(){return{type:"object",required:["armored_key","passphrase"],properties:{armored_key:{type:"string"},passphrase:{type:"string"}}}}get armoredKey(){return this._props.armored_key}get passphrase(){return this._props.passphrase}static get ENTITY_NAME(){return"PrivateGpgkey"}}const $i=Ki;const ji=class{constructor(e,t){this.worker=e,this._title=t,this._progress=0,this.lastTimeCall=null,this.message=null,this.isClose=!1,this._updateProgressBar=this._updateProgressBar.bind(this)}set title(e){this._title=e}get progress(){return this._progress}start(e,t){this._progress=0,this.isClose=!1,this.worker.port.emit("passbolt.progress.open-progress-dialog",this._title,e,t),this.lastTimeCall=(new Date).getTime()}updateGoals(e){this.worker.port.emit("passbolt.progress.update-goals",e)}async finishStep(e,t=!1){this._progress++,this.message=e,await this._debounceAction(this._updateProgressBar,t)}async close(){return new Promise((e=>{this.worker.port.emit("passbolt.progress.close-progress-dialog"),this.isClose=!0,setTimeout(e,0)}))}_updateProgressBar(){this.worker.port.emit("passbolt.progress.update",this.message,this._progress)}async _debounceAction(e,t=!1){const r=(new Date).getTime(),s=r-this.lastTimeCall;if(t||!(s<80))return this.lastTimeCall=r,new Promise((t=>setTimeout((()=>{this.isClose||e(),t()}),0)))}};const Bi=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r),this.progressService=new ji(this.worker,w.t("Rekeying users' key")),this.keyring=new ge,this.account=s}async _exec(e,t=null){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t=null){const r=await Li.get(this.worker),s=new _i(e),i=t?new $i(t):null,o=await this.accountRecoveryModel.findOrganizationPolicy(),n=Boolean(s.accountRecoveryOrganizationPublicKey),a=this._hasToRevokedCurrentORK(s,o),c=n?await M(s.accountRecoveryOrganizationPublicKey.armoredKey):null,u=s.toDto({account_recovery_organization_public_key:!0});u.policy=u.policy||o.policy;const p=this.keyring.findPrivate().armoredKey,l=await M(p),d=await Ii.decrypt(l,r);if(n){const e=await Ri.sign(c,[d]);u.account_recovery_organization_public_key.fingerprint=c.getFingerprint().toUpperCase(),u.account_recovery_organization_public_key.armored_key=e.armor()}else u.public_key_id=o.publicKeyId;if(a){const e=await M(i.armoredKey),t=await Ii.decrypt(e,i.passphrase),r=await Ci.revoke(t);if(u.account_recovery_organization_revoked_key={armored_key:r.armor(),fingerprint:t.getFingerprint().toUpperCase()},n){const e=this.account.domain,r=await this._reEncryptPrivateKeyPasswords(c,t,d,e),s=await Ri.sign(c,[t]);u.account_recovery_organization_public_key.armored_key=s.armor(),u.account_recovery_private_key_passwords=r.toDto()}}const h=new Gs(u);return this.accountRecoveryModel.saveOrganizationPolicy(h)}_hasToRevokedCurrentORK(e,t){return!t.isDisabled&&(!!e.isDisabled||Boolean(e.accountRecoveryOrganizationPublicKey)&&t.armoredKey!==e.armoredKey)}async _reEncryptPrivateKeyPasswords(e,t,r,s){const i=await this.accountRecoveryModel.findAccountRecoveryPrivateKeyPasswords();if(0===i.length)return new Wt([]);this.progressService.start(i.length,w.t("Updating users' key..."));const o=[];try{for(const n of i){const i=await this._reEncryptPrivateKeyPassword(n,e,t,r,s);o.push(i),await this.progressService.finishStep()}}catch(e){throw console.error(e),await this.progressService.close(),e}return await this.progressService.close(),new Wt(o)}async _reEncryptPrivateKeyPassword(e,t,r,s,i){const o=await qi.decrypt(e,r,i),n=JSON.stringify(o),a=await ye.encrypt(n,t,[r,s]);return new Vt({data:a,private_key_id:e.privateKeyId,recipient_fingerprint:t.getFingerprint().toUpperCase(),recipient_foreign_model:Vt.FOREIGN_MODEL_ORGANIZATION_KEY})}};const Gi=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.accountRecoveryModel.findOrganizationPolicy();await Ks.validatePublicKey(e,t.armoredKey)}};class Yi extends Error{constructor(e,t){super(e),this.name="WrongOrganizationRecoveryKeyError",this.expectedFingerprint=t}}const zi=Yi;const Vi=class{static async validate(e,t){const r=await M(e.accountRecoveryOrganizationPublicKey.armoredKey),s=await M(t.armoredKey),i=r.getFingerprint().toUpperCase();if(i!==s.getFingerprint().toUpperCase())throw new zi(`Error, this is not the current organization recovery key. Expected fingerprint: ${i}`,i);await Ii.decrypt(s,t.passphrase)}};const Hi=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new $i(e),r=await this.accountRecoveryModel.findOrganizationPolicy();if(!r)throw new Error("Account recovery organization policy not found.");await Vi.validate(r,t)}};const Wi=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!J().isUUID(e))throw new Error("The user id is not valid");const t={"has-users":[e]};return this.accountRecoveryModel.findUserRequests(t)}};const Ji=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(void 0===e)throw new Error("An account recovery request id is required.");if("string"!=typeof e)throw new Error("The account recovery request should be a string.");if(!J().isUUID(e))throw new Error("The account recovery request should be a valid uuid.");return this.accountRecoveryModel.findRequestById(e,{creator:!0,"creator.gpgkey":!0})}};const Qi=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.accountRecoveryModel=new oi(r),this.keyringModel=new ge}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t,r=null){if("string"!=typeof e||!J().isUUID(e))throw new TypeError("requestId should be a valid uuid.");let s;const i=await this.accountRecoveryModel.findOrganizationPolicy();if(i.isDisabled)throw new Error("Sorry the account recovery feature is not enabled for this organization.");const o=await this._findAndAssertRequest(e);if(t===Kt.STATUS_APPROVED){const e=new $i(r),t=await Li.get(this.worker);s=await this._buildApprovedResponse(o,i,e,t)}else{if(t!==Kt.STATUS_REJECTED)throw new Error("The provided status should be either approved or rejected.");s=this._buildRejectedResponse(e,i)}const n=await this.accountRecoveryModel.saveReview(s);return await this._updateUserLocalStorage(o.userId),n}_buildRejectedResponse(e,t){const r={status:Kt.STATUS_REJECTED,account_recovery_request_id:e,responder_foreign_key:t.publicKeyId,responder_foreign_model:Kt.RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY};return new Kt(r)}async _buildApprovedResponse(e,t,r,s){const i=await M(r.armoredKey),o=await M(this.account.userPrivateArmoredKey),n=await Ii.decrypt(i,r.passphrase),a=await Ii.decrypt(o,s),c=await M(await this._findUserPublicKey(e.userId)),u=await this._encryptResponseData(e,n,c,a),p={status:Kt.STATUS_APPROVED,account_recovery_request_id:e.id,responder_foreign_key:t.publicKeyId,responder_foreign_model:Kt.RESPONDER_FOREIGN_MODEL_ORGANIZATION_KEY,data:u};return new Kt(p)}async _findAndAssertRequest(e){const t=await this.accountRecoveryModel.findRequestById(e,{account_recovery_private_key_passwords:!0,armored_key:!0}),r=t.accountRecoveryPrivateKey;if(!r)throw new Error("The request should have an associated private key.");if(r.userId!==t.userId)throw new Error("The request user should match the request associated private key user.");if(!r.accountRecoveryPrivateKeyPasswords)throw new Error("The account recovery request private key should have a collection of private key passwords.");if(1!==r.accountRecoveryPrivateKeyPasswords.length)throw new Error("The account recovery request private key should have a collection containing exactly one private key password.");const s=r.accountRecoveryPrivateKeyPasswords.items[0];if(s.recipientForeignModel!==Vt.FOREIGN_MODEL_ORGANIZATION_KEY)throw new Error("The request private key password should be encrypted for the organization key.");if(s.privateKeyId!==r.id)throw new Error("The request private key password private key id should match the request private key id.");return t}async _findUserPublicKey(e){let t=this.keyringModel.findPublic(e);if(!t&&(await this.keyringModel.sync(),t=this.keyringModel.findPublic(e),!t))throw new Error("Cannot find the public key of the user requesting an account recovery.");return t.armoredKey}async _encryptResponseData(e,t,r,s){const i=this.account.domain,o=e.accountRecoveryPrivateKey.accountRecoveryPrivateKeyPasswords.items[0],n=await qi.decrypt(o,t,i,e.userId,r),a=JSON.stringify(n),c=await M(e.armoredKey);return ye.encrypt(a,c,[t,s])}async _updateUserLocalStorage(e){const t=await es.getUserById(e);t.pending_account_recovery_request=null;const r=new sr(t);await es.updateUser(r)}};const Zi=class{static async getDate(e){const t=new st(e);let r;try{r=await t.getOrFind()}catch(e){return console.error(e),(new Date).getTime()}return r.isServerInPast()?r.serverTime:(new Date).getTime()}};class Xi extends X{constructor(e){super(se.validate(Xi.ENTITY_NAME,e,Xi.getSchema())),this._props.private_key&&(this._private_key=new oe(this._props.private_key),delete this._props.private_key),this._props.public_key&&(this._public_key=new oe(this._props.public_key),delete this._props.public_key)}static getSchema(){return{type:"object",required:["public_key","private_key"],properties:{public_key:oe.getSchema(),private_key:oe.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(e.public_key&&this._public_key&&(t.public_key=this.publicKey.toDto()),e.private_key&&this._private_key&&(t.private_key=this.privateKey.toDto()),t):t}toJSON(){return this.toDto(Xi.ALL_CONTAIN_OPTIONS)}get publicKey(){return this._public_key}get privateKey(){return this._private_key}static get ENTITY_NAME(){return"externalGpgKeyPairEntity"}static get ALL_CONTAIN_OPTIONS(){return{public_key:!0,private_key:!0}}}const eo=Xi;const to=class{static async generateKeyPair(e){const t=Object.assign(e.toGenerateOpenpgpKeyDto(),{format:"armored"}),r=await h.k$(t);return new eo({public_key:{armored_key:r.publicKey},private_key:{armored_key:r.privateKey}})}};const ro=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.apiClientOptions=r}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e={}){const t={type:Fs.TYPE_RSA,keySize:4096,date:await Zi.getDate(this.apiClientOptions)};Object.assign(e,t);const r=new Fs(e);return to.generateKeyPair(r)}};var so=r(6057),io=r.n(so);const oo=class{static async build(e,t,r){if(C(t),!(r&&r instanceof Gs))throw new Error("The provided organizationPolicy must be a valid AccountRecoveryOrganizationPolicyEntity.");const s=io().random(512),i=await this._encryptPrivateKey(s,t),o=await this._encryptPrivateKeyPasswordsForOrganizationKey(e,s,r,t);i.account_recovery_private_key_passwords=[o];const n={user_id:e.userId,status:tr.STATUS_APPROVED,account_recovery_private_key:i};return new tr(n)}static async _encryptPrivateKey(e,t){return{data:await ye.encryptSymmetrically(t.armor(),[e],[t])}}static async _encryptPrivateKeyPasswordsForOrganizationKey(e,t,r,s){const i=await M(r.armoredKey),o=this._buildPrivateKeyPasswordDecryptedData(e,t),n=JSON.stringify(o.toDto());return{data:await ye.encrypt(n,i,[s]),recipient_foreign_model:Vt.FOREIGN_MODEL_ORGANIZATION_KEY,recipient_fingerprint:i.getFingerprint().toUpperCase()}}static _buildPrivateKeyPasswordDecryptedData(e,t){const r={domain:e.domain,type:"account-recovery-private-key-password-decrypted-data",version:"v1",private_key_user_id:e.userId,private_key_fingerprint:e.userKeyFingerprint,private_key_secret:t,created:(new Date).toISOString()};return new Fi(r)}};const no=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.keyring=new ge,this.account=s,this.accountRecoveryModel=new oi(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.accountRecoveryModel.findOrganizationPolicy();if(!t)throw new Error("Account recovery organization policy not found.");if(t.isDisabled)throw new Error("The Account recovery organization policy should be enabled.");let r;if(e.status===tr.STATUS_APPROVED)r=await this.buildApprovedUserSetting(t);else{const e={user_id:Ye.getInstance().get().id,status:tr.STATUS_REJECTED};r=new tr(e)}return this.accountRecoveryModel.saveUserSetting(r)}async buildApprovedUserSetting(e){const t=await Li.request(this.worker),r=this.keyring.findPrivate().armoredKey,s=await M(r),i=await Ii.decrypt(s,t);return oo.build(this.account,i,e)}};let ao=!1,co=!1;const uo=class{static hasPostponedAccountRecovery(){return ao}static hasPostponedMFAPolicy(){return co}static postponeAccountRecovery(){ao=!0}static postponeMFAPolicy(){co=!0}static reset(){ao=!1,co=!1}static init(){this.reset(),self.addEventListener("passbolt.auth.after-logout",(()=>{this.reset()}))}};const po=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return uo.hasPostponedAccountRecovery()}};const lo=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){uo.postponeAccountRecovery()}};const ho=class{static saveFile(e,t,r,s){return r||(r="text/plain"),t=new Blob([t],{type:r}),new Promise((r=>{if(chrome.downloads){const s=self.URL.createObjectURL(t),i=!H();u.downloads.download({url:s,filename:e,saveAs:i}).then((()=>{self.URL.revokeObjectURL(s),r()}))}else this.blobToDataURL(t).then((t=>{gi.get("FileIframe",s).port.emit("passbolt.file-iframe.download",e,t),r()}))}))}static blobToDataURL(e){return new Promise((t=>{const r=new FileReader;r.onload=function(e){t(e.target.result)},r.readAsDataURL(e)}))}},go=["https://login.microsoftonline.com","https://login.microsoftonline.us","https://login.partner.microsoftonline.cn"];class yo extends X{constructor(e){super(se.validate(yo.ENTITY_NAME,e,yo.getSchema()))}static getSchema(){return{type:"object",required:["url"],properties:{url:{type:"x-custom",validationCallback:yo.validateUrl}}}}static validateUrl(e){if("string"!=typeof e)throw new TypeError("The url should be a string.");let t;try{t=new URL(e)}catch(e){throw new Error("The url should be a valid url.")}if(!go.some((e=>t.origin===e)))throw new Error("The url should be part of the list of supported single sign-on urls.")}get url(){return this._props.url}static get ENTITY_NAME(){return"SsoLoginUrl"}}const _o=yo;const mo=class{constructor(e,t,r){this.popup=null,this.popupTabId=null,this.verifyCodeInTab=this.verifyCodeInTab.bind(this),this.verifyPopupClosed=this.verifyPopupClosed.bind(this);const s=r?"/sso/login/dry-run/success":"/sso/login/success";this.expectedUrl=`${e}${s}`,this.originTabIdCall=t}async getSsoTokenFromThirdParty(e){if(!(e instanceof _o))throw new Error("The login URL should be a valid instance of a SsoLoginUrlEntity");return this.popup=await this.openPopup(e.url),this.popupTabId=this.popup.tabs[0].id,new Promise(((e,t)=>{this.resolvePromise=e,this.rejectPromise=t,n().tabs.onUpdated.addListener(this.verifyCodeInTab),n().tabs.onRemoved.addListener(this.verifyPopupClosed)}))}async verifyCodeInTab(e,t,r){if(e===this.originTabIdCall)return this.rejectPromise(new Ni("The user navigated away from the tab where the SSO sign-in initiated")),void await this.closeHandler();if(e!==this.popupTabId)return;if("complete"!==r.status)return;const s=this.grabSsoTokenFromUrl(r.url);null!==s&&this.resolvePromise(s)}async verifyPopupClosed(e){e===this.originTabIdCall?(this.rejectPromise(new Ni("The user closed the tab from where the SSO sign-in initiated")),await this.closeHandler()):e===this.popupTabId&&this.rejectPromise(new Ni("The user closed the SSO sign-in popup"))}async closeHandler(){n().tabs.onUpdated.removeListener(this.verifyCodeInTab),n().tabs.onRemoved.removeListener(this.verifyPopupClosed),this.rejectPromise=null,this.resolvePromise=null,this.codeFound=null,this.popup&&!this.popup.closed&&n().tabs.remove(this.popupTabId),this.popup=null}async openPopup(e){const t={url:e,type:"popup",width:380,height:600};return await n().windows.create(t)}grabSsoTokenFromUrl(e){if(!e.startsWith(this.expectedUrl))return null;const t=new URL(e).searchParams.get("token")||null;return t?(Ei(t,"The SSO token should be a valid uuid."),t):void 0}};class wo{constructor(e){this.apiClientOptions=e}static get RESOURCE_NAME(){return"/sso/${providerId}/login/dry-run"}async getUrl(e,t){return(await this.getApiClient(e).create(t)).body}getApiClient(e){if("string"!=typeof e)throw new Error("The provider identifier should be a string");const t=wo.RESOURCE_NAME.replace("${providerId}",e);return this.apiClientOptions.setResourceName(t),new Ae(this.apiClientOptions)}}const fo=wo;const Eo=class{constructor(e){this.ssoDryRunService=new fo(e)}async getUrl(e,t){if(Ei(t,"The SSO settings id should be a valid uuid."),"string"!=typeof e)throw new Error("The provider identifier should be a valid string");const r={sso_settings_id:t},s=await this.ssoDryRunService.getUrl(e,r);return new _o(s)}};class So extends Te{constructor(e){super(e,So.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/sso/settings"}static getSupportedContainOptions(){return["data"]}async get(e){Ei(e,"The SSO settings id should be a valid uuid.");return(await this.apiClient.get(e)).body}async getCurrent(e){const t=e?this.formatContainOptions(e,So.getSupportedContainOptions()):null;return(await this.apiClient.get("current",t)).body}async saveDraft(e){return(await this.apiClient.create(e)).body}async activateSettings(e,t){Ei(e,"The SSO settings id should be a valid uuid.");return(await this.apiClient.update(e,t)).body}async delete(e){Ei(e,"The SSO settings id should be a valid uuid.");return(await this.apiClient.delete(e)).body}}const vo=So,bo=/^\d{4}-\d{2}-\d{2}$/,Ao=/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}$/;class To extends X{constructor(e){super(se.validate(To.ENTITY_NAME,To.sanitizeDto(e),To.getSchema()))}static getSchema(){return{type:"object",required:[],properties:{id:{type:"string",format:"uuid"},providers:{type:"array",items:{type:"string"}},provider:{anyOf:[{type:"string",enum:[To.AZURE]},{type:"null"}]},data:{type:"object"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}static sanitizeDto(e){return(e=Object.assign({},e))?.data?.client_secret_expiry&&Ao.test(e.data.client_secret_expiry)&&(e.data.client_secret_expiry=e.data.client_secret_expiry.substr(0,10)),e}toDto(){const e=JSON.parse(JSON.stringify(this));return e?.data?.client_secret_expiry&&bo.test(e.data.client_secret_expiry)&&(e.data.client_secret_expiry+=" 00:00:00"),e}get id(){return this._props.id}get provider(){return this._props.provider}static get ENTITY_NAME(){return"SsoSettings"}static get AZURE(){return"azure"}}const Io=To;const Ro=class{constructor(e){this.ssoSettingsService=new vo(e)}async saveDraft(e){const t=await this.ssoSettingsService.saveDraft(e.toDto());return new Io(t)}async getById(e){const t=await this.ssoSettingsService.get(e);return new Io(t)}async getCurrent(e){const t=await this.ssoSettingsService.getCurrent(e);return new Io(t)}async activate(e,t){const r={token:t,status:"active"},s=await this.ssoSettingsService.activateSettings(e,r);return new Io(s)}async delete(e){await this.ssoSettingsService.delete(e)}};const Co=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.ssoSettingsModel=new Ro(r),this.ssoDryRunModel=new Eo(r),this.azurePopupHandler=new mo(s.domain,e?.tab?.id,!0)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){Ei(e,"The SSO settings id should be a valid uuid.");try{const t=await this.ssoSettingsModel.getById(e),r=await this.ssoDryRunModel.getUrl(t.provider,t.id),s=await this.azurePopupHandler.getSsoTokenFromThirdParty(r);return await this.azurePopupHandler.closeHandler(),s}catch(e){throw console.log("An error occured while handle Azure sign in:",e),e}}};const Oo=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new Ro(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.ssoSettingsModel.getCurrent({data:!0})}};const ko=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new Ro(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=new Io(e);return this.ssoSettingsModel.saveDraft(t)}};const No=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new Ro(r)}async _exec(e,t){try{const r=await this.exec(e,t);this.worker.port.emit(this.requestId,"SUCCESS",r)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){return Ei(e,"The SSO settings id should be a valid uuid."),Ei(t,"The SSO activation token should be a valid uuid."),await this.ssoSettingsModel.activate(e,t)}};const Po=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.ssoSettingsModel=new Ro(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){Ei(e,"The SSO settings id should be a valid uuid."),await this.ssoSettingsModel.delete(e)}};class Uo extends Te{constructor(e){super(e,Uo.RESOURCE_NAME)}static get RESOURCE_NAME(){return"auth"}static getSupportedContainOptions(){return[]}async logout(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/logout`,{});try{await this.apiClient.fetchAndHandleResponse("GET",e,null,{redirect:"manual"})}catch(e){if(!(e instanceof fe&&"opaqueredirect"===e?.srcResponse?.type))throw e}}async getServerKey(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/verify`,{}),t=await this.apiClient.fetchAndHandleResponse("GET",e);return this.mapGetServerKey(t.body)}mapGetServerKey(e){const{keydata:t,fingerprint:r}=e;return{armored_key:t,fingerprint:r}}async verify(e,t){const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/verify`,{}),s=new FormData;s.append("data[gpg_auth][keyid]",e),s.append("data[gpg_auth][server_verify_token]",t);const i=this.apiClient.buildFetchOptions();let o,n;i.method="POST",i.body=s,delete i.headers["content-type"];try{o=await fetch(r.toString(),i)}catch(e){throw new be(e.message)}try{n=await o.json()}catch(e){throw new fe}if(!o.ok){const e=n.header.message;throw new Se(e,{code:o.status,body:n.body})}return o}}const xo=Uo;const Mo=class{static async getKey(e){const t=(new ge).findPrivate()?.armoredKey;if(!t)throw new Error("Can't find current user's private key.");const r=await M(t);return Ii.decrypt(r,e)}};const Lo=class{constructor(e){this.authService=new xo(e),this.legacyAuthModel=new At}async logout(){await this.authService.logout(),await this.postLogout()}async postLogout(){await He.set(!1,!1);const e=new Event("passbolt.auth.after-logout");self.dispatchEvent(e)}async getServerKey(){return this.authService.getServerKey()}async login(e,t){t=t||!1;const r=Ye.getInstance(),s=await Mo.getKey(e);await r.retrieveAndStoreCsrfToken(),await this.legacyAuthModel.login(s),t&&await Be.set(e,-1),await this.postLogin()}async postLogin(){await this.legacyAuthModel.startCheckAuthStatusLoop(),await Qd.pageMods.AppBoostrap.init();const e=new Event("passbolt.auth.after-login");self.dispatchEvent(e)}async verify(e,t){let r,s;try{s=new We;const t=await M(e);r=await ye.encrypt(s.token,t)}catch(e){throw new Error(`Unable to encrypt the verify token. ${e.message}`)}const i=await this.authService.verify(t,r),o=new at(i.headers,"verify");if(new We(o.headers["x-gpgauth-verify-response"]).token!==s.token)throw new Error("The server was unable to prove it can use the advertised OpenPGP key.")}};class Do extends Te{constructor(e){super(e,Do.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/sso/keys"}async getSsoKit(e,t,r){Ei(e,"The SSO kit id should be a valid uuid."),Ei(t,"The user id should be a valid uuid."),Ei(r,"The SSO token should be a valid uuid.");return(await this.apiClient.get(`${e}/${t}/${r}`)).body}async setupSsoKit(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async deleteSsoKit(e){Ei(e,"The SSO kit id should be a valid uuid."),await this.apiClient.delete(e)}}const Fo=Do;var qo=r(8764);class Ko extends X{constructor(e){super(se.validate(Ko.ENTITY_NAME,e,Ko.getSchema()))}static getSchema(){return{type:"object",required:["data"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},data:{type:"x-custom",validationCallback:Ko.validateData},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}static validateData(e){if("string"!=typeof e)throw new TypeError("The data should be a string");if(!J().isBase64(e))throw new TypeError("The data should be a base64 formated string");const t=JSON.parse(qo.lW.from(e,"base64").toString());if("A256GCM"!==t.alg)throw new TypeError("The SSO server key should use the algorithm AES 256 bits");if(!t.ext)throw new TypeError("The SSO server key should be extractable");if("oct"!==t.kty)throw new TypeError("The SSO server key type should be an octect sequence");if("string"!=typeof t.k)throw new TypeError("The SSO server key data should be a string");const r=t.key_ops;if(!(2===r.length&&r.includes("encrypt")&&r.includes("decrypt")))throw new TypeError("The SSO server key be usable for and only for encryption and decryption")}get id(){return this._props.id}get data(){return this._props.data}get key(){return JSON.parse(qo.lW.from(this.data,"base64").toString())}static get ENTITY_NAME(){return"SsoKitServerPartEntity"}}const $o=Ko;const jo=class{constructor(e){this.ssoKitServerPartService=new Fo(e)}async getSsoKit(e,t,r){Ei(e,"The SSO kit id should be a valid uuid."),Ei(t,"The user id should be a valid uuid."),Ei(r,"The SSO token should be a valid uuid.");const s=await this.ssoKitServerPartService.getSsoKit(e,t,r);return new $o(s)}async setupSsoKit(e){const t=await this.ssoKitServerPartService.setupSsoKit(e);return new $o(t)}async deleteSsoKit(e){Ei(e,"The SSO kit id should be a valid uuid."),await this.ssoKitServerPartService.deleteSsoKit(e)}};class Bo extends X{constructor(e){const t=structuredClone(e);super(se.validate(Bo.ENTITY_NAME,t,Bo.getSchema())),Bo.validateNek(t.nek),Bo.validateIv(t.iv1),Bo.validateIv(t.iv2),this._props.nek=t.nek,this._props.iv1=t.iv1,this._props.iv2=t.iv2}static validateNek(e){const t=new te;if(e instanceof CryptoKey||t.addError("nek","type","SsoKitClientPartEntity expects an nek to be an instance of CryptoKey."),e.extractable&&t.addError("nek","type","SsoKitClientPartEntity expects an nek not to be extractable."),"AES-GCM"!==e?.algorithm?.name&&t.addError("nek","type","SsoKitClientPartEntity expects an nek to use the algorithm 'AES-GSM'."),256!==e?.algorithm?.length&&t.addError("nek","type","SsoKitClientPartEntity expects an nek to use 256 bits."),e?.usages?.includes("encrypt")||t.addError("nek","type","SsoKitClientPartEntity expects an nek to have the capability to encrypt."),e?.usages?.includes("decrypt")||t.addError("nek","type","SsoKitClientPartEntity expects an nek to have the capability to decrypt."),2!==e?.usages?.length&&t.addError("nek","type","SsoKitClientPartEntity expects an nek to only have the following capabilities: encrypt and decrypt."),t.hasErrors())throw t}static validateIv(e){const t=new te;if(e instanceof Uint8Array||t.addError("iv","type","SsoKitClientPartEntity expects IVs to be an instance of Uint8Array."),12!==e.length&&t.addError("iv","type","SsoKitClientPartEntity expects IVs to be of a length of 12 bytes."),t.hasErrors())throw t}toDto(){throw new Error("Serialization is not supported on this object")}toDbSerializableObject(){return structuredClone(this._props)}static getSchema(){return{type:"object",required:["nek","iv1","iv2","secret"],properties:{id:{type:"string",format:"uuid"},provider:{type:"string"},nek:{type:"object"},iv1:{type:"object"},iv2:{type:"object"},secret:{type:"string"},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified_by:{type:"string",format:"uuid"}}}}isRegistered(){return Boolean(this.provider)}set id(e){const t=Bo.getSchema();se.validateProp("id",e,t.properties.id),this._props.id=e}get id(){return this._props.id||null}set provider(e){const t=Bo.getSchema();se.validateProp("provider",e,t.properties.provider),this._props.provider=e}get provider(){return this._props.provider||null}get secret(){return this._props.secret}get nek(){return this._props.nek}get iv1(){return this._props.iv1}get iv2(){return this._props.iv2}static get ENTITY_NAME(){return"SsoKitClientPartEntity"}}const Go=Bo;const Yo=class{static async encrypt(e,t,r,s,i){bi(t),Ai(r),Ti(s),Ti(i);const o=qo.lW.from(e),n={name:t.algorithm.name,iv:s},a={name:r.algorithm.name,iv:i},c=await crypto.subtle.encrypt(n,t,o),u=await crypto.subtle.encrypt(a,r,c);return qo.lW.from(u).toString("base64")}};const zo=class{static generateIv(e=12){return crypto.getRandomValues(new Uint8Array(e))}};const Vo=class{static async generateSsoKey(e=!1){return crypto.subtle.generateKey({name:"AES-GCM",length:256},e,["encrypt","decrypt"])}},Ho="sso_kit";const Wo=class{static async get(){const e=await this.getDbHandler(),t=await this.getSsoData(e);return e.close(),t}static async save(e){const t=await this.getDbHandler();await this.replaceSsoData(t,e),t.close()}static async updateLocalKitIdWith(e){Ei(e,"A valid SSO kit id is required");const t=await this.getDbHandler();await this.updateSsoDataWithId(t,e),t.close()}static async flush(){const e=await this.getDbHandler();await this.clearData(e)}static async getDbHandler(){return new Promise(((e,t)=>{const r=indexedDB.open("sso_kit_db",1);r.onupgradeneeded=e=>{const t=e.target.result;if(console.log(`Upgrading SSO IndexedDB from version ${e.oldVersion} to version ${e.newVersion}.`),e.oldVersion<1){t.createObjectStore(Ho,{keyPath:"pk_id"}).createIndex("sso_kit","sso_kit",{unique:!0})}console.log("SSO IndexedDB upgrade completed.")},r.onsuccess=()=>{e(r.result)},r.onerror=e=>{console.error("Database failed to open"),console.error(e),t()}}))}static async replaceSsoData(e,t){await this.clearData(e),await this.storeData(e,t)}static async getSsoData(e){return new Promise(((t,r)=>{const s=e.transaction([Ho],"readonly").objectStore(Ho).openCursor();s.onsuccess=e=>{const r=e.target.result;if(!r)return void t(null);const s=new Go(r.value.sso_kit);t(s)},s.onerror=e=>{console.error("An error occured when trying to open the IndexDb cursor:",e),r()}}))}static async clearData(e){return new Promise(((t,r)=>{const s=e.transaction([Ho],"readwrite").objectStore(Ho).clear();s.onsuccess=()=>{console.log("IndexDB SSO client data cleared"),t()},s.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to clear the data"),console.error(e),r()}}))}static async storeData(e,t){return new Promise(((r,s)=>{const i=e.transaction([Ho],"readwrite"),o=i.objectStore(Ho),n=t.toDbSerializableObject();o.add({pk_id:1,sso_kit:n}).onsuccess=()=>{console.log("New SSO client data stored successfully")},i.oncomplete=()=>{r()},i.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to add new data"),console.error(e),s()}}))}static async updateSsoDataWithId(e,t){const r=await this.getSsoData(e);return new Promise(((s,i)=>{const o=e.transaction([Ho],"readwrite"),n=o.objectStore(Ho),a=Object.assign({},r.toDbSerializableObject(),{id:t});n.put({pk_id:1,sso_kit:a}).onsuccess=()=>{console.log("The SSO Kit identifier has been updated successfully")},o.oncomplete=()=>{s()},o.onerror=e=>{console.error("The IndexedDB transaction couldn't be opened to updated the SSO Kit"),console.error(e),i()}}))}},Jo=new Fe,Qo="temp_server_part_sso_kit";const Zo=class{static async init(){await this.flush()}static async set(e){await Jo.acquire();try{await u.storage.session.set({[Qo]:e})}catch(e){throw Jo.release(),e}Jo.release()}static async getAndFlush(){await Jo.acquire();try{const e=(await u.storage.session.get(Qo))?.[Qo]||null;if(!e)return Jo.release(),null;const t=new $o(e);return Le.write({level:"debug",message:"SsoKitTemporaryStorageService flushed"}),await u.storage.session.remove(Qo),Jo.release(),t}catch(e){throw Jo.release(),e}}static async flush(){await Jo.acquire();try{Le.write({level:"debug",message:"SsoKitTemporaryStorageService flushed"}),await u.storage.session.remove(Qo)}catch(e){throw Jo.release(),e}Jo.release()}};const Xo=class{static async generate(e,t){try{const r=await this.generateSsoKits(e,t);await Wo.save(r.clientPart),await Zo.set(r.serverPart)}catch(e){throw await Wo.flush(),await Zo.flush(),e}}static async generateSsoKits(e,t){const r=await Vo.generateSsoKey(),s=await Vo.generateSsoKey(!0),i=zo.generateIv(),o=zo.generateIv(),n=await Yo.encrypt(e,r,s,i,o),a=new Go({nek:r,iv1:i,iv2:o,secret:n,provider:t}),c=await crypto.subtle.exportKey("jwk",s),u=qo.lW.from(JSON.stringify(c)).toString("base64");return{clientPart:a,serverPart:new $o({data:u})}}};const en=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.authModel=new Lo(r),this.organizationSettingsModel=new Xo(r),this.ssoKitServerPartModel=new jo(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await Wo.get();if(t)return void(t?.provider!==e&&(t.provider=e,await Wo.save(t)));const r=await Li.get(this.worker),s=await Xo.generateSsoKits(r,e),i=await this.ssoKitServerPartModel.setupSsoKit(s.serverPart);s.clientPart.id=i.id,await Wo.save(s.clientPart)}},tn={listen:function(e,t){e.port.on("passbolt.app.route-changed",(t=>{if(/^\/[A-Za-z0-9\-\/]*$/.test(t)){gi.get("AppBootstrap",e.tab.id).port.emit("passbolt.app-bootstrap.change-route",t)}})),e.port.on("passbolt.account-recovery.get-organization-policy",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new ni(e,t,r);await s._exec()})),e.port.on("passbolt.account-recovery.save-organization-policy",(async(r,s,i)=>{const o=await Ye.getInstance().getApiClientOptions(),n=new Bi(e,r,o,t);await n._exec(s,i)})),e.port.on("passbolt.account-recovery.validate-organization-key",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Gi(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.generate-organization-key",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new ro(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.download-organization-generated-key",(async(t,r)=>{try{const s=(new Date).toISOString().slice(0,10);await ho.saveFile(`organization-recovery-private-key-${s}.asc`,r,"text/plain",e.tab.id),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.account-recovery.validate-organization-private-key",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Hi(e,t,s);return await i._exec(r)})),e.port.on("passbolt.account-recovery.get-user-requests",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Wi(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.get-request",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Ji(e,t,s);await i._exec(r)})),e.port.on("passbolt.account-recovery.save-user-settings",(async(r,s)=>{const i=await Ye.getInstance().getApiClientOptions(),o=new no(e,r,i,t);await o._exec(s)})),e.port.on("passbolt.account-recovery.review-request",(async(r,s,i,o)=>{const n=await Ye.getInstance().getApiClientOptions(),a=new Qi(e,r,n,t);await a._exec(s,i,o)})),e.port.on("passbolt.account-recovery.has-user-postponed-user-setting-invitation",(async t=>{const r=new po(e,t);await r._exec()})),e.port.on("passbolt.account-recovery.postpone-user-setting-invitation",(async t=>{const r=new lo(e,t);await r._exec()})),e.port.on("passbolt.sso.get-current",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Oo(e,t,r);await s._exec()})),e.port.on("passbolt.sso.save-draft",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new ko(e,t,s);await i._exec(r)})),e.port.on("passbolt.sso.test.azure",(async(r,s)=>{const i=await Ye.getInstance().getApiClientOptions(),o=new Co(e,r,i,t);await o._exec(s)})),e.port.on("passbolt.sso.activate-settings",(async(t,r,s)=>{const i=await Ye.getInstance().getApiClientOptions(),o=new No(e,t,i);await o._exec(r,s)})),e.port.on("passbolt.sso.delete-settings",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Po(e,t,s);await i._exec(r)})),e.port.on("passbolt.sso.generate-sso-kit",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new en(e,t,s);await i._exec(r)}))}},rn={listen:function(e){e.port.on("passbolt.app-boostrap.navigate-to-logout",(async()=>{const t=Ye.getInstance(),r=await t.getApiClientOptions(),s=new Lo(r),i=`${t.settings.getDomain()}/auth/logout`;try{await chrome.tabs.update(e.tab.id,{url:i}),await s.postLogout()}catch(e){console.error(e)}}))}};class sn extends X{constructor(e){super(se.validate(sn.ENTITY_NAME,e,sn.getSchema())),this._props.profile&&(this._profile=new Lt(this._props.profile),delete this._props.profile)}static getSchema(){const e=sr.getSchema();return e.required=["id","username","profile"],e}toDto(e){const t=Object.assign({},this._props);return e?(this.profile&&e.profile&&(!0===e.profile?t.profile=this.profile.toDto():t.profile=this.profile.toDto(e.profile)),t):t}toJSON(){return this.toDto(sn.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get username(){return this._props.username}get profile(){return this._profile||null}static get ENTITY_NAME(){return"LoggedUser"}static get ALL_CONTAIN_OPTIONS(){return sr.ALL_CONTAIN_OPTIONS}}const on=sn,nn=[Ar.ENTITY_NAME,Gr.ENTITY_NAME];const an=class extends X{constructor(e){super(e),this._props.creator&&(this._creator=new on(this._props.creator),delete this._props.creator)}static getSchema(){return{type:"object",required:["id","action_log_id","type","creator"],properties:{id:{type:"string",format:"uuid"},action_log_id:{type:"string",format:"uuid"},type:{type:"string",maxLength:100},created:{type:"string",format:"date-time"},creator:on.getSchema()}}}toDto(){const e=Object.assign({},this._props);return this._creator&&(e.creator=this.creator.toDto(on.ALL_CONTAIN_OPTIONS)),e}toJSON(){return this.toDto()}get id(){return this._props.id||null}get type(){return this._props.type}get actionLogId(){return this._props.action_log_id||null}get created(){return this._props.created||null}get creator(){return this._creator||null}static get ENTITY_NAME(){return"AbstractActionLog"}static get ALLOWED_FOREIGN_MODELS(){return nn}};class cn extends an{constructor(e){super(se.validate(cn.ENTITY_NAME,e,cn.getSchema()))}static get ENTITY_NAME(){return"DefaultActionLog"}}const un=cn;class pn extends X{constructor(e){super(se.validate(pn.ENTITY_NAME,e,pn.getSchema())),this._props.user&&(this._user=new on(this._props.user),delete this._props.user),this._props.group&&(this._group=new or(this._props.group),delete this._props.group)}static getSchema(){return{type:"object",required:["id","type"],properties:{id:{type:"string",format:"uuid"},type:{type:"integer",enum:[ar.PERMISSION_READ,ar.PERMISSION_UPDATE,ar.PERMISSION_OWNER]},user:on.getSchema(),group:or.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.user&&e.user&&(!0===e.user?t.user=this.user.toDto():t.user=this.user.toDto(e.user)),this.group&&e.group&&(!0===e.group?t.group=this.group.toDto():t.group=this.group.toDto(e.group)),t):t}toJSON(){return this.toDto(pn.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get type(){return this._props.type}get user(){return this._user||null}get group(){return this._group||null}static get ENTITY_NAME(){return"UpdatedPermission"}static get ALL_CONTAIN_OPTIONS(){return ar.ALL_CONTAIN_OPTIONS}}const ln=pn;class dn extends Ct{constructor(e){super(se.validate(dn.ENTITY_NAME,e,dn.getSchema())),this._props.forEach((e=>{const t=new ln(e);this.push(t)})),this._props=null}static getSchema(){return{type:"array",items:ln.getSchema()}}get updatedPermissions(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.updatedPermissions.length;let r=0;for(;r<t;r++){const t=this.updatedPermissions[r];if(t.id&&t.id===e.id)throw new jt(r,dn.RULE_UNIQUE_ID,`Updated permission id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("UpdatePermissionsCollection push parameter should be an object.");e instanceof ln&&(e=e.toDto(ln.ALL_CONTAIN_OPTIONS));const t=new ln(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"UpdatedPermissions"}static get RULE_UNIQUE_ID(){return"unique_id"}}const hn=dn;class gn extends an{constructor(e){super(se.validate(gn.ENTITY_NAME,e,gn.getSchema()));let t=[],r=[],s=[];this._props.data&&(this._props.data.permissions&&(this._props.data.permissions.added&&(t=this._props.data.permissions.added),this._props.data.permissions.updated&&(r=this._props.data.permissions.updated),this._props.data.permissions.removed&&(s=this._props.data.permissions.removed)),delete this._props.data),this._permissionsAdded=new hn(t),this._permissionsUpdated=new hn(r),this._permissionsRemoved=new hn(s)}static getSchema(){const e=an.getSchema();return e.required=[...e.required,"data"],e.properties.type={type:"string",enum:gn.ALLOWED_TYPES},e.properties.data={type:"object",required:["permissions"],properties:{permissions:{type:"object",properties:{added:hn.getSchema(),updated:hn.getSchema(),removed:hn.getSchema()}}}},e}toDto(){const e=super.toDto();return e.data={permissions:{added:this.permissionsAdded.toDto(),updated:this.permissionsUpdated.toDto(),removed:this.permissionsRemoved.toDto()}},e}toJSON(){return this.toDto()}get permissionsAdded(){return this._permissionsAdded}get permissionsUpdated(){return this._permissionsUpdated}get permissionsRemoved(){return this._permissionsRemoved}static get ENTITY_NAME(){return"PermissionsUpdatedActionLog"}static get ALLOWED_TYPES(){return["Permissions.updated"]}}const yn=gn;class _n extends Ct{constructor(e){super(se.validate(_n.ENTITY_NAME,e,_n.getSchema())),this._props.forEach((e=>{const t=this.constructActionLogEntityFromDto(e);this.push(t)})),this._props=null}static getSchema(){return{type:"array",items:an.getSchema()}}constructActionLogEntityFromDto(e){return yn.ALLOWED_TYPES.includes(e.type)?new yn(e):new un(e)}get actionLogs(){return this._items}get ids(){return this._items.map((e=>e.id))}assertUniqueId(e){if(!e.id)return;const t=this.actionLogs.length;let r=0;for(;r<t;r++){const t=this.actionLogs[r];if(t.id&&t.id===e.id)throw new jt(r,_n.RULE_UNIQUE_ID,`Action log id ${e.id} already exists.`)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("ActionLogsCollection push parameter should be an object.");e instanceof an&&(e=e.toDto(Object.getPrototypeOf(e).ALL_CONTAIN_OPTIONS));const t=this.constructActionLogEntityFromDto(e);this.assertUniqueId(t),super.push(t)}static get ENTITY_NAME(){return"ActionLogs"}static get RULE_UNIQUE_ID(){return"unique_id"}}const mn=_n;class wn extends Te{constructor(e){super(e,wn.RESOURCE_NAME)}static get RESOURCE_NAME(){return"actionlog"}static getSupportedContainOptions(){return[]}static getSupportedFiltersOptions(){return[]}static getSupportedOrdersOptions(){return[]}async findAllFor(e,t,r,s){if(this.assertValidForeignModel(e),this.assertValidId(t),!r||"number"!=typeof r)throw new TypeError("ActionLog page should be a valid integer.");if(!s||"number"!=typeof s)throw new TypeError("ActionLog limit should be a valid integer.");const i=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e.toLowerCase()}/${t}`);i.searchParams.append("page",r.toString()),i.searchParams.append("limit",s.toString());const o=await this.apiClient.fetchAndHandleResponse("GET",i);return o.body&&o.body.length?o.body:[]}assertValidForeignModel(e){if(!e||"string"!=typeof e)throw new TypeError("ActionLog foreign model should be a valid string.");if(!an.ALLOWED_FOREIGN_MODELS.includes(e))throw new TypeError(`ActionLog foreign model ${e} in not in the list of supported models.`)}}const fn=wn;const En=class{constructor(e){this.actionLogService=new fn(e)}async findAllFor(e,t,r,s){const i=await this.actionLogService.findAllFor(e,t,r,s);return new mn(i)}},Sn={listen:async function(e){e.port.on("passbolt.actionlogs.find-all-for",(async(t,r,s,i)=>{try{const o=await Ye.getInstance().getApiClientOptions(),n=new En(o),{limit:a,page:c}=i,u=await n.findAllFor(r,s,c,a);e.port.emit(t,"SUCCESS",u)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};class vn extends Error{constructor(e){super(e),this.name="KeyIsExpiredError"}}const bn=vn;class An extends Error{constructor(e){super(e),this.name="ServerKeyChangedError"}}const Tn=An;const In=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.userDomain=s,this.keyring=new ge,this.authLegacy=new At(this.keyring),this.authModel=new Lo(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=this.keyring.findPublic(K(this.userDomain)).armoredKey,t=this.keyring.findPrivate().fingerprint;try{await this.authModel.verify(e,t)}catch(t){await this.onVerifyError(t,e)}}async onVerifyError(e,t){if(e.message&&-1!==e.message.indexOf("no user associated"))gi.get("AuthBootstrap",this.worker.tab.id).port.emit("passbolt.auth-bootstrap.remove-iframe");else try{await this.canParseServerKey(t)?await this.authLegacy.serverKeyChanged()?e=new Tn(w.t("The server key has changed.")):this.authLegacy.isServerKeyExpired()&&(e=new bn(w.t("The server key is expired."))):e=new Tn(w.t("The server key cannot be parsed."))}catch(t){e=new Error(w.t("Server internal error. Check with your administrator."))}throw e.message=`${w.t("Could not verify the server key.")} ${e.message}`,e}async canParseServerKey(e){try{await M(e)}catch(e){return!1}return!0}};const Rn=class{constructor(e,t){this.worker=e,this.requestId=t,this.auth=new At}async main(){try{const e=await this.auth.checkAuthStatus();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}};const Cn=class{constructor(e,t){this.worker=e,this.requestId=t,this.auth=new At}async main(e){e=e||{};try{await this.auth.isAuthenticated(e)?this.worker.port.emitQuiet(this.requestId,"SUCCESS",!0):this.worker.port.emitQuiet(this.requestId,"SUCCESS",!1)}catch(e){this.worker.port.emitQuiet(this.requestId,"ERROR",e)}}};const On=class{constructor(e,t){this.worker=e,this.requestId=t,this.auth=new At}async main(){try{await this.auth.isMfaRequired()?this.worker.port.emit(this.requestId,"SUCCESS",!0):this.worker.port.emit(this.requestId,"SUCCESS",!1)}catch(e){this.worker.port.emit(this.requestId,"ERROR",e)}}};const kn=class{constructor(e){this.keyring=e}async checkPassphrase(e){Si(e);const t=this.keyring.findPrivate();if(!t)throw new le(w.t("Private key not found."));const r=await M(t.armoredKey);await Ii.decrypt(r,e)}};const Nn=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new ge,this.checkPassphraseService=new kn(this.keyring)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){await this.checkPassphraseService.checkPassphrase(e)}};r(1010);class Pn extends Error{constructor(e,t){if(super(e),this.name="DeleteDryRunError",this.errors={},t.groups&&t.groups.sole_manager&&(this.errors.groups={sole_manager:new rs(t.groups.sole_manager)}),t.resources&&t.resources.sole_owner&&(this.errors.resources={sole_owner:new Pr(t.resources.sole_owner)}),t.folders&&t.folders.sole_owner&&(this.errors.folders={sole_owner:new zr(t.folders.sole_owner)}),!this.errors.folders&&!this.errors.resources&&!this.errors.groups)throw console.error(this),new TypeError("Invalid user deletion error. There should be at least some error details.")}toJSON(){const e=super.toJSON();return e.errors={},this.errors.groups&&this.errors.groups.sole_manager&&(e.errors.groups={sole_manager:this.errors.groups.sole_manager.toJSON()}),this.errors.resources&&this.errors.resources.sole_owner&&(e.errors.resources={sole_owner:this.errors.resources.sole_owner.toJSON()}),this.errors.folders&&this.errors.folders.sole_owner&&(e.errors.folders={sole_owner:this.errors.folders.sole_owner.toJSON()}),e}}const Un=Pn;class xn extends X{constructor(e){super(se.validate(xn.ENTITY_NAME,e,xn.getSchema()))}static getSchema(){return{type:"object",required:["id","group_id"],properties:{id:{type:"string",format:"uuid"},group_id:{type:"string",format:"uuid"}}}}get id(){return this._props.id}get groupId(){return this._props.group_id}static get ENTITY_NAME(){return"GroupUserTransfer"}}const Mn=xn;class Ln extends Ct{constructor(e){if(super(se.validate(Ln.ENTITY_NAME,e,Ln.getSchema())),this._props.forEach((e=>{this.push(e)})),!this.length)throw new te("The group user transfer collection cannot be empty.");this._props=null}static getSchema(){return{type:"array",items:Mn.getSchema()}}static get ENTITY_NAME(){return"GroupUserTransfers"}push(e){if(!e||"object"!=typeof e)throw new TypeError("GroupUserTransfersCollection push parameter should be an object.");e instanceof Mn&&(e=e.toDto()),e=new Mn(e),super.push(e)}}const Dn=Ln;class Fn extends X{constructor(e){super(se.validate(Fn.ENTITY_NAME,e,Fn.getSchema()))}static getSchema(){return{type:"object",required:["id","aco_foreign_key"],properties:{id:{type:"string",format:"uuid"},aco_foreign_key:{type:"string",format:"uuid"}}}}get id(){return this._props.id}get acoForeignKey(){return this._props.aco_foreign_key}static get ENTITY_NAME(){return"PermissionTransfer"}}const qn=Fn;class Kn extends Ct{constructor(e){if(super(se.validate(Kn.ENTITY_NAME,e,Kn.getSchema())),this._props.forEach((e=>{this.push(e)})),!this.length)throw new te("The permission transfer collection cannot be empty.");this._props=null}static getSchema(){return{type:"array",items:qn.getSchema()}}static get ENTITY_NAME(){return"PermissionTransfers"}push(e){if(!e||"object"!=typeof e)throw new TypeError("PermissionTransfersCollection push parameter should be an object.");e instanceof qn&&(e=e.toDto()),e=new qn(e),super.push(e)}}const $n=Kn;class jn extends X{constructor(e){super(jn.validate(e)),this._props.owners&&(this._owners=new $n(this._props.owners),delete this._props.owners),this._props.managers&&(this._managers=new Dn(this._props.managers),delete this._props.managers)}static validate(e){const t={};if(!e||!e.owners&&!e.managers)throw new te("The user delete transfer data cannot be empty.");return e.owners&&Array.isArray(e.owners)&&(t.owners=e.owners),e.managers&&Array.isArray(e.managers)&&(t.managers=e.managers),t}static getSchema(){return{type:"object",properties:{owners:$n.getSchema(),managers:Dn.getSchema()}}}toDto(){const e={};return this.owners&&(e.owners=this.owners.toDto()),this.managers&&(e.managers=this.managers.toDto()),e}get owners(){return this._owners||null}get managers(){return this._managers||null}static get ENTITY_NAME(){return"UserDeleteTransfer"}}const Bn=jn;const Gn=class{constructor(e){this.userService=new Re(e)}async updateLocalStorage(){const e=await this.findAll({profile:!0,gpgkey:!1,groups_users:!1,last_logged_in:!0,pending_account_recovery_request:!0,account_recovery_user_setting:!0},null,null,!0);return await es.set(e),e}async resendInvite(e){return this.userService.resendInvite(e)}async getOrFindAll(){const e=await es.get();return void 0!==e?new Qr(e):this.updateLocalStorage()}async findOne(e,t,r){let s=await this.userService.get(e,t);return r&&(s=sr.sanitizeDto(s)),new sr(s)}async findAll(e,t,r,s){let i=await this.userService.findAll(e,t,r);return s&&(i=Qr.sanitizeDto(i)),new Qr(i)}async findAllIdsForResourceUpdate(e){if(!J().isUUID(e))throw new TypeError("Error in find all users for users updates. The user id is not a valid uuid.");const t=await this.userService.findAll(null,{"has-access":e});return new Qr(t).ids}async create(e){const t=e.toDto({profile:{avatar:!1}}),r=await this.userService.create(t),s=new sr(r);return await es.addUser(s),s}async update(e,t){const r=e.toDto({profile:{avatar:!1}});let s=await this.userService.update(e.id,r);t&&(s=sr.sanitizeDto(s));const i=new sr(s);return await es.updateUser(i),i}async updateAvatar(e,t,r){let s=await this.userService.updateAvatar(e,t.file,t.filename);return r&&(s=sr.sanitizeDto(s)),new sr(s)}async deleteDryRun(e,t){try{const r=t&&t instanceof Bn?t.toDto():{};await this.userService.delete(e,r,!0)}catch(e){if(e instanceof Se&&400===e.data.code&&e.data.body.errors)throw new Un(e.message,e.data.body.errors);throw e}}async delete(e,t){try{const r=t&&t instanceof Bn?t.toDto():{};await this.userService.delete(e,r)}catch(e){if(e instanceof Se&&400===e.data.code&&e.data.body.errors)throw new Un(e.message,e.data.body.errors);throw e}await es.delete(e)}async requestHelpCredentialsLost(e){const t={username:e.username,case:"lost-passphrase"};await this.userService.requestHelpCredentialsLost(t)}};const Yn=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.userModel=new Gn(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.userModel.requestHelpCredentialsLost(this.account)}};class zn extends Error{constructor(e){super(e),this.name="OutdatedSsoKitError"}}const Vn=zn;const Hn=class{static async decrypt(e,t,r,s,i){(e=>{if(!J().isBase64(e))throw new Error("The given parameter is not a valid base64 string")})(e),bi(t),Ai(r),Ti(s),Ti(i);const o=qo.lW.from(e,"base64"),n={name:r.algorithm.name,iv:i},a={name:t.algorithm.name,iv:s};let c=null;try{c=await crypto.subtle.decrypt(n,r,o)}catch(e){throw console.error(e),new Vn(`Unable to decrypt passphrase from the server SSO kit: ${e.message}`)}let u=null;try{u=await crypto.subtle.decrypt(a,t,c)}catch(e){throw console.error(e),new Error(`Unable to decrypt passphrase with the local SSO kit: ${e.message}`)}return qo.lW.from(u).toString()}};class Wn extends Te{constructor(e){super(e,Wn.RESOURCE_NAME)}static get RESOURCE_NAME(){return"/sso/azure/login"}async getLoginUrl(e){return(await this.apiClient.create(e)).body}}const Jn=Wn;const Qn=class{constructor(e){this.ssoAzureLoginService=new Jn(e)}async getLoginUrl(e){Ei(e,"The user id should be a valid uuid.");const t=await this.ssoAzureLoginService.getLoginUrl({user_id:e});return new _o(t)}};const Zn=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.ssoKitServerPartModel=new jo(r),this.ssoAzureLoginModel=new Qn(r),this.azurePopupHandler=new mo(s.domain,e?.tab?.id,!1),this.authModel=new Lo(r)}async _exec(e=!1){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){try{const t=await Wo.get();if(!t)throw new Error("The Single Sign-On cannot proceed as there is no SSO kit registered on this browser profile.");const r=this.account.userId,s=await this.ssoAzureLoginModel.getLoginUrl(r),i=await this.azurePopupHandler.getSsoTokenFromThirdParty(s),o=await this.ssoKitServerPartModel.getSsoKit(t.id,r,i),n=await crypto.subtle.importKey("jwk",o.key,"AES-GCM",!0,["encrypt","decrypt"]),a=await Hn.decrypt(t.secret,t.nek,n,t.iv1,t.iv2);await this.azurePopupHandler.closeHandler(),await this.authModel.login(a,!0),e&&await this.ensureRedirectionInQuickaccessMode()}catch(e){throw console.error("An error occured while handle Azure sign in:",e),this.handleSpecificErrors(e),e}}async ensureRedirectionInQuickaccessMode(){await Oi.openInDetachedMode([{name:"uiMode",value:"detached"},{name:"feature",value:"login"}])}handleSpecificErrors(e){switch(e.name){case"InvalidMasterPasswordError":case"PassboltApiFetchError":case"OutdatedSsoKitError":Wo.flush()}}};const Xn=class{constructor(e){this.organisationSettingsModel=new st(e),this.ssoSettingsModel=new Ro(e),this.ssoKitServerPartModel=new jo(e)}async forceUpdateSsoKit(e){const t=(await Wo.get())?.id;if(await Wo.flush(),t)try{await this.ssoKitServerPartModel.deleteSsoKit(t)}catch(e){if(!(e instanceof Se&&404===e.data.code))throw e}await this.updateSsoKitIfNeeded(e)}async updateSsoKitIfNeeded(e){const t=await Wo.get();if(!(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("sso"))return void(t&&await Wo.flush());const r=await this.ssoSettingsModel.getCurrent();!r?.provider&&t?await Wo.flush():r?.provider&&!t&&await Xo.generate(e,r.provider)}};const ea=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.authModel=new Lo(r),this.organizationSettingsModel=new st(r),this.ssoKitServerPartModel=new jo(r),this.updateSsoCredentialsService=new Xn(r),this.checkPassphraseService=new kn(new ge)}async _exec(e,t,r=!1){try{await this.exec(e,t,r),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t,r){if(void 0===e)throw new Error("A passphrase is required.");if("string"!=typeof e)throw new Error("The passphrase should be a string.");if(void 0!==t&&"boolean"!=typeof t)throw new Error("The rememberMe should be a boolean.");await this.checkPassphraseService.checkPassphrase(e);try{await this.updateSsoCredentialsService.updateSsoKitIfNeeded(e)}catch(e){console.error(e)}try{await this.authModel.login(e,t)}catch(e){if(!(e instanceof ot))throw e}r&&await this.redirectToApp()}async redirectToApp(){const e=this.account.domain;u.tabs.update(this.worker.tab.id,{url:e})}};const ta=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;try{e=await Wo.get()}catch(e){return console.error(e),null}return e?e.provider:null}},ra={listen:function(e,t){e.port.on("passbolt.auth.is-authenticated",(async(t,r)=>{new Cn(e,t).main(r)})),e.port.on("passbolt.auth.is-mfa-required",(async t=>{new On(e,t).main()})),e.port.on("passbolt.auth.check-status",(async t=>{new Rn(e,t).main()})),e.port.on("passbolt.auth.logout",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Lo(r);try{await s.logout(),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR")}})),e.port.on("passbolt.auth.navigate-to-logout",(async()=>{const t=Ye.getInstance(),r=await t.getApiClientOptions(),s=new Lo(r),i=`${t.settings.getDomain()}/auth/logout`;try{await chrome.tabs.update(e.tab.id,{url:i}),await s.postLogout()}catch(e){console.error(e)}})),e.port.on("passbolt.auth.verify-server-key",(async t=>{const r=Ye.getInstance(),s=await r.getApiClientOptions({requireCsrfToken:!1}),i=r.settings.getDomain(),o=new In(e,t,s,i);await o._exec()})),e.port.on("passbolt.auth.get-server-key",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new Lo(r),i=await s.getServerKey();e.port.emit(t,"SUCCESS",i)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.auth.replace-server-key",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Lo(r),i=new ge,o=Y("user.settings.trustedDomain");try{const r=await s.getServerKey();await i.importServerPublicKey(r.armored_key,o),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.auth.verify-passphrase",(async(t,r)=>{const s=new Nn(e,t);await s._exec(r)})),e.port.on("passbolt.auth.login",(async(r,s,i)=>{const o=await Ye.getInstance().getApiClientOptions(),n=new ea(e,r,o,t);await n._exec(s,i)})),e.port.on("passbolt.auth.post-login-redirect",(t=>{let r=Y("user.settings.trustedDomain");const s=new URL(e.tab.url).searchParams.get("redirect");/^\/[A-Za-z0-9\-\/]*$/.test(s)&&(r=`${r}${s}`),chrome.tabs.update(e.tab.id,{url:r}),e.port.emit(t,"SUCCESS")})),e.port.on("passbolt.auth.request-help-credentials-lost",(async r=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Yn(e,r,s,t);await i._exec()})),e.port.on("passbolt.sso.sign-in-with-azure",(async(r,s)=>{const i=await Ye.getInstance().getApiClientOptions(),o=new Zn(e,r,i,t);await o._exec(s)})),e.port.on("passbolt.sso.get-local-configured-provider",(async t=>{const r=new ta(e,t);await r._exec()}))}},sa=[Ar.ENTITY_NAME];class ia extends X{constructor(e){super(se.validate(ia.ENTITY_NAME,e,ia.getSchema())),this._props.creator&&(this._creator=new sr(this._props.creator),delete this._props.creator),this._props.modifier&&(this._modifier=new sr(this._props.modifier),delete this._props.modifier)}static getSchema(){return{type:"object",required:["user_id","foreign_key","foreign_model","content"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},foreign_key:{type:"string",format:"uuid"},foreign_model:{type:"string",enum:ia.ALLOWED_FOREIGN_MODELS},parent_id:{anyOf:[{type:"string",format:"uuid"},{type:"null"}]},content:{type:"string",minLength:1,maxLength:ia.COMMENT_CONTENT_MAX_LENGTH},created:{type:"string",format:"date-time"},created_by:{type:"string",format:"uuid"},modified:{type:"string",format:"date-time"},modified_by:{type:"string",format:"uuid"},creator:sr.getSchema(),modifier:sr.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.creator&&e.creator&&(t.creator=this.creator.toDto(sr.ALL_CONTAIN_OPTIONS)),this.modifier&&e.modifier&&(t.modifier=this.modifier.toDto(sr.ALL_CONTAIN_OPTIONS)),t):t}toJSON(){return this.toDto(ia.ALL_CONTAIN_OPTIONS)}get id(){return this._props.id||null}get foreignKey(){return this._props.foreign_key}get foreignModel(){return this._props.foreign_model}get userId(){return this._props.user_id}get content(){return this._props.content}get parentId(){return this._props.parent_id||null}get created(){return this._props.created||null}get modified(){return this._props.modified||null}get createdBy(){return this._props.created_by||null}get modifiedBy(){return this._props.modified_by||null}get creator(){return this._creator||null}get modifier(){return this._modifier||null}static get ENTITY_NAME(){return"Comment"}static get COMMENT_CONTENT_MIN_LENGTH(){return 1}static get COMMENT_CONTENT_MAX_LENGTH(){return 255}static get ALLOWED_FOREIGN_MODELS(){return sa}static get ALL_CONTAIN_OPTIONS(){return{creator:sr.ALL_CONTAIN_OPTIONS,modifier:sr.ALL_CONTAIN_OPTIONS}}}const oa=ia;class na extends Ct{constructor(e){super(se.validate(na.ENTITY_NAME,e,na.getSchema())),this._props.forEach((e=>{this.push(new oa(e))})),this._props=null}static getSchema(){return{type:"array",items:oa.getSchema()}}get comments(){return this._items}get ids(){return this._items.map((e=>e.id))}get userIds(){return this._items.map((e=>e.userId))}get foreignKey(){return this._items.map((e=>e.foreignKey))}assertUniqueId(e){if(!e.id)return;const t=this.comments.length;let r=0;for(;r<t;r++){const t=this.comments[r];if(t.id&&t.id===e.id)throw new jt(r,na.RULE_UNIQUE_ID,`Comment id ${e.id} already exists.`)}}assertSameForeignEntity(e){if(!this.comments.length)return;if(!(e.foreignKey===this.comments[0].foreignKey&&e.foreignModel===this.comments[0].foreignModel)){const e=`The collection is already used for another model with id ${this.comments[0].resourceId} (${this.comments[0].foreignKey}).`;throw new jt(0,na.RULE_SAME_FOREIGN_MODEL,e)}}push(e){if(!e||"object"!=typeof e)throw new TypeError("CommentsCollection push parameter should be an object.");e instanceof oa&&(e=e.toDto(oa.ALL_CONTAIN_OPTIONS));const t=new oa(e);this.assertUniqueId(t),this.assertSameForeignEntity(t),super.push(t)}remove(e){const t=this.items.findIndex((t=>t.id===e));this.items.splice(t,1)}static get ENTITY_NAME(){return"Comments"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_SAME_FOREIGN_MODEL(){return"same_foreign_model"}}const aa=na;class ca extends Te{constructor(e){super(e,ca.RESOURCE_NAME)}static get RESOURCE_NAME(){return"comments"}static getSupportedContainOptions(){return["creator","modifier"]}async findAll(e,t,r){this.assertValidId(t),this.assertValidForeignModel(e),r=r?this.formatContainOptions(r,ca.getSupportedContainOptions()):null;const s={...r},i=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e.toLowerCase()}/${t}`,s||{}),o=await this.apiClient.fetchAndHandleResponse("GET",i);return o.body&&o.body.length?o.body:[]}async create(e){if(!e||!e.foreign_key||!e.foreign_model)throw new TypeError("Comment creation failed, invalid comment data.");const t=e.foreign_model;this.assertValidForeignModel(t);const r=e.foreign_key;this.assertValidId(r);const s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${t.toLowerCase()}/${r}`,{}),i={content:e.content};e.parent_id&&(i.parent_id=e.parent_id);const o=this.apiClient.buildBody(i);return(await this.apiClient.fetchAndHandleResponse("POST",s,o)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}assertValidForeignModel(e){if(!e||"string"!=typeof e)throw new TypeError("Comment foreign model should be a valid string.");if(!oa.ALLOWED_FOREIGN_MODELS.includes(e))throw new TypeError(`Comment foreign model ${e} in not in the list of supported models.`)}}const ua=ca;const pa=class{constructor(e){this.commentService=new ua(e)}async findAllByResourceId(e){const t=await this.commentService.findAll("Resource",e,{creator:!0,modifier:!1});return new aa(t)}async create(e){const t=await this.commentService.create(e.toDto({creator:!1,modifier:!1}));return new oa(t)}async delete(e){await this.commentService.delete(e)}};const la=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.commentModel=new pa(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return this.commentModel.create(new oa(e))}};const da=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.commentModel=new pa(r)}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!e)throw new Error("A comment id is required.");if("string"!=typeof e)throw new Error("The comment id should be a valid string.");if(!J().isUUID(e))throw new Error("The comment id should be a valid uuid.");await this.commentModel.delete(e)}};const ha=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.commentModel=new pa(r)}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!e)throw new TypeError("A resource id is required.");if("string"!=typeof e)throw new TypeError("The resource id should be a string.");if(!J().isUUID(e))throw new TypeError("The resource id should be a valid uuid.");return this.commentModel.findAllByResourceId(e)}},ga={listen:function(e){e.port.on("passbolt.comments.find-all-by-resource",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new ha(e,t,s);await i._exec(r)})),e.port.on("passbolt.comments.create",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new la(e,t,s);await i._exec(r)})),e.port.on("passbolt.comments.delete",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new da(e,t,s);await i._exec(r)}))}};const ya=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return chrome.runtime.getManifest().version}},_a={listen:function(e){e.port.on("passbolt.config.read",((t,r)=>{e.port.emit(t,"SUCCESS",Y(r))})),e.port.on("passbolt.config.readAll",((t,r)=>{const s={};for(const e in r)s[r[e]]=Y(r[e]);e.port.emit(t,"SUCCESS",s)})),e.port.on("passbolt.addon.is-configured",(t=>{const r=Ye.getInstance();e.port.emit(t,"SUCCESS",r.isValid())})),e.port.on("passbolt.addon.check-domain",(t=>{const r=Y("user.settings.trustedDomain");void 0!==r&&""!=r||e.port.emit(t,"SUCCESS",!1);const s=e.tab.url.startsWith(r);e.port.emit(t,"SUCCESS",s)})),e.port.on("passbolt.addon.get-domain",(t=>{const r=Y("user.settings.trustedDomain");e.port.emit(t,"SUCCESS",r)})),e.port.on("passbolt.addon.get-version",(async t=>{const r=new ya(e,t);await r._exec()})),e.port.on("passbolt.addon.get-url",(t=>{e.port.emit(t,"SUCCESS",chrome.runtime.getURL(""))}))}};class ma extends Te{constructor(e){super(e,ma.RESOURCE_NAME)}static get RESOURCE_NAME(){return"folders"}static getSupportedContainOptions(){return["children_resources","children_folders","creator","modifier","permission","permissions","permissions.user.profile","permissions.group"]}static getSupportedFiltersOptions(){return["has-id","has-parent","search"]}async get(e,t){this.assertValidId(e);const r=t?this.formatContainOptions(t,ma.getSupportedContainOptions()):null;return(await this.apiClient.get(e,r)).body}async findAll(e,t){e=e?this.formatContainOptions(e,ma.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(e,ma.getSupportedFiltersOptions()):null;const r={...e,...t},s=await this.apiClient.findAll(r);return s.body&&s.body.length?s.body:[]}async create(e,t){this.assertNonEmptyData(e);const r=t?this.formatContainOptions(t,ma.getSupportedContainOptions()):null;return(await this.apiClient.create(e,r)).body}async update(e,t,r){this.assertValidId(e),this.assertNonEmptyData(t);const s=r?this.formatContainOptions(r,ma.getSupportedContainOptions()):null;return(await this.apiClient.update(e,t,s)).body}async delete(e,t){this.assertValidId(e);const r={};t&&(r.cascade="1");return(await this.apiClient.delete(e,null,r)).body}async findAllForShare(e){if(e.length>80){let t=[];const r=Math.ceil(e.length/80);for(let s=0;s<r;s++){const r=e.splice(0,80),s=await this.findAllForShare(r);t=[...t,...s]}return t}const t=this.apiClient.buildUrl(this.apiClient.baseUrl.toString());e.forEach((e=>{t.searchParams.append("filter[has-id][]",e)})),t.searchParams.append("contain[permission]","1"),t.searchParams.append("contain[permissions.user.profile]","1"),t.searchParams.append("contain[permissions.group]","1");return(await this.apiClient.fetchAndHandleResponse("GET",t)).body}}const wa=ma;class fa extends Te{constructor(e){super(e,fa.RESOURCE_NAME)}static get RESOURCE_NAME(){return"share"}async shareFolder(e,t){this.assertValidId(e),this.assertNonEmptyData(t);const r=`folder/${e}`;return(await this.apiClient.update(r,t)).body}}const Ea=fa;const Sa=class{constructor(e){this.folderService=new wa(e),this.moveService=new Ts(e),this.shareService=new Ea(e)}async updateLocalStorage(){const e=await this.findAll();return await Wr.set(e),e}async getById(e){const t=await Wr.getFolderById(e);return t?new Gr(t):null}async getAllByIds(e,t){const r=new zr([]),s=await Wr.get();if(s){const i=new zr(s);if(i.items.forEach((t=>{e.includes(t.id)&&r.push(t)})),t)for(const t in e){const s=e[t],o=zr.getAllChildren(s,i,r);r.merge(o)}}return r}async getAllChildren(e){const t=await Wr.get(),r=new zr(t),s=new zr([]);for(const t in e){const i=e[t],o=zr.getAllChildren(i,r,s);s.merge(o)}return s}async findAll(){const e=await this.folderService.findAll({permission:!0});return new zr(e)}async findAllForShare(e){const t=await this.folderService.findAllForShare(e);return new zr(t)}async findForShare(e){const t=await this.folderService.findAllForShare([e]);if(!t.length)throw new Error(`Folder ${e} not found`);return new Gr(t[0])}async findFolderPermissions(e){const t=await this.folderService.get(e,{"permissions.user.profile":!0,"permissions.group":!0});return new Gr(t).permissions}calculatePermissionsChangesForMove(e,t,r){let s=new ur([],!1);if(t){if(!e.permissions||!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires permissions to be set.");s=ur.diff(e.permissions,t.permissions,!1)}let i=new ur([],!1);if(r){if(!r.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");i=r.permissions.cloneForAco(ar.ACO_FOLDER,e.id,!1)}const o=ur.sum(s,i,!1);return r||o.addOrReplace(new ar({aco:ar.ACO_FOLDER,aco_foreign_key:e.id,aro:e.permission.aro,aro_foreign_key:e.permission.aroForeignKey,type:ar.PERMISSION_OWNER})),o.assertAtLeastOneOwner(),bs.calculateChanges(e.permissions,o)}async calculatePermissionsChangesForCreate(e,t){let r=null;if(e.folderParentId){if(!t.permissions)throw new TypeError("Resource model calculatePermissionsChangesForMove requires destination permissions to be set.");const s=new ur([e.permission]),i=t.permissions.cloneForAco(ar.ACO_FOLDER,e.id);r=bs.calculateChanges(s,i)}return r}async create(e){const t=await this.folderService.create(e.toDto(),{permission:!0}),r=new Gr(t);return await Wr.addFolder(r),r}async move(e,t){const r=await Wr.getFolderById(e),s=new Gr(r);return s.folderParentId=t,await this.moveService.move(s),await Wr.updateFolder(s),s}async update(e){const t=await this.folderService.update(e.id,e.toDto(),{permission:!0}),r=new Gr(t);return await Wr.updateFolder(r),r}async share(e,t,r){return await this.shareService.shareFolder(e.id,{permissions:t.toDto()}),(void 0===r||r)&&await this.updateLocalStorage(),e}async delete(e,t){await this.folderService.delete(e,t),await Wr.delete(e),t&&await this.updateLocalStorage()}async bulkCreate(e,t){let r=[];const s=ks(e.folders,5);for(const e in s){const i=s[e].map((async(r,s)=>{const i=5*e+s;return this._bulkCreate_createFolder(r,i,t)})),o=(await Promise.allSettled(i)).map((e=>e.value));r=[...r,...o]}const i=r.filter((e=>e instanceof Gr));return await Wr.addFolders(i),r}async _bulkCreate_createFolder(e,t,r){const s=(r=r||{}).successCallback||(()=>{}),i=r.errorCallback||(()=>{});try{const r=await this.folderService.create(e.toDto(),{permission:!0}),i=new Gr(r);return s(i,t),i}catch(e){throw console.error(e),i(e,t),e}}async assertFolderExists(e){if(null===e)return;if(!J().isUUID(e))throw new TypeError("Folder exists check expect a uuid.");if(!await Wr.getFolderById(e))throw new Error(`Folder with id ${e} does not exist.`)}async assertFoldersExist(e){if(!Array.isArray(e))throw new TypeError("Folders exist check expect an array of uuid.");for(const t in e)await this.assertFolderExists(e[t])}};class va extends X{constructor(e){const t=Object.assign(va.getDefault(),e);"string"==typeof t.folder_parent_path&&(t.folder_parent_path=va.sanitizePath(t.folder_parent_path)),super(se.validate(va.ENTITY_NAME,t,va.getSchema()))}static getDefault(){return{folder_parent_path:""}}static getSchema(){const e=Gr.getSchema();return{type:"object",required:["name"],properties:{id:e.properties.id,name:e.properties.name,folder_parent_id:e.properties.folder_parent_id,folder_parent_path:{type:"string"}}}}static createFromPath(e){e=va.sanitizePath(e);const t=va.splitFolderPath(e),r={name:t.pop(),folder_parent_path:t.join("/")};return new va(r)}static sanitizePath(e){return(e=e||"").replace(/^(\/{2,})|(\/{2,})$/g,"/").replace(/^(\/(?! ))|((?<! )\/)$/g,"").replace(/(?<! )(\/{2,})(?! )/g,"/")}static splitFolderPath(e){return e.split(/(?<! )\/(?! )/g)}static escapeName(e){return(e=e||"").trim().replace(/^\//,"/ ").replace(/\/$/," /").replace(/(.)\/(.)/g,"$1 / $2")}static resolveEscapedName(e){return(e=e||"").replace(/ \/ | \/|\/ /g,"/")}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get id(){return this._props.id||null}set id(e){this._props.id=e}get name(){return this._props.name}get folderParentId(){return this._props.folder_parent_id||null}set folderParentId(e){this._props.folder_parent_id=e}get folderParentPath(){return this._props.folder_parent_path||""}set folderParentPath(e){this._props.folder_parent_path=e}get path(){return this.folderParentPath?`${this.folderParentPath}/${this.name}`:this.name}get depth(){return this.folderParentPath?va.splitFolderPath(this.folderParentPath).length:0}changeRootPath(e){this.folderParentPath.length?this.folderParentPath=`${e.path}/${this.folderParentPath}`:this.folderParentPath=e.path}static get ENTITY_NAME(){return"ExternalFolder"}}const ba=va;class Aa extends Ct{constructor(e){super(se.validate(Aa.ENTITY_NAME,e,Aa.getSchema())),this._props.forEach((e=>{this.push(new ba(e))})),this._props=null}static constructFromFoldersCollection(e){if(!(e instanceof zr))throw new TypeError("ExternalFoldersCollection constructFromFoldersCollection parameter should be an instance of FoldersCollection.");const t=e.folders.map((t=>{const r=Aa.getEscapedFolderParentPath(e,t),s=r.length?t.folderParentId:null;return Object.assign(t.toDto(),{name:ba.escapeName(t.name),folder_parent_id:s,folder_parent_path:r})}));return new Aa(t)}static getSchema(){return{type:"array",items:ba.getSchema()}}static getEscapedFolderParentPath(e,t){return e.getAllParents(t).items.reverse().map((e=>ba.escapeName(e.name))).join("/")}static toFoldersCollection(e){const t=[];return e.forEach((e=>{const r=Object.assign(e.toDto(),{name:ba.resolveEscapedName(e.name)});t.push(r)})),new zr(t)}get externalFolders(){return this._items}get ids(){return this._items.map((e=>e.id))}hasPath(e){return e=ba.sanitizePath(e),this.externalFolders.some((t=>t.path===e))}getById(e){return this.externalFolders.find((t=>t.id===e))}getByDepth(e){return this.externalFolders.filter((t=>t.depth===e))}getByPath(e){return this.externalFolders.find((t=>t.path===e))}getByFolderParentId(e){return e?this.externalFolders.filter((t=>t.folderParentId===e)):[]}push(e){if(!e||"object"!=typeof e)throw new TypeError("ExternalFoldersCollection push parameter should be an object.");e instanceof ba&&(e=e.toDto());const t=new ba(e);return super.push(t)}pushFromPath(e){const t=[];if(!(e=ba.sanitizePath(e)).length)return;const r=ba.splitFolderPath(e);let s="";for(const e of r){if(s=s.length?`${s}/${e}`:e,this.hasPath(s))continue;const r=ba.createFromPath(s);t.push(r)}t.forEach((e=>this.push(e)))}setFolderParentIdsByPath(e,t){for(const r of this.externalFolders)r.folderParentPath===e&&(r.folderParentId=t)}changeRootPath(e){this.externalFolders.forEach((t=>t.changeRootPath(e)))}removeByPath(e){for(let t=this.externalFolders.length-1;t>=0;t--){const r=this.externalFolders[t],s=e.replace(/[.*+\-?^${}()|[\]\\\/]/g,"\\$&");new RegExp(`^${s}($|/)`).exec(r.path)&&this.externalFolders.splice(t,1)}}static get ENTITY_NAME(){return"ExternalFolders"}}const Ta=Aa;class Ia extends X{constructor(e){const t=Object.assign(Ia.getDefault(),e);"string"==typeof t.folder_parent_path&&(t.folder_parent_path=ba.sanitizePath(t.folder_parent_path)),super(se.validate(Ia.ENTITY_NAME,t,Ia.getSchema())),this._props.secrets&&(this._secrets=new vr(this._props.secrets),Ar.assertValidSecrets(this._secrets,this.id),delete this._props.secrets)}static getDefault(){return{name:Ia.DEFAULT_RESOURCE_NAME,secret_clear:"",folder_parent_path:""}}static getSchema(){const e=Ar.getSchema();return{type:"object",required:["name","secret_clear"],properties:{id:e.properties.id,name:e.properties.name,username:e.properties.username,uri:e.properties.uri,description:e.properties.description,secrets:e.properties.secrets,folder_parent_id:e.properties.folder_parent_id,resource_type_id:e.properties.resource_type_id,secret_clear:{type:"string"},folder_parent_path:{type:"string"}}}}toDto(){const e=Object.assign({},this._props);return this._secrets&&(e.secrets=this._secrets.toDto()),e}toJSON(){return this.toDto()}get id(){return this._props.id||null}set id(e){this._props.id=e}get name(){return this._props.name}get username(){return this._props.username}get uri(){return this._props.uri}get description(){return this._props.description}set description(e){this._props.description=e}get secretClear(){return this._props.secret_clear}set secretClear(e){this._props.secret_clear=e}get folderParentId(){return this._props.folder_parent_id||null}set folderParentId(e){this._props.folder_parent_id=e}get folderParentPath(){return this._props.folder_parent_path||""}get resourceTypeId(){return this._props.resource_type_id||null}get path(){return this.folderParentPath?`${this.folderParentPath}/${this.name}`:this.name}get depth(){return this.folderParentPath?ba.splitFolderPath(this.folderParentPath).length:0}set folderParentPath(e){this._props.folder_parent_path=e}changeRootPath(e){this.folderParentPath.length?this.folderParentPath=`${e.path}/${this.folderParentPath}`:this.folderParentPath=e.path}get secrets(){return this._secrets}set secrets(e){if(!(e instanceof vr))throw new te("ExternalResourceEntity secrets expect a ResourceSecretsCollection.");this._secrets=e}static get ENTITY_NAME(){return"ExternalResource"}static get DEFAULT_RESOURCE_NAME(){return"(no name)"}}const Ra=Ia;const Ca=class{static get mapping(){throw new Error("mapping should be overridden by the inherited csv row parser.")}static parse(e,t){throw new Error("parse should be overridden by the inherited csv row parser.")}static canParse(e){const t=t=>e.some((e=>this.mapping[t]===e));if(!["name","secret_clear"].reduce(((e,r)=>e&&t(r)),!0))return 0;return 2+["username","uri","description","folder_parent_path"].reduce(((e,r)=>t(r)?++e:e),0)}};const Oa=class extends Ca{static get mapping(){return{name:"Title",username:"Username",uri:"URL",secret_clear:"Password",description:"Notes",folder_parent_path:"Group"}}static parse(e,t){const r={},s=this.parseResourceType(e,t);s&&(r.resource_type_id=s.id);for(const t in this.mapping)e[this.mapping[t]]&&(r[t]=e[this.mapping[t]]);return new Ra(r)}static parseResourceType(e,t){if(t)return t.getFirst("slug","password-and-description")}};const ka=class{static get format(){throw new Error("format should be overridden by the inherited class.")}static get mapping(){throw new Error("mapping should be overridden by the inherited class.")}static compose(e){throw new Error("compose should be overridden by the inherited class.")}};const Na=class extends ka{static get format(){return"csv-kdbx"}static get mapping(){return Oa.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const Pa=class extends Ca{static get mapping(){return{name:"Title",username:"Username",uri:"Url",secret_clear:"Password",description:"Notes",folder_parent_path:"Type"}}static parse(e,t){const r={},s=this.parseResourceType(e,t);s&&(r.resource_type_id=s.id);for(const t in this.mapping)e[this.mapping[t]]&&(r[t]=e[this.mapping[t]]);return new Ra(r)}static parseResourceType(e,t){if(t)return t.getFirst("slug","password-and-description")}};const Ua=class extends ka{static get format(){return"csv-1password"}static get mapping(){return Pa.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};const xa=class extends Ca{static get mapping(){return{name:"name",username:"username",uri:"url",secret_clear:"password",description:"extra",folder_parent_path:"grouping"}}static parse(e,t){const r={},s=this.parseResourceType(e,t);s&&(r.resource_type_id=s.id);for(const t in this.mapping)e[this.mapping[t]]&&(r[t]=e[this.mapping[t]]);return new Ra(r)}static parseResourceType(e,t){if(t)return t.getFirst("slug","password-and-description")}};const Ma=class extends ka{static get format(){return"csv-lastpass"}static get mapping(){return xa.mapping}static compose(e){const t={},r=e.toDto();for(const e in this.mapping)t[this.mapping[e]]=r[e]||"";return t}};class La extends Error{constructor(e){super(e),this.name="FileFormatError"}}const Da=La;var Fa=r(7460),qa=r.n(Fa);const Ka=[Na,Ma,Ua];const $a=class{constructor(e){this.exportEntity=e}static get register(){return Ka}async export(){const e=this.getRowComposer();if(!e)throw new Da("This csv format is not supported.");const t=this.exportResources(e),r=Object.values(e.mapping);let s=`"${r.join('","')}"\r\n`;s+=qa().unparse(t,{header:!1,quotes:!0,columns:r}),this.exportEntity.file=s}getRowComposer(){return Ka.find((e=>e.format===this.exportEntity.format))||null}exportResources(e){const t=[];for(const r of this.exportEntity.exportResources){const s=e.compose(r);t.push(s)}return t}};var ja=r(4500);const Ba=class{constructor(e){this.exportEntity=e}async export(){const e=await this.createKdbxDb();this.exportEntity.exportFolders.getByDepth(0).forEach((t=>this.createKdbxGroup(e,t,e.getDefaultGroup())));this.exportEntity.exportResources.getByDepth(0).forEach((t=>this.createKdbxEntry(e,t,e.getDefaultGroup()))),this.exportEntity.file=await e.save()}async createKdbxDb(){const e=this.createKdbxCredentials(),t=ja.Kdbx.create(e,"passbolt export");return t.setVersion(3),t}createKdbxCredentials(){let e=null,t=null;return this.exportEntity.password&&(e=ja.ProtectedValue.fromString(this.exportEntity.password)),this.exportEntity.keyfile&&(t=ja.ByteUtils.base64ToBytes(this.exportEntity.keyfile)),new ja.Credentials(e,t)}createKdbxGroup(e,t,r){const s=e.createGroup(r,ba.resolveEscapedName(t.name));this.exportEntity.exportFolders.getByFolderParentId(t.id).forEach((t=>this.createKdbxGroup(e,t,s)));this.exportEntity.exportResources.getByFolderParentId(t.id).forEach((t=>this.createKdbxEntry(e,t,s)))}createKdbxEntry(e,t,r){const s=e.createEntry(r);s.fields.set("Title",t.name),s.fields.set("UserName",t.username),t.secretClear&&s.fields.set("Password",ja.ProtectedValue.fromString(t.secretClear)),s.fields.set("URL",t.uri),s.fields.set("Notes",t.description)}};class Ga extends Error{constructor(e){super(e),this.name="FileTypeError"}}const Ya=Ga;const za=class{export(e){return this.getExporter(e).export()}getExporter(e){switch(e.fileType){case"csv":return new $a(e);case"kdbx":return new Ba(e);default:throw new Ya(`The format ${e.format} is not supported.`)}}};class Va extends Ct{constructor(e){super(se.validate(Va.ENTITY_NAME,e,Va.getSchema())),this._props.forEach((e=>{this.push(new Ra(e))})),this._props=null}static getSchema(){return{type:"array",items:Ra.getSchema()}}get externalResources(){return this._items}get ids(){return this._items.map((e=>e.id))}static constructFromResourcesCollection(e,t){if(!(e instanceof Pr))throw new TypeError("ExternalResourcesCollection constructFromResourcesCollection parameter 1 should be an instance of ResourcesCollection.");if(!(t instanceof Ta))throw new TypeError("ExternalResourcesCollection constructFromResourcesCollection parameter 2 should be an instance of ExternalFoldersCollection.");const r=e.resources.map((e=>{const r=t.getById(e.folderParentId),s=r?r.id:null,i=r?r.path:"";return Object.assign(e.toDto({secrets:!0}),{folder_parent_id:s,folder_parent_path:i})}));return new Va(r)}getByDepth(e){return this.externalResources.filter((t=>t.depth===e))}getByFolderParentId(e){return e?this.externalResources.filter((t=>t.folderParentId===e)):[]}push(e){if(!e||"object"!=typeof e)throw new TypeError("ExternalResourcesCollection push parameter should be an object.");e instanceof Ra&&(e=e.toDto());const t=new Ra(e);return super.push(t)}setFolderParentIdsByPath(e,t){for(const r of this.externalResources)r.folderParentPath===e&&(r.folderParentId=t)}changeRootPath(e){this.externalResources.forEach((t=>t.changeRootPath(e)))}removeByPath(e){for(let t=this.externalResources.length-1;t>=0;t--){const r=this.externalResources[t],s=e.replace(/[.*+\-?^${}()|[\]\\\/]/g,"\\$&");new RegExp(`^${s}/`).exec(r.path)&&this.externalResources.splice(t,1)}}static get ENTITY_NAME(){return"ExternalResources"}}const Ha=Va;class Wa extends X{constructor(e){super(se.validate(Wa.ENTITY_NAME,e,Wa.getSchema())),this._props.export_resources&&(this._export_resources=new Ha(this._props.export_resources),delete this._props.export_resources),this._props.export_folders&&(this._export_folders=new Ta(this._props.export_folders),delete this._props.export_folders)}static getSchema(){return{type:"object",required:["format"],properties:{format:{type:"string",enum:Wa.SUPPORTED_FORMAT},resources_ids:{anyOf:[{type:"array"},{type:"null"}]},folders_ids:{anyOf:[{type:"array"},{type:"null"}]},export_resources:Ha.getSchema(),export_folders:Ta.getSchema(),options:{type:"object",required:[],properties:{credentials:{type:"object",required:[],properties:{password:{anyOf:[{type:"string"},{type:"null"}]},keyfile:{anyOf:[{type:"string",format:"x-base64"},{type:"null"}]}}}}}}}}get format(){return this._props.format}get foldersIds(){return this._props.folders_ids||null}get resourcesIds(){return this._props.resources_ids||null}get options(){return this._props.options||{}}get credentials(){return this.options.credentials||{}}get password(){return this.credentials.password}get keyfile(){return this.credentials.keyfile}get fileType(){return this.format.split("-")[0]}get exportResources(){return this._export_resources}set exportResources(e){if(!(e instanceof Ha))throw new TypeError("exportResources must be a valid ImportResourcesCollection instance");this._export_resources=e}get exportFolders(){return this._export_folders||new Ta([])}set exportFolders(e){if(!(e instanceof Ta))throw new TypeError("exportFolders must be a valid ExternalFoldersCollection instance");this._export_folders=e}static get ENTITY_NAME(){return"ExportResourcesFileEntity"}static get SUPPORTED_FORMAT(){return[Wa.FORMAT_KDBX,Wa.FORMAT_CSV_KDBX,Wa.FORMAT_CSV_LASTPASS,Wa.FORMAT_CSV_1PASSWORD]}static get FORMAT_KDBX(){return"kdbx"}static get FORMAT_CSV_KDBX(){return"csv-kdbx"}static get FORMAT_CSV_LASTPASS(){return"csv-lastpass"}static get FORMAT_CSV_1PASSWORD(){return"csv-1password"}}const Ja=Wa;const Qa=class{constructor(e,t){this.worker=e,this.resourceTypeModel=new fs(t),this.resourceModel=new Ns(t),this.folderModel=new Sa(t),this.progressService=new ji(this.worker,w.t("Exporting ..."))}async exec(e){const t=Ye.getInstance().get().id;try{this.progressService.start(100,w.t("Generate file"));const r=new Ja(e);await this.prepareExportContent(r);const s=await this.getPrivateKey();return await this.decryptSecrets(r,t,s),await this.export(r),await this.download(r),await this.progressService.finishStep(w.t("Done"),!0),await this.progressService.close(),r}catch(e){throw await this.progressService.close(),e}}async prepareExportContent(e){const t=e.resourcesIds.length+2;this.progressService.updateGoals(t),await this.progressService.finishStep(w.t("Initialize"),!0);const r=await this.folderModel.getAllByIds(e.foldersIds),s=Ta.constructFromFoldersCollection(r),i=await this.resourceModel.findAllForDecrypt(e.resourcesIds),o=Ha.constructFromResourcesCollection(i,s);e.exportFolders=s,e.exportResources=o}async getPrivateKey(){const e=await Li.get(this.worker);return Mo.getKey(e)}async decryptSecrets(e,t,r){let s=0;const i=await this.resourceTypeModel.getOrFindAll();for(const t of e.exportResources.items){s++,await this.progressService.finishStep(w.t("Decrypting {{counter}}/{{total}}",{counter:s,total:e.exportResources.items.length}));const o=await U(t.secrets.items[0].data);let n=await _e.decrypt(o,r);if(!t.resourceTypeId){t.secretClear=n;continue}const a=i.getFirst("id",t.resourceTypeId);a&&"password-and-description"===a.slug?(n=await this.resourceModel.deserializePlaintext(t.resourceTypeId,n),t.description=n.description,t.secretClear=n.password):t.secretClear=n}}async export(e){const t=new za;await t.export(e)}getMimeType(e){let t="text/plain";switch(e){case"kdbx":t="application/x-keepass";break;case"csv":t="text/csv"}return t}async download(e){const t=`passbolt-export-${(new Date).toISOString().slice(0,10)}.${e.fileType}`,r=this.getMimeType(e.fileType),s=new Blob([e.file],{type:r});await ho.saveFile(t,s,r,this.worker.tab.id)}},Za={listen:async function(e){e.port.on("passbolt.export-resources.export-to-file",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Qa(e,s);try{await i.exec(r),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};class Xa extends Te{constructor(e){super(e,Xa.RESOURCE_NAME)}static get RESOURCE_NAME(){return"favorites"}async create(e,t){this.assertValidForeignModel(e),this.assertValidId(t);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e.toLowerCase()}/${t}`,{});return(await this.apiClient.fetchAndHandleResponse("POST",r)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}assertValidForeignModel(e){if(!e||"string"!=typeof e)throw new TypeError("Favorite foreign model should be a valid string.");if(!dr.ALLOWED_FOREIGN_MODELS.includes(e))throw new TypeError(`Favorite foreign model ${e} in not in the list of supported models.`)}}const ec=Xa;const tc=class{constructor(e){this.favoriteService=new ec(e),this.resourceModel=new Ns(e)}async addResourceToFavorite(e){const t=await this.favoriteService.create("Resource",e),r=new dr(t);return await this.resourceModel.updateFavoriteLocally(e,r),r}async removeResourceFromFavorite(e){const t=await this.resourceModel.getById(e);t.favorite&&(await this.favoriteService.delete(t.favorite.id),await this.resourceModel.updateFavoriteLocally(e,null))}},rc={listen:function(e){e.port.on("passbolt.favorite.add",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new tc(s),o=await i.addResourceToFavorite(r);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.favorite.delete",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new tc(s);await i.removeResourceFromFavorite(r),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const sc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.folderModel=new Sa(r),this.progressService=new ji(this.worker,w.t("Creating folder..."))}async main(e){const t=e.folderParentId?3:1;try{const r=`Creating folder ${e.name}`;this.progressService.start(t,r);const s=await this.folderModel.create(e);if(s.folderParentId){await this.progressService.finishStep(w.t("Fetching parent permissions"),!0);const e=await this.folderModel.findForShare(s.folderParentId);await this.progressService.finishStep(w.t("Saving permissions..."),!0);const t=await this.folderModel.calculatePermissionsChangesForCreate(s,e);t&&await this.folderModel.share(s,t)}return await this.progressService.finishStep(w.t("Done!"),!0),await this.progressService.close(),s}catch(e){throw console.error(e),await this.progressService.close(),e}}};class ic{}ic.searchAros=async function(e){const t=Ye.getInstance().settings.getDomain(),r={method:"GET",credentials:"include",headers:{Accept:"application/json","content-type":"application/json"}},s=new URL(`${t}/share/search-aros?api-version=2`);let i,o;s.searchParams.append("filter[search]",e);try{i=await fetch(s.toString(),r)}catch(e){throw new be(e.message)}try{o=await i.json()}catch(e){throw new fe}if(!i.ok){const e=o.header.message;throw new Se(e,{code:i.status,body:o.body})}return o.body},ic.searchResourceAros=async function(e,t){const r=Ye.getInstance().settings.getDomain(),s={method:"GET",credentials:"include",headers:{Accept:"application/json","content-type":"application/json"}},i=new URL(`${r}/share/search-users/resource/${e}?api-version=2`);let o,n;i.searchParams.append("filter[search]",t);try{o=await fetch(i.toString(),s)}catch(e){throw new be(e.message)}try{n=await o.json()}catch(e){throw new fe}if(!o.ok){const e=n.header.message;throw new Se(e,{code:o.status,body:n.body})}return n.body},ic.shareResource=async function(e,t){const r=Ye.getInstance(),s=r.settings.getDomain(),i={method:"PUT",credentials:"include",headers:{Accept:"application/json","content-type":"application/json"},body:JSON.stringify(t)};yt.setCsrfHeader(i,r);const o=new URL(`${s}/share/resource/${e}.json?api-version=v2`);let n,a;try{n=await fetch(o.toString(),i)}catch(e){throw new be(e.message)}try{a=await n.json()}catch(e){throw new fe}if(!n.ok){const e=a.header.message;throw new Se(e,{code:n.status,body:a.body})}return a.body},ic.simulateShareResource=async function(e,t){const r=Ye.getInstance(),s=r.settings.getDomain(),i=new URL(`${s}/share/simulate/resource/${e}.json?api-version=2`),o={permissions:t},n={method:"POST",credentials:"include",body:JSON.stringify(o),headers:{Accept:"application/json","content-type":"application/json"}};let a,c;yt.setCsrfHeader(n,r);try{a=await fetch(i.toString(),n)}catch(e){throw new be(e.message)}try{c=await a.json()}catch(e){throw new fe}if(!a.ok){const e=c.header.message;throw new Se(e,{code:a.status,body:c.body})}return c.body};const oc=ic;class nc{}nc.searchAros=async function(e){return oc.searchAros(e)},nc.searchResourceAros=function(e,t){return oc.searchResourceAros(e,t)},nc.bulkShareResources=async function(e,t,r,s){const i=ac(e,t),o=await cc(e,i,s),n=await uc(e,o,r,s);for(const t in i)if(Object.prototype.hasOwnProperty.call(i,t)){const r=e.find((e=>e.id===t)),o=i[t],a=n[t]||[];s(`Sharing password ${r.name}`),await oc.shareResource(t,{permissions:o,secrets:a})}},nc.bulkShareFolders=async function(e,t,r,s){for(const i of e){const e=t.filterByAcoForeignKey(i.id);e&&e.length&&(await s(`Updating folder ${i.name} permissions`),await r.share(i,e,!1))}await r.updateLocalStorage()};const ac=function(e,t){if(!e||!Array.isArray(e)||!e.length)throw new TypeError("bulkShareAggregateChanges expect an array of ACOs");if(!t||!Array.isArray(t)||!t.length)throw new TypeError("bulkShareAggregateChanges expect an array of changes");const r={};return e.forEach((e=>{const s=t.filter((t=>t.aco_foreign_key===e.id));s.length&&(r[e.id]=s)})),r},cc=async function(e,t,r){const s={};for(const i in t){r(`Validating share operation for ${e.find((e=>e.id===i)).name}`);const o=(await oc.simulateShareResource(i,t[i])).changes.added;o.length&&(s[i]=o.reduce(((e,t)=>[...e,t.User.id]),[]))}return s},uc=async function(e,t,r,s){const i=new ge,o={};for(const n in t){const a=e.find((e=>e.id===n)),c=await U(a.secrets[0].data),u=t[n];if(s(`Encrypting for ${a.name}`),u&&u.length){const e=await _e.decrypt(c,r),t=u.reduce(((t,r)=>[...t,{userId:r,message:e}]),[]),s=[];for(const e in t){const o=t[e],a=i.findPublic(o.userId).armoredKey,c=await M(a),u=await ye.encrypt(o.message,c,[r]);s.push({resource_id:n,user_id:o.userId,data:u})}o[n]=s}}return o},pc=nc;const lc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.folderModel=new Sa(r),this.resourceModel=new Ns(r),this.keyring=new ge,this.progressService=new ji(this.worker)}async main(e,t){await this.assertValidMoveParameters(e,t);try{await this.getPassphrase()}catch(e){throw this.cleanup(),e}try{this.progressService.title=this.getProgressTitle(),this.progressService.start(null,w.t("Initializing ...")),await this.findAllForShare(),this.filterOutResourcesThatWontMove(),this.progressService.updateGoals(this.getGoals()),await this.progressService.finishStep(w.t("Calculating changes ..."),!0),await this.calculateChanges(),await this.move(),await this.share(),await this.progressService.finishStep(w.t("Done"),!0),await this.progressService.close(),this.cleanup()}catch(e){throw await this.progressService.close(),this.cleanup(),e}}async assertValidMoveParameters(e,t){if(null!==t&&await this.folderModel.assertFolderExists(t),!e.length)throw new Error(w.t("Could not move, expecting at least a resource to be provided."));await this.resourceModel.assertResourcesExist(e),this.destinationFolderId=t,this.resourcesIds=e}async getPassphrase(){const e=await Li.get(this.worker);this.privateKey=await Mo.getKey(e)}async findAllForShare(){this.resources=await this.resourceModel.findAllForShare(this.resourcesIds);const e=[...new Set(this.resources.folderParentIds)];this.destinationFolderId?this.destinationFolder=await this.folderModel.findForShare([this.destinationFolderId]):this.destinationFolder=null,e.length&&(this.resourcesParentFolders=await this.folderModel.findAllForShare(e))}filterOutResourcesThatWontMove(){const e=[];for(const t of this.resources){let r=null;null!==t.folderParentId&&(r=this.resourcesParentFolders.getById(t.folderParentId)),Ar.canResourceMove(t,r,this.destinationFolder)||(console.warning(`Resource ${t.name} can not be moved, skipping.`),e.push(t.id))}this.resources.removeMany(e)}getGoals(){return 5*this.resources.length+1}async calculateChanges(){this.changes=new bs([]);for(const e of this.resources){if(await this.progressService.finishStep(w.t("Calculating changes for {{name}}",{name:e.name})),!e.permission.isOwner())break;if(e.isShared()&&(null===this.destinationFolderId||this.destinationFolder.isPersonal())&&(null===e.folderParentId||e.isPersonal()))break;const t=e.folderParentId?this.resourcesParentFolders.getById(e.folderParentId):null,r=this.resourceModel.calculatePermissionsChangesForMove(e,t,this.destinationFolder);this.changes.merge(r)}}async move(){const e=[];for(const t of this.resources)t.folderParentId!==this.destinationFolderId?(await this.progressService.finishStep(w.t("Moving {{name}}",{name:t.name})),await this.resourceModel.move(t,this.destinationFolderId)):(Le.write({level:"debug",message:`Resource ${t.name} is already in the folder, skipping.`}),e.push(t.id));this.resources.removeMany(e),this.resources.length>0&&await this.resourceModel.updateCollection(this.resources)}async share(){const e=this.resources.toDto({secrets:!0}),t=this.changes.toDto();t.length&&(await this.progressService.finishStep(w.t("Synchronizing keys"),!0),await this.keyring.sync(),await pc.bulkShareResources(e,t,this.privateKey,(async e=>{await this.progressService.finishStep(e)})),await this.resourceModel.updateLocalStorage())}cleanup(){this.privateKey=null}getProgressTitle(){return 1===this.resourcesIds.length?w.t("Moving one resource"):w.t("Moving {{total}} resources",{total:this.resourcesIds.length})}};const dc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.folderModel=new Sa(r),this.resourceModel=new Ns(r),this.keyring=new ge,this.folderId=null,this.folder=null,this.parentFolder=null,this.destinationFolderId=null,this.destinationFolder=null,this.subFolders=null,this.foldersChanges=new bs([]),this.resources=null,this.resourcesChanges=new bs([]),this.passphrase=null,this.privateKey=null,this.progressService=new ji(this.worker,w.t("Moving folder"))}async main(e,t){await this.assertValidParameters(e,t);try{await this.getPassphrase()}catch(e){throw this.cleanup(),e}try{await this.findAllForShare(),this.progressService.start(this.getGoals(),w.t("Initializing ...")),await this.progressService.finishStep(w.t("Calculating changes..."),!0),await this.calculateChanges(),await this.share(),await this.move(),await this.progressService.finishStep(w.t("Done"),!0),await this.progressService.close(),this.cleanup()}catch(e){throw await this.progressService.close(),this.cleanup(),e}}async assertValidParameters(e,t){if(null!==t&&await this.folderModel.assertFolderExists(t),!e)throw new Error(w.t("Could not move, expecting a folder to be provided."));if(await this.folderModel.assertFolderExists(e),e===t)throw new Error(w.t("The folder cannot be moved inside itself."));this.destinationFolderId=t,this.folderId=e}async getPassphrase(){const e=await Li.get(this.worker);this.privateKey=await Mo.getKey(e)}async findAllForShare(){this.folder=await this.folderModel.findForShare(this.folderId),this.destinationFolderId&&(this.destinationFolder=await this.folderModel.findForShare(this.destinationFolderId)),this.folder.folderParentId&&(this.parentFolder=await this.folderModel.findForShare(this.folder.folderParentId)),this.assertFolderCanBeMoved(),this.subFolders=await this.folderModel.getAllChildren([this.folder.id]),this.resources=await this.resourceModel.getAllByParentIds([this.folder.id,...this.subFolders.ids]),this.resources=this.resources.getAllWhereOwner(),this.subFolders=this.subFolders.getAllWhereOwner(),this.resources.length&&(this.resources=await this.resourceModel.findAllForShare(this.resources.ids)),this.subFolders.length&&(this.subFolders=await this.folderModel.findAllForShare(this.subFolders.ids))}assertFolderCanBeMoved(){if(this.folder.folderParentId===this.destinationFolderId){const e=w.t("Folder {{name}} is already in folder {{destination}}.",{name:this.folder.name,destination:this.destinationFolder.name});throw new Error(e)}if(!Gr.canFolderMove(this.folder,this.parentFolder,this.destinationFolder)){const e=w.t("Folder {{name}} can not be moved.",{name:this.folder.name});throw new Error(e)}}getGoals(){return 3+2*this.subFolders.length+4*this.resources.length}async calculateChanges(){if(await this.progressService.finishStep(w.t("Calculating changes for {{name}}",{name:this.folder.name})),!this.folder.isShared()||null!==this.destinationFolderId&&!this.destinationFolder.isPersonal()||null!==this.folder.folderParentId&&!this.parentFolder.isPersonal()){this.folder.permission.isOwner()&&this.foldersChanges.merge(this.folderModel.calculatePermissionsChangesForMove(this.folder,this.parentFolder,this.destinationFolder));for(const e of this.subFolders)e.permission.isOwner()&&this.foldersChanges.merge(this.folderModel.calculatePermissionsChangesForMove(e,this.parentFolder,this.destinationFolder));for(const e of this.resources)e.permission.isOwner()&&this.resourcesChanges.merge(this.resourceModel.calculatePermissionsChangesForMove(e,this.parentFolder,this.destinationFolder))}}async share(){if(this.foldersChanges.length||this.resourcesChanges.length){if("keep"===(await this.worker.port.request("passbolt.folders.move-strategy.request",this.destinationFolderId,[this.folderId],[])).moveOption)return}if(this.foldersChanges.length){const e=new zr([this.folder]);e.merge(this.subFolders),await pc.bulkShareFolders(e,this.foldersChanges,this.folderModel,(async e=>{await this.progressService.finishStep(e)}))}if(this.resourcesChanges.length){const e=this.resources.toDto({secrets:!0}),t=this.resourcesChanges.toDto();await this.progressService.finishStep(w.t("Synchronizing keys"),!0),await this.keyring.sync(),await pc.bulkShareResources(e,t,this.privateKey,(async e=>{await this.progressService.finishStep(e)})),await this.resourceModel.updateLocalStorage()}}async move(){await this.progressService.finishStep(w.t("Moving {{name}}",{name:this.folder.name})),await this.folderModel.move(this.folder.id,this.destinationFolderId)}cleanup(){this.privateKey=null}};const hc=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.clientOptions=r}async main(e){if(!e)throw new TypeError("Move controller parameters cannot be empty");const t=e.folderParentId?e.folderParentId:null,r=e.folders?e.folders:[],s=e.resources?e.resources:[];if(s.length&&r.length)throw new TypeError("Multi resource and folder move is not supported.");if(r.length>1)throw new TypeError("Multi folder move is not supported.");if(s.length){const e=new lc(this.worker,this.requestId,this.clientOptions);await e.main(s,t)}if(r.length){const e=new dc(this.worker,this.requestId,this.clientOptions);await e.main(r[0],t)}}},gc={listen:function(e){e.port.on("passbolt.folders.find-permissions",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Sa(s),o=await i.findFolderPermissions(r);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.folders.create",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new sc(e,t,s),o=await i.main(new Gr(r));e.port.emit(t,"SUCCESS",o)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.folders.update",(async(t,r)=>{try{const s=new Sa(await Ye.getInstance().getApiClientOptions()),i=await s.update(new Gr(r));e.port.emit(t,"SUCCESS",i)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.folders.delete",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Sa(i),n=new Ns(i);await o.delete(r,s),await n.updateLocalStorage(),e.port.emit(t,"SUCCESS",r)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.folders.update-local-storage",(async t=>{try{const r=new Sa(await Ye.getInstance().getApiClientOptions());await r.updateLocalStorage(),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.folders.open-move-confirmation-dialog",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new hc(e,t,s);await i.main(r),e.port.emit(t,"SUCCESS")}catch(r){e.port.emit(t,"ERROR",r)}}))}};class yc extends Te{constructor(e){super(e,yc.RESOURCE_NAME)}static get RESOURCE_NAME(){return"groups"}static getSupportedContainOptions(){return["modifier","modifier.profile","my_group_user","groups_users","groups_users.user","groups_users.user.profile","groups_users.user.gpgkey","group_user","group_user.user","group_user.user.profile","group_user.user.gpgkey"]}static getSupportedFiltersOptions(){return["has-users","has-managers"]}static getSupportedOrdersOptions(){return["Group.name DESC","Group.name ASC"]}async get(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}async findAll(e,t,r){const s=yc.remapLegacyContain(e);e=s?this.formatContainOptions(s,yc.getSupportedContainOptions()):null,t=t?this.formatFilterOptions(t,yc.getSupportedFiltersOptions()):null,r=r?this.formatOrderOptions(r,yc.getSupportedFiltersOptions()):null;const i={...e,...t,...r},o=await this.apiClient.findAll(i);return o.body&&o.body.length?o.body:[]}async create(e){this.assertNonEmptyData(e),e=yc.remapV2DataToV1(e);return(await this.apiClient.create(e)).body}async update(e,t){this.assertValidId(e),this.assertNonEmptyData(t);return(await this.apiClient.update(e,t)).body}async updateDryRun(e,t){this.assertValidId(e),this.assertNonEmptyData(t);const{body:r}=await this.apiClient.update(e,t,{},!0);if(r)return r["dry-run"]?this.remapUpdateDryRunDataV1tov2(r["dry-run"]):r}async delete(e,t,r){this.assertValidId(e);const s=t?{transfer:t}:{};return(await this.apiClient.delete(e,s,{},r)).body}static remapV2DataToV1(e){if(!e||!e.name||!e.groups_users)return;const t=[];for(const r of e.groups_users){const e={};Object.prototype.hasOwnProperty.call(r,"user_id")&&(e.user_id=r.user_id),Object.prototype.hasOwnProperty.call(r,"is_admin")&&(e.is_admin=r.is_admin?1:0),t.push({GroupUser:e})}return{Group:{name:e.name},GroupUsers:t}}static remapLegacyContain(e){if(e)return Object.prototype.hasOwnProperty.call(e,"groups_users")&&("boolean"==typeof e.groups_users?e.group_user=e.groups_users:e.group_user=Object.assign({},e.groups_users),delete e.groups_users),e}remapUpdateDryRunDataV1tov2(e){let t=[],r=[];if(e.Secrets&&Array.isArray(e.Secrets)){const r=e=>e.Secret&&Array.isArray(e.Secret)?e.Secret[0]:null;t=e.Secrets.map(r)}if(e.SecretsNeeded&&Array.isArray(e.SecretsNeeded)){const t=e=>e.Secret;r=e.SecretsNeeded.map(t)}return{secrets:t,needed_secrets:r}}}const _c=yc;class mc extends X{constructor(e){super(se.validate(mc.ENTITY_NAME,e,mc.getSchema()))}static getSchema(){return{type:"object",required:["user_id","resource_id"],properties:{user_id:{type:"string",format:"uuid"},resource_id:{type:"string",format:"uuid"}}}}get userId(){return this._props.user_id}get resourceId(){return this._props.resource_id}static get ENTITY_NAME(){return"NeededSecret"}}const wc=mc;class fc extends Ct{constructor(e){super(se.validate(fc.ENTITY_NAME,e,fc.getSchema())),this._props.forEach((e=>{this.push(new wc(e))})),this._props=null}static getSchema(){return{type:"array",items:wc.getSchema()}}get neededSecrets(){return this._items}push(e){if(!e||"object"!=typeof e)throw new TypeError("NeededSecretsCollection push parameter should be an object.");e instanceof wc&&(e=e.toDto());const t=new wc(e);super.push(t)}static get ENTITY_NAME(){return"NeededSecrets"}}const Ec=fc;class Sc extends Ct{constructor(e){super(se.validate(Sc.ENTITY_NAME,e,Sc.getSchema())),this._props.forEach((e=>{this.push(new Er(e))})),this._props=null}static getSchema(){return{type:"array",items:Er.getSchema()}}get secrets(){return this._items}assertUniqueId(e){if(!e.id)return;const t=this.items.findIndex((t=>t.id===e.id));if(-1!==t)throw new jt(t,Sc.RULE_UNIQUE_ID,`Secret id ${e.id} already exists.`)}assertUniqueResourceIdUserId(e){if(!e.userId||!e.resourceId)return;const t=this.items.findIndex((t=>t.resourceId===e.resourceId&&t.userId===e.userId));if(-1!==t)throw new jt(t,Sc.RULE_UNIQUE_USER_ID,`Secret for user id ${e.userId} and resource id ${e.resourceId} already exists.`)}push(e){if(!e||"object"!=typeof e)throw new TypeError("SecretsCollection push parameter should be an object.");e instanceof Er&&(e=e.toDto());const t=new Er(e);this.assertUniqueId(t),this.assertUniqueResourceIdUserId(t),super.push(t)}static get ENTITY_NAME(){return"Secrets"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_RESOURCE_ID_USER_ID(){return"unique_resource_id_user_id"}}const vc=Sc;class bc extends X{constructor(e){super(se.validate(bc.ENTITY_NAME,e,bc.getSchema())),this._props.secrets&&(this._secrets=new vc(this._props.secrets),delete this._props.secrets),this._props.needed_secrets&&(this._needed_secrets=new Ec(this._props.needed_secrets),delete this._props.needed_secrets)}static getSchema(){return{type:"object",required:[],properties:{secrets:vc.getSchema(),needed_secrets:Ec.getSchema()}}}toDto(){const e=Object.assign({},this._props);return this._secrets&&(e.secrets=this._secrets.toDto()),this._needed_secrets&&(e.needed_secrets=this._needed_secrets.toDto()),e}toJSON(){return this.toDto()}get secrets(){return this._secrets||null}get neededSecrets(){return this._needed_secrets||null}static get ENTITY_NAME(){return"GroupUpdateDryRunResult"}}const Ac=bc;class Tc extends X{constructor(e){super(Tc.validate(e)),this._props.owners&&(this._owners=new $n(this._props.owners),delete this._props.owners)}static validate(e){const t={};if(!e||!e.owners)throw new te("The group delete transfer data cannot be empty.");return e.owners&&Array.isArray(e.owners)&&(t.owners=e.owners),t}static getSchema(){return{type:"object",properties:{owners:$n.getSchema()}}}toDto(){const e={};return this.owners&&(e.owners=this.owners.toDto()),e}get owners(){return this._owners||null}static get ENTITY_NAME(){return"GroupDeleteTransfer"}}const Ic=Tc;const Rc=class{constructor(e){this.groupService=new _c(e)}async updateLocalStorage(){const e=await this.findAll({groups_users:!0,my_group_user:!0,modifier:!1},null,null,!0);return await os.set(e),e}async getById(e){const t=await os.getGroupById(e);if(t)return new or(t)}async findAll(e,t,r,s){let i=await this.groupService.findAll(e,t,r);return s&&(i=rs.sanitizeDto(i)),new rs(i)}async create(e){const t=e.toDto({groups_users:!0}),r=await this.groupService.create(t),s=new or(r);return await os.addGroup(s),s}async updateDryRun(e){const t=e.toDto(),r=await this.groupService.updateDryRun(e.id,t);return new Ac(r)}async update(e,t){const r=e.toDto();let s=await this.groupService.update(e.id,r);t&&(s=or.sanitizeDto(s));const i=new or(s);return await os.updateGroup(i),i}async deleteDryRun(e,t){try{const r=t&&t instanceof Ic?t.toDto():{};await this.groupService.delete(e,r,!0)}catch(e){if(e instanceof Se&&400===e.data.code&&e.data.body.errors)throw new Un(e.message,e.data.body.errors);throw e}}async delete(e,t){try{const r=t&&t instanceof Ic?t.toDto():{};await this.groupService.delete(e,r)}catch(e){if(e instanceof Se&&400===e.data.code&&e.data.body.errors)throw new Un(e.message,e.data.body.errors);throw e}await os.delete(e)}};class Cc extends X{constructor(e){super(se.validate(Cc.ENTITY_NAME,e,Cc.getSchema()))}static getSchema(){const e=It.getSchema(),t={type:"object",required:[],properties:{delete:{type:"boolean"}}};return["id","user_id","is_admin"].forEach((r=>{t.properties[r]=e.properties[r]})),t}static createFromGroupUser(e,t){if(!(e&&e instanceof It))throw new TypeError("GroupUserChangeEntity createFromGroupUser expect a GroupUser entity.");const r={};switch(t){case Cc.GROUP_USER_CHANGE_CREATE:if(!e.userId)throw new TypeError("GroupUserChangeEntity createFromGroupUser update expect a group user user_id.");r.user_id=e.userId,r.is_admin=e.isAdmin;break;case Cc.GROUP_USER_CHANGE_UPDATE:if(!e.id)throw new TypeError("GroupUserChangeEntity createFromGroupUser update expect a group user id.");r.id=e.id,r.is_admin=e.isAdmin;break;case Cc.GROUP_USER_CHANGE_DELETE:if(!e.id)throw new TypeError("GroupUserChangeEntity createFromGroupUser delete expect a group user id.");r.id=e.id,r.delete=!0;break;default:throw new TypeError("GroupUserChangeEntity createFromGroupUser unsupported operation")}return new Cc(r)}get id(){return this._props.id||null}get userId(){return this._props.user_id||null}get isAdmin(){return this._props.is_admin||null}get isDeleted(){return void 0===this._props.delete?null:this._props.delete}get scenario(){return this.isDeleted?Cc.GROUP_USER_CHANGE_DELETE:this.id?Cc.GROUP_USER_CHANGE_UPDATE:Cc.GROUP_USER_CHANGE_CREATE}static get ENTITY_NAME(){return"GroupUser"}static get GROUP_USER_CHANGE_CREATE(){return"create"}static get GROUP_USER_CHANGE_UPDATE(){return"update"}static get GROUP_USER_CHANGE_DELETE(){return"delete"}}const Oc=Cc;class kc extends Ct{constructor(e){super(se.validate(kc.ENTITY_NAME,e,kc.getSchema())),this._props.forEach((e=>{this.push(e)})),this._props=null}static getSchema(){return{type:"array",items:Oc.getSchema()}}static createFromGroupsUsersCollectionsChanges(e,t){if(!(e&&e instanceof kt&&t&&t instanceof kt))throw new TypeError("GroupUserChangesCollection createFromGroupsUsersCollectionsChanges invalid parameters");const r=new kc([]);for(const s of t){const t=e.getGroupUserByUserId(s.userId);if(t){if(s.isAdmin!==t.isAdmin){s.id=t.id;const e=Oc.createFromGroupUser(s,Oc.GROUP_USER_CHANGE_UPDATE);r.push(e)}}else{const e=Oc.createFromGroupUser(s,Oc.GROUP_USER_CHANGE_CREATE);r.push(e)}}for(const s of e)if(!t.getById(s.id)){const e=Oc.createFromGroupUser(s,Oc.GROUP_USER_CHANGE_DELETE);r.push(e)}return r}push(e){if(!e||"object"!=typeof e)throw new TypeError("GroupUserChangesCollection push parameter should be an object.");e instanceof Oc&&(e=e.toDto()),e=new Oc(e),super.push(e)}static get ENTITY_NAME(){return"GroupUserChanges"}}const Nc=kc;class Pc extends X{constructor(e){super(se.validate(Pc.ENTITY_NAME,e,Pc.getSchema())),this._props.groups_users&&(this._groups_users=new Nc(this._props.groups_users),delete this._props.groups_users),this._props.secrets&&(this._secrets=new vc(this._props.secrets),delete this._props.secrets)}static getSchema(){const e=or.getSchema();return{type:"object",required:["id","name"],properties:{id:e.properties.id,name:e.properties.name,groups_users:Nc.getSchema(),secrets:vc.getSchema()}}}static createFromGroupsDiff(e,t){const r={id:e.id,name:t.name,groups_users:Nc.createFromGroupsUsersCollectionsChanges(e.groupsUsers,t.groupsUsers).toDto()};return new Pc(r)}toDto(){const e=Object.assign({},this._props);return this._groups_users&&(e.groups_users=this._groups_users.toDto()),this._secrets&&(e.secrets=this._secrets.toDto()),e}toJSON(){return this.toDto()}get id(){return this._props.id||null}get name(){return this._props.name}get groupsUsers(){return this._groups_users||null}get secrets(){return this._secrets||null}set secrets(e){this._secrets=e}static get ENTITY_NAME(){return"GroupUpdate"}}const Uc=Pc;const xc=class{constructor(e,t,r){this.worker=e,this.groupModel=new Rc(r),this.keyring=new ge,this.progressService=new ji(this.worker,w.t("Updating group ..."))}async main(e){const t=new or(e),r=await this.groupModel.getById(t.id),s=Uc.createFromGroupsDiff(r,t);this.progressService.start(10,w.t("Initialize")),await this.progressService.finishStep(null,!0);try{const e=await this.getPrivateKey(),t=await this.simulateUpdateGroup(s),r=await t;r.neededSecrets.length>0&&(await this.synchronizeKeys(),s.secrets=await this.encryptNeededSecrets(e,r)),await this.updateGroup(s),await this.progressService.finishStep(null,!0),await this.progressService.close()}catch(e){throw await this.progressService.close(),e}return e}async simulateUpdateGroup(e){const t=await this.groupModel.updateDryRun(e),r=10+t.neededSecrets.length+t.secrets.length;return this.progressService.updateGoals(r),await this.progressService.finishStep(null,!0),t}async getPrivateKey(){const e=await Li.get(this.worker);return Mo.getKey(e)}async synchronizeKeys(){return await this.progressService.finishStep(w.t("Synchronizing keys"),!0),this.keyring.sync()}async encryptNeededSecrets(e,t){const r=await this.decryptSecrets(e,t.secrets);return await this.encryptSecrets(e,t.neededSecrets,r)}async encryptSecrets(e,t,r){const s=new vc([]),i=t.items;let o,n,a;for(const t in i){const c=i[t],u=c.resourceId;o!==c.userId&&(o=c.userId,n=this.keyring.findPublic(o).armoredKey,a=await M(n)),await this.progressService.finishStep(w.t("Encrypting {{counter}}/{{total}}",{counter:t,total:i.length}));const p={resource_id:u,user_id:o,data:await ye.encrypt(r[u],a,[e])},l=new Er(p);s.push(l)}return s}async decryptSecrets(e,t){const r=[],s=t.items;for(const t in s){const i=s[t],o=await U(i.data);await this.progressService.finishStep(w.t("Decrypting {{counter}}/{{total}}",{counter:t,total:s.length})),r[i.resourceId]=await _e.decrypt(o,e)}return r}async updateGroup(e){await this.progressService.finishStep(w.t("Updating group"),!0),await this.groupModel.update(e,!0)}},Mc={listen:function(e){e.port.on("passbolt.groups.update-local-storage",(async t=>{try{const r=new Rc(await Ye.getInstance().getApiClientOptions());await r.updateLocalStorage(),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.groups.find-all",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Rc(s),{contains:o,filters:n,orders:a}=r,c=await i.findAll(o,n,a);e.port.emit(t,"SUCCESS",c)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.groups.create",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Rc(s),o=new or(r),n=await i.create(o);e.port.emit(t,"SUCCESS",n)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.groups.update",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new xc(e,t,s);try{const s=await i.main(r);e.port.emit(t,"SUCCESS",s)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.groups.delete-dry-run",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Rc(i),n=s?new Ic(s):null;await o.deleteDryRun(r,n),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.groups.delete",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Rc(i),n=s?new Ic(s):null;await o.delete(r,n),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};class Lc extends Te{constructor(e){super(e,Lc.RESOURCE_NAME)}static get RESOURCE_NAME(){return"tags"}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}async updateResourceTags(e,t){this.assertValidId(e);const r=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/${e}`),s={Tags:t.map((e=>e.slug))},i=this.apiClient.buildBody(s);return(await this.apiClient.fetchAndHandleResponse("POST",r,i)).body}async update(e,t){this.assertValidId(e);return(await this.apiClient.update(e,t)).body}async delete(e){this.assertValidId(e);return(await this.apiClient.delete(e)).body}}const Dc=Lc;const Fc=class{constructor(e){this.tagService=new Dc(e),this.resourceModel=new Ns(e)}async findAll(){const e=await this.tagService.findAll();return new wr(e)}async updateResourceTags(e,t){const r=await this.tagService.updateResourceTags(e,t.toDto()),s=new wr(r);return await this.resourceModel.replaceResourceTagsLocally(e,s)}async update(e){const t=await this.tagService.update(e.id,e.toDto()),r=new _r(t);return await this.resourceModel.replaceTagLocally(e.id,r),r}async delete(e){await this.tagService.delete(e),await this.resourceModel.deleteTagsLocally(e)}async bulkTagResources(e,t,r){let s=[];const i=ks(e,5);for(const e in i){const o=i[e].map((async(s,i)=>{const o=5*e+i;return this._bulkTagResources_tagResource(s,t,o,r)})),n=(await Promise.allSettled(o)).map((e=>e.value));s=[...s,...n]}return await this.resourceModel.bulkReplaceResourceTagsLocally(e,s)}async _bulkTagResources_tagResource(e,t,r,s){const i=(s=s||{}).successCallback||(()=>{}),o=s.errorCallback||(()=>{});try{const s=await this.resourceModel.getById(e),o=new wr([...t.tags,...s.tags]),n=await this.tagService.updateResourceTags(e,o.toDto()),a=new wr(n);return i(a,r),a}catch(e){return console.error(e),o(e,r),e}}};class qc extends X{constructor(e){super(se.validate(qc.ENTITY_NAME,e,qc.getSchema())),e.options&&(se.validate(qc.ENTITY_NAME,e.options,qc.getSchema().properties.options),e.options.credentials&&se.validate(qc.ENTITY_NAME,e.options.credentials,qc.getSchema().properties.options.properties.credentials)),this._import_resources=new Ha([]),this._import_folders=new Ta([]),this._import_resources_errors=[],this._import_folders_errors=[]}static getSchema(){return{type:"object",required:["ref","file","file_type"],properties:{ref:{type:"string",pattern:/^[a-zA-Z0-9\-_]*$/},file:{type:"string",format:"x-base64"},file_type:{type:"string",enum:qc.SUPPORTED_FILE_TYPES},options:{type:"object",required:[],properties:{folders:{type:"boolean"},tags:{type:"boolean"},credentials:{type:"object",required:[],properties:{password:{anyOf:[{type:"string"},{type:"null"}]},keyfile:{anyOf:[{type:"string",format:"x-base64"},{type:"null"}]}}}}}}}}toDto(){return{created:{resourcesCount:this.importResources.items.filter((e=>e.id)).length,foldersCount:this.importFolders.items.filter((e=>e.id)).length},errors:{resources:this.importResourcesErrors.map((e=>e.toJSON())),folders:this.importFoldersErrors.map((e=>e.toJSON()))},options:{folders:this.mustImportFolders,tags:this.mustTag},references:{folder:this.referenceFolder?this.referenceFolder.toJSON():null,tag:this.referenceTag?this.referenceTag.toJSON():null}}}toJSON(){return this.toDto()}get ref(){return this._props.ref}get file(){return this._props.file}get fileType(){return this._props.file_type}get options(){return this._props.options||{}}get mustImportFolders(){return this.options.folders||!1}get mustTag(){return this.options.tags||!1}get credentials(){return this.options.credentials||{}}get password(){return this.credentials.password}get keyfile(){return this.credentials.keyfile}get referenceFolder(){return this._referenceFolder||null}set referenceFolder(e){if(null!==e&&!(e instanceof Gr))throw new TypeError("The reference folder should be a valid FolderEntity");this._referenceFolder=e}get referenceTag(){return this._referenceTag||null}set referenceTag(e){if(null!==e&&!(e instanceof _r))throw new TypeError("The reference tag should be a valid TagEntity");this._referenceTag=e}get importResources(){return this._import_resources}set importResources(e){if(!(e instanceof Ha))throw new TypeError("importResources must be a valid ImportResourcesCollection instance");this._import_resources=e}get importFolders(){return this._import_folders}set importFolders(e){if(!(e instanceof Ta))throw new TypeError("importFolders must be a valid ExternalFoldersCollection instance");this._import_folders=e}get importResourcesErrors(){return this._import_resources_errors}set importResourcesErrors(e){if(Array.isArray(e))throw new TypeError("importResourcesErrors must be a valid array");this._import_resources_errors=e}get importFoldersErrors(){return this._import_folders_errors}set importFoldersErrors(e){if(Array.isArray(e))throw new TypeError("importFoldersErrors must be a valid array");this._import_folders_errors=e}static get ENTITY_NAME(){return"ImportResourcesFile"}static get SUPPORTED_FILE_TYPES(){return[qc.FILE_TYPE_CSV,qc.FILE_TYPE_KDBX]}static get FILE_TYPE_CSV(){return"csv"}static get FILE_TYPE_KDBX(){return"kdbx"}}const Kc=qc;class $c extends Error{constructor(e,t,r){super(e),this.name="ImportError",this.data=t,this.sourceError=r||{}}toJSON(){const e=this.sourceError&&"function"==typeof this.sourceError.toJSON?this.sourceError.toJSON():this.sourceError,t=this.data&&"function"==typeof this.data.toJSON?this.data.toJSON():this.data;return{name:this.name,message:this.message,data:t,sourceError:e}}}const jc=$c;const Bc=class{constructor(e,t){this.importEntity=e,this.resourceTypesCollection=t}async parseImport(){const e=await this.readKdbxDb();this.parseFolder(e.getDefaultGroup()),this.createAndChangeRootFolder()}async readKdbxDb(){const e=ja.ByteUtils.base64ToBytes(this.importEntity.file),t=this.readKdbxCredentials();return ja.Kdbx.load(e.buffer,t)}readKdbxCredentials(){let e=null,t=null;return this.importEntity.password&&(e=ja.ProtectedValue.fromString(this.importEntity.password)),this.importEntity.keyfile&&(t=ja.ByteUtils.base64ToBytes(this.importEntity.keyfile)),new ja.Credentials(e,t)}parseFolder(e){const t={name:ba.escapeName(e.name),folder_parent_path:this.getKdbxEntryPath(e)};try{this.importEntity.importFolders.push(t),this.getGroupChildrenGroups(e).forEach(this.parseFolder.bind(this)),this.getGroupChildrenEntries(e).forEach(this.parseResource.bind(this))}catch(e){this.importEntity.importFoldersErrors.push(new jc("Cannot parse folder",t,e))}}getGroupChildrenGroups(e){return e.groups.filter((e=>e.parentGroup.id===e.id))}getGroupChildrenEntries(e){return e.entries.filter((t=>t.parentGroup.id===e.id))}getKdbxEntryPath(e){let t=[];if(e.parentGroup){const r=e=>e.parentGroup?[...r(e.parentGroup),ba.escapeName(e.name)]:[ba.escapeName(e.name)];t=r(e.parentGroup)}return t.join("/")}parseResource(e){const t={name:e.fields.get("Title")?e.fields.get("Title").trim():"",uri:e.fields.get("URL")?e.fields.get("URL").trim():"",username:e.fields.get("UserName")?e.fields.get("UserName").trim():"",description:e.fields.get("Notes")?e.fields.get("Notes").trim():"",folder_parent_path:this.getKdbxEntryPath(e),secret_clear:""};"object"==typeof e.fields.get("Password")&&(t.secret_clear=e.fields.get("Password").getText());const r=this.parseResourceType();r&&(t.resource_type_id=r.id),t.name.length||(t.name=Ra.DEFAULT_RESOURCE_NAME);try{this.importEntity.importResources.push(t)}catch(e){this.importEntity.importResourcesErrors.push(new jc("Cannot parse resource",t,e))}}parseResourceType(){if(this.resourceTypesCollection)return this.resourceTypesCollection.getFirst("slug","password-and-description")}createAndChangeRootFolder(){const e=new ba({name:this.importEntity.ref});this.importEntity.importFolders.changeRootPath(e),this.importEntity.importResources.changeRootPath(e),this.importEntity.importFolders.push(e)}};const Gc=class{static fromBinary(e){const t=new Uint8Array(e.length);for(let r=0;r<t.length;r++)t[r]=e.charCodeAt(r);return new Uint16Array(t.buffer).reduce(((e,t)=>e+String.fromCharCode(t)),"")}static toBinary(e){const t=new Uint16Array(e.length);for(let r=0;r<t.length;r++)t[r]=e.charCodeAt(r);return new Uint8Array(t.buffer).reduce(((e,t)=>e+String.fromCharCode(t)),"")}};const Yc=class extends Ca{static get mapping(){return{name:"name",username:"username",uri:"url",secret_clear:"password"}}static parse(e,t){const r={},s=this.parseResourceType(e,t);s&&(r.resource_type_id=s.id);for(const t in this.mapping)e[this.mapping[t]]&&(r[t]=e[this.mapping[t]]);return new Ra(r)}static parseResourceType(e,t){if(t)return t.getFirst("slug","password-and-description")}};const zc=[Pa,Oa,xa,Yc,class extends Ca{static get mapping(){return{name:"name",username:"login_username",uri:"login_uri",secret_clear:"login_password",description:"notes",folder_parent_path:"folder"}}static parse(e,t){const r={},s=this.parseResourceType(e,t);s&&(r.resource_type_id=s.id);for(const t in this.mapping)e[this.mapping[t]]&&(r[t]=e[this.mapping[t]]);return new Ra(r)}static parseResourceType(e,t){if(t)return t.getFirst("slug","password-and-description")}}];const Vc=class{constructor(e,t){this.importEntity=e,this.resourceTypesCollection=t}static get register(){return zc}async parseImport(){const{data:e,fields:t}=this.readCsv(),r=this.getRowParser(t);if(!r)throw new Da("This csv format is not supported.");const s=this.parseResources(r,e),i=this.parseFolders(s);this.createAndChangeRootFolder(i,s),this.importEntity.importFolders=i,this.importEntity.importResources=s}readCsv(){const e=atob(this.importEntity.file),t=Gc.fromBinary(e),{data:r,meta:{fields:s}}=qa().parse(t,{header:!0,skipEmptyLines:!0});return{data:r,fields:s}}getRowParser(e){let t=null,r=0;for(const s of zc){const i=s.canParse(e);i>r&&(t=s,r=i)}return t}parseResources(e,t){const r=new Ha([]);return t.forEach((t=>{try{const s=e.parse(t,this.resourceTypesCollection);r.push(s)}catch(e){this.importEntity.importResourcesErrors.push(new jc("Cannot parse resource",t,e))}})),r}parseFolders(e){const t=new Ta([]);for(const r of e)try{t.pushFromPath(r.folderParentPath)}catch(e){this.handleParseFolderValidationError(e,r)}return t}handleParseFolderValidationError(e,t){const r={path:t.folderParentPath};this.importEntity.importFoldersErrors.push(new jc("Cannot parse folder",r,e)),t.folderParentPath=""}createAndChangeRootFolder(e,t){const r=new ba({name:this.importEntity.ref});e.changeRootPath(r),t.changeRootPath(r),e.push(r)}};const Hc=class{parseImport(e,t){return new(this.getParser(e))(e,t).parseImport()}getParser(e){switch(e.fileType.toLowerCase()){case Kc.FILE_TYPE_CSV:return Vc;case Kc.FILE_TYPE_KDBX:return Bc;default:throw new Ya(`The file type ${e.fileType} is not supported`)}}};const Wc=class{constructor(e,t){this.worker=e,this.keyring=new ge,this.resourceTypeModel=new fs(t),this.resourceModel=new Ns(t),this.folderModel=new Sa(t),this.tagModel=new Fc(t),this.progressService=new ji(this.worker,w.t("Importing ..."))}async exec(e,t,r){const s=Ye.getInstance().get().id;this.progressService.start(100,w.t("Initialize")),await this.progressService.finishStep(null,!0);try{const i=this.buildImportEntity(e,t,r);await this.parseFile(i);const o=await this.getPrivateKey();return await this.encryptSecrets(i,s,o),i.mustImportFolders&&await this.bulkImportFolders(i),await this.bulkImportResources(i),i.mustTag&&await this.bulkTagResources(i),await this.progressService.finishStep(null,!0),await this.progressService.close(),i}catch(e){throw await this.progressService.close(),e}}buildImportEntity(e,t,r){const s=this.generateImportReference();return new Kc({file_type:e,file:t,options:r,ref:s})}generateImportReference(){return`import-${(new Date).toISOString().split(".")[0].replace(/\D/g,"")}`}async parseFile(e){const t=new Hc,r=await this.resourceTypeModel.getOrFindAll();await t.parseImport(e,r);const s=1+(e.mustImportFolders?e.importFolders.items.length:0)+2*e.importResources.items.length+(e.mustTag?e.importResources.items.length:0);return this.progressService.updateGoals(s),e}async getPrivateKey(){const e=await Li.get(this.worker);return Mo.getKey(e)}async encryptSecrets(e,t,r){let s=0;for(const i of e.importResources){s++,await this.progressService.finishStep(w.t("Encrypting {{counter}}/{{total}}",{counter:s,total:e.importResources.items.length}));const o=this.buildSecretDto(i),n=await this.resourceModel.serializePlaintextDto(i.resourceTypeId,o),a=this.keyring.findPublic(t).armoredKey,c=await M(a),u=await ye.encrypt(n,c,[r]),p=new Er({data:u});i.secrets=new vr([p])}}buildSecretDto(e){if(e.resourceTypeId){const t={password:e.secretClear||"",description:e.description||""};return e.description="",t}return e.secretClear}async bulkImportFolders(e){let t=0,r=0;do{const s=e.importFolders.getByDepth(r);if(!s.length)break;const i=Ta.toFoldersCollection(s),o=(r,i)=>this.handleImportFolderSuccess.bind(this)(e,++t,r,s[i]),n=(r,i)=>this.handleImportFolderError.bind(this)(e,++t,r,s[i]);await this.folderModel.bulkCreate(i,{successCallback:o,errorCallback:n})}while(++r);const s=e.importFolders.getByPath(e.ref);if(s){const t=await this.folderModel.getById(s.id);e.referenceFolder=t}}async handleImportFolderSuccess(e,t,r,s){s.id=r.id,e.importFolders.setFolderParentIdsByPath(s.path,s.id),e.importResources.setFolderParentIdsByPath(s.path,s.id),await this.progressService.finishStep(w.t("Importing folders {{importedCount}}/{{total}}",{importedCount:t,total:e.importFolders.items.length}))}async handleImportFolderError(e,t,r,s){await this.progressService.finishStep(w.t("Importing folders {{importedCount}}/{{total}}",{importedCount:t,total:e.importFolders.items.length})),e.importFoldersErrors.push(new jc("Cannot import folder",s,r)),e.importFolders.removeByPath(s.path),e.importResources.removeByPath(s.path)}async bulkImportResources(e){let t=0;const r=new Pr(e.importResources.toJSON());await this.resourceModel.bulkCreate(r,{successCallback:(r,s)=>this.handleImportResourceSuccess(e,++t,r,e.importResources.items[s]),errorCallback:(r,s)=>this.handleImportResourceError(e,++t,r,e.importResources.items[s])})}async handleImportResourceSuccess(e,t,r,s){s.id=r.id,await this.progressService.finishStep(w.t("Importing passwords {{importedCount}}/{{total}}",{importedCount:t,total:e.importResources.items.length}))}async handleImportResourceError(e,t,r,s){await this.progressService.finishStep(w.t("Importing passwords {{importedCount}}/{{total}}",{importedCount:t,total:e.importResources.items.length})),e.importResourcesErrors.push(new jc("Cannot import resource",s,r))}async bulkTagResources(e){const t=new wr([{slug:e.ref}]),r=e.importResources.items.filter((e=>e.id)).map((e=>e.id));if(!r.length)return;if(await this.tagModel.updateResourceTags(r[0],t),r.splice(0,1),!r.length)return;let s=0;const i=await this.tagModel.bulkTagResources(r,t,{successCallback:()=>this.handleTagResourceSuccess(e,++s),errorCallback:()=>this.handleTagResourceError(e,++s)});i&&i.length&&(e.referenceTag=i[0].tags.items[0])}async handleTagResourceSuccess(e,t){await this.progressService.finishStep(w.t("Tagging passwords {{taggedCount}}/{{total}}",{taggedCount:t,total:e.importResources.items.length}))}async handleTagResourceError(e,t){await this.progressService.finishStep(w.t("Tagging passwords {{taggedCount}}/{{total}}",{taggedCount:t,total:e.importResources.items.length}))}},Jc={listen:function(e){e.port.on("passbolt.import-resources.import-file",(async(t,r,s,i)=>{const o=await Ye.getInstance().getApiClientOptions(),n=new Wc(e,o);try{const o=await n.exec(r,s,i);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const Qc=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new ge}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){let t=this.keyring.findPublic(e);if(!t&&(await this.keyring.sync(),t=this.keyring.findPublic(e),!t))throw new Error("User key not found");const r=await M(t.armoredKey);return de.getKeyInfo(r)}};const Zc=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new ge}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(!e)throw new Error("An armored key must be provided");const t=await M(e);return await de.getKeyInfo(t)}};const Xc=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new ge}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=this.keyring.findPrivate()?.armoredKey;if(!e)throw new le(w.t("Public key can't be found."));const t=await M(e);O(t);const r=await t.toPublic().armor();await ho.saveFile("passbolt_public.asc",r,"text/plain",this.worker.tab.id)}};const eu=class{constructor(e,t){this.worker=e,this.requestId=t,this.keyring=new ge}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;await Li.request(this.worker);try{e=this.keyring.findPrivate().armoredKey}catch(e){throw new le(w.t("Private key not found."))}await ho.saveFile("passbolt_private.asc",e,"text/plain",this.worker.tab.id)}},tu={listen:function(e){e.port.on("passbolt.keyring.get-public-key-info-by-user",(async(t,r)=>{const s=new Qc(e,t);await s._exec(r)})),e.port.on("passbolt.keyring.get-key-info",(async(t,r)=>{const s=new Zc(e,t);await s._exec(r)})),e.port.on("passbolt.keyring.private.checkpassphrase",(async(t,r)=>{const s=new Nn(e,t);await s._exec(r)})),e.port.on("passbolt.keyring.download-my-public-key",(async t=>{const r=new Xc(e,t);await r._exec()})),e.port.on("passbolt.keyring.download-my-private-key",(async t=>{const r=new eu(e,t);await r._exec()})),e.port.on("passbolt.keyring.get-private-key",(async t=>{try{await Li.request(e);const r=(new ge).findPrivate();if(!r)throw new Error("Private key not found.");e.port.emit(t,"SUCCESS",r.armoredKey)}catch(r){e.port.emit(t,"ERROR",r)}}))}};const ru={getCurrent:async function(){return(await u.tabs.query({active:!0,currentWindow:!0}))[0]},getById:async function(e){return(await u.tabs.query({})).find((t=>t.id===parseInt(e)))}};const su=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.resourceModel=new Ns(r),this.progressService=new ji(this.worker,w.t("Decrypting ..."))}async main(e,t){const r=this.resourceModel.findForDecrypt(e),s=await Li.get(this.worker);try{t&&this.progressService.start(2,w.t("Decrypting private key"));const e=await Mo.getKey(s);t&&await this.progressService.finishStep(w.t("Decrypting secret"),!0);const i=await r,o=await U(i.secret.data);let n=await _e.decrypt(o,e);return n=await this.resourceModel.deserializePlaintext(i.resourceTypeId,n),t&&(await this.progressService.finishStep(w.t("Complete"),!0),await this.progressService.close()),{plaintext:n,resource:i}}catch(e){throw console.error(e),t&&await this.progressService.close(),e}}},iu="ResourceInProgressCacheFlush",ou="resourceInProgress";const nu=new class{constructor(){this.bindCallbacks()}bindCallbacks(){this.reset=this.reset.bind(this),this.handleFlushEvent=this.handleFlushEvent.bind(this)}async consume(){const e=await u.storage.session.get(ou);return this.reset(),e?.[ou]||null}async set(e,t=6e3){if(!(e instanceof Ra))throw new TypeError("ResourceInProgressCacheService::set expects a ExternalResourceEntity");this.reset(),await u.storage.session.set({[ou]:e.toDto()}),this.scheduleStorageFlush(t),self.addEventListener("passbolt.auth.after-logout",this.reset)}scheduleStorageFlush(e){u.alarms.create(iu,{when:Date.now()+e}),u.alarms.onAlarm.addListener(this.handleFlushEvent)}clearAlarm(){u.alarms.onAlarm.removeListener(this.handleFlushEvent),u.alarms.clear(iu)}async handleFlushEvent(e){e.name===iu&&this.reset()}reset(){u.storage.session.remove(ou),this.clearAlarm(),self.removeEventListener("passbolt.auth.after-logout",this.reset)}},au={listen:function(e){e.port.on("passbolt.quickaccess.use-resource-on-current-tab",(async(t,r,s)=>{let i;if(!e.port){const r=new Error(w.t("Inactive worker on the page."));e.port.emit(t,"ERROR",r)}try{if(i=s?await ru.getById(s):await ru.getCurrent(),!i){const r=new Error(w.t("Autofill failed. Could not find the active tab."));e.port.emit(t,"ERROR",r)}}catch(r){e.port.emit(t,"ERROR",r)}try{const s=await Ye.getInstance().getApiClientOptions(),o=new su(e,t,s),{plaintext:n,resource:a}=await o.main(r,!1),c=a.username||"";let u;u="string"==typeof n?n:n.password||"";const p=await gi.get("WebIntegration",i.id);await p.port.request("passbolt.quickaccess.fill-form",c,u,i.url),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.quickaccess.prepare-resource",(async(t,r)=>{try{const s=await nu.consume();if(null===s){const s=r?await ru.getById(r):await ru.getCurrent(),i=s.title,o=s.url;e.port.emit(t,"SUCCESS",{name:i,uri:o})}else e.port.emit(t,"SUCCESS",s)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.quickaccess.prepare-autosave",(async t=>{try{const r=await nu.consume()||{};e.port.emit(t,"SUCCESS",r)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.quickaccess.update-window-height",(async t=>{try{const r=await ru.getById(e.tab.id);u.windows.update(r.windowId,{height:t+30})}catch(e){console.error(e)}}))}};class cu extends Te{constructor(e){super(e,cu.RESOURCE_NAME)}static get RESOURCE_NAME(){return"mfa"}async disableMfaForUser(e){this.assertValidId(e);const t=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/${e}`);return this.apiClient.fetchAndHandleResponse("DELETE",t)}async getSettings(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/setup/select`);return this.apiClient.fetchAndHandleResponse("GET",e)}}const uu=cu;class pu extends Te{constructor(e){super(e,pu.RESOURCE_NAME)}static get RESOURCE_NAME(){return"mfa-policies"}async find(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/settings`);return this.apiClient.fetchAndHandleResponse("GET",e)}}const lu=pu;const du=class{constructor(e){this.multiFactorAuthenticationService=new uu(e),this.multiFactorAuthenticationPolicyService=new lu(e)}async disableForUser(e){await this.multiFactorAuthenticationService.disableMfaForUser(e);const t=await es.getUserById(e);if(t){t.is_mfa_enabled=!1;const e=new sr(t);await es.updateUser(e)}}async getPolicy(){return(await this.multiFactorAuthenticationPolicyService.find()).body.policy}async getMfaSettings(){return(await this.multiFactorAuthenticationService.getSettings()).body.MfaAccountSettings}},hu={listen:function(e){e.port.on("passbolt.mfa.disable-for-user",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new du(s);await i.disableForUser(r),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const gu=class{static async encrypt(e,t){if(C(e),!ke(t))throw new Error("The passphrase should be a valid UTF8 string.");return await h.Vg({privateKey:e,passphrase:t})}};const yu=class{static async reEncrypt(e,t,r){I(e),this._validatePassphrase(t),this._validatePassphrase(r);const s=await Ii.decrypt(e,t);return gu.encrypt(s,r)}static _validatePassphrase(e){if(!ke(e))throw new Error("The passphrase should be a valid UTF8 string.")}};const _u=class{constructor(){this.keyring=new ge}async add(e){const t=Ye.getInstance();t.settings.setSecurityToken(e.securityToken.toDto()),t.settings.setDomain(e.domain);const r=e.toLegacyUserDto();t.set(r),this.keyring.flush(ge.PUBLIC),this.keyring.flush(ge.PRIVATE),await this.keyring.importServerPublicKey(e.serverPublicArmoredKey,e.domain),await this.keyring.importPublic(e.userPublicArmoredKey,e.userId),await this.keyring.importPrivate(e.userPrivateArmoredKey)}async changeSecurityToken(e){await Ye.getInstance().updateSecurityToken(e.toDto())}async rotatePrivateKeyPassphrase(e,t){const r=this.keyring.findPrivate().armoredKey,s=await M(r);return(await yu.reEncrypt(s,e,t)).armor()}async updatePrivateKey(e){const t=this.keyring.findPrivate(),r=await M(e);if(t.fingerprint.toUpperCase()!==r.getFingerprint().toUpperCase())throw new Error("The private key to import doesn't match the current private key.");await this.keyring.importPrivate(e)}};class mu extends X{constructor(e){super(se.validate(mu.ENTITY_NAME,e,mu.getSchema()))}static getSchema(){return{type:"object",required:["code","color","textcolor"],properties:{code:{type:"string",pattern:/^[a-zA-Z0-9-_]{3}$/},color:{type:"string",format:"x-hex-color"},textcolor:{type:"string",format:"x-hex-color"}}}}get code(){return this._props.code}get color(){return this._props.color}get textcolor(){return this._props.textcolor}static get ENTITY_NAME(){return"SecurityToken"}}const wu=mu;class fu extends X{constructor(e){super(e),this._props.security_token&&(this._security_token=new wu(this._props.security_token),delete this._props.security_token)}static getSchema(){const e=sr.getSchema(),t=Lt.getSchema();return{type:"object",required:[],properties:{type:{type:"string"},domain:{type:"string"},user_id:{type:"string",format:"uuid"},user_key_fingerprint:{type:"string",minLength:40,maxLength:40,pattern:/^[A-F0-9]{40}$/},user_public_armored_key:{type:"string"},user_private_armored_key:{type:"string"},server_public_armored_key:{type:"string"},username:e.properties.username,first_name:t.properties.first_name,last_name:t.properties.last_name,locale:{anyOf:[{type:"string",pattern:/^[a-z]{2}-[A-Z]{2}$/},{type:"null"}]},security_token:wu.getSchema()}}}get type(){return this._props.type}get domain(){return this._props.domain}get userId(){return this._props.user_id}get username(){return this._props.username}set username(e){se.validateProp("username",e,fu.getSchema().properties.username),this._props.username=e}get firstName(){return this._props.first_name}set firstName(e){se.validateProp("first_name",e,fu.getSchema().properties.first_name),this._props.first_name=e}get lastName(){return this._props.last_name}set lastName(e){se.validateProp("last_name",e,fu.getSchema().properties.last_name),this._props.last_name=e}get locale(){return this._props.locale}set locale(e){se.validateProp("locale",e,fu.getSchema().properties.locale),this._props.locale=e}get userPublicArmoredKey(){return this._props.user_public_armored_key}set userPublicArmoredKey(e){se.validateProp("user_public_armored_key",e,fu.getSchema().properties.user_public_armored_key),this._props.user_public_armored_key=e}get userPrivateArmoredKey(){return this._props.user_private_armored_key}set userPrivateArmoredKey(e){se.validateProp("user_private_armored_key",e,fu.getSchema().properties.user_private_armored_key),this._props.user_private_armored_key=e}get serverPublicArmoredKey(){return this._props.server_public_armored_key}set serverPublicArmoredKey(e){se.validateProp("server_public_armored_key",e,fu.getSchema().properties.server_public_armored_key),this._props.server_public_armored_key=e}get userKeyFingerprint(){return this._props.user_key_fingerprint}set userKeyFingerprint(e){se.validateProp("user_key_fingerprint",e,fu.getSchema().properties.user_key_fingerprint),this._props.user_key_fingerprint=e}get securityToken(){return this._security_token||null}set securityToken(e){e instanceof wu&&(e=e.toDto()),this._security_token=new wu(e)}static get ENTITY_NAME(){return"AbstractAccount"}}const Eu=fu;var Su=r(96);const vu=new(r.n(Su)()),bu="accounts";class Au{static async get(){const{accounts:e}=await u.storage.local.get([bu]);return e||[]}static async getAccountByUserIdAndType(e,t){return(await Au.get()).find((r=>r.user_id===e&&r.type===t))}static async add(e){if(!(e instanceof Eu))throw new TypeError("ResourceLocalStorage::add expects an AccountEntity");await vu.acquireAsync();try{const t=await Au.get();t.push(e.toDto(Au.DEFAULT_CONTAIN)),await u.storage.local.set({[bu]:t}),vu.release()}catch(e){throw vu.release(),e}}static async deleteByUserIdAndType(e,t){await vu.acquireAsync();try{const r=await Au.get();if(r){const s=r.filter((r=>r.user_id!==e||r.type!==t));await u.storage.local.set({[bu]:s})}vu.release()}catch(e){throw vu.release(),e}}static get DEFAULT_CONTAIN(){return{user:!0,security_token:!0,authentication_token_token:!0,account_recovery_request_id:!0,user_private_armored_key:!0}}static get ACCOUNTS_LOCAL_STORAGE_KEY(){return bu}}const Tu=Au;class Iu extends X{constructor(e){super(se.validate(Iu.ENTITY_NAME,e,Iu.getSchema()))}static getSchema(){return{type:"object",required:["token"],properties:{id:{type:"string",format:"uuid"},token:{type:"string",format:"uuid"},active:{type:"boolean"},type:{type:"string",enum:[Iu.AUTHENTICATION_TOKEN_TYPE_LOGIN,Iu.AUTHENTICATION_TOKEN_TYPE_MFA,Iu.AUTHENTICATION_TOKEN_TYPE_MOBILE_TRANSFER,Iu.AUTHENTICATION_TOKEN_TYPE_RECOVER,Iu.AUTHENTICATION_TOKEN_TYPE_REGISTER]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get token(){return this._props.token}static get ENTITY_NAME(){return"AuthenticationToken"}static get AUTHENTICATION_TOKEN_TYPE_LOGIN(){return"login"}static get AUTHENTICATION_TOKEN_TYPE_MFA(){return"mfa"}static get AUTHENTICATION_TOKEN_TYPE_MOBILE_TRANSFER(){return"mobile_transfer"}static get AUTHENTICATION_TOKEN_TYPE_RECOVER(){return"recover"}static get AUTHENTICATION_TOKEN_TYPE_REGISTER(){return"register"}}const Ru=Iu;class Cu extends X{constructor(e){super(se.validate(Cu.ENTITY_NAME,e,Cu.getSchema())),this._props.authentication_token&&(this._authentication_token=new Ru(this._props.authentication_token),delete this._props.authentication_token)}static getSchema(){return{type:"object",required:["user_id","fingerprint","armored_key","authentication_token"],properties:{user_id:Xt.getSchema().properties.user_id,armored_key:Xt.getSchema().properties.armored_key,fingerprint:Xt.getSchema().properties.fingerprint,authentication_token:Ru.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this.authenticationToken&&e.authentication_token&&(t.authentication_token=this.authenticationToken.toDto()),t):t}toJSON(){return this.toDto(Cu.ALL_CONTAIN_OPTIONS)}get authenticationToken(){return this._authentication_token||null}static get ENTITY_NAME(){return"AccountRecoveryRequestCreate"}static get ALL_CONTAIN_OPTIONS(){return{authentication_token:!0}}}const Ou=Cu;class ku extends Eu{constructor(e){ku.marshal(e),super(se.validate(ku.ENTITY_NAME,e,ku.getSchema())),this._props.account_recovery_user_setting&&(this._account_recovery_user_setting=new tr(this._props.account_recovery_user_setting),delete this._props.account_recovery_user_setting),this._props.user&&(this._user=new sr(this._props.user),delete this._props.user)}static marshal(e){Object.assign(e,{type:ku.TYPE_ACCOUNT_RECOVER})}static getSchema(){const e=Eu.getSchema(),t=Ru.getSchema();return{type:"object",required:["type","domain","user_id","authentication_token_token"],properties:{...e.properties,type:{type:"string",pattern:`^${ku.TYPE_ACCOUNT_RECOVER}$`},authentication_token_token:t.properties.token,user:sr.getSchema()}}}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,delete t.authentication_token_token,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.authentication_token_token&&(t.authentication_token_token=this.authenticationTokenToken),e.security_token&&this._security_token&&(t.security_token=this._security_token.toDto()),e.user&&this._user&&(t.user=this._user.toDto(sr.ALL_CONTAIN_OPTIONS)),t):t}toCompleteRecoverDto(){return{authenticationtoken:{token:this.authenticationTokenToken},authentication_token:{token:this.authenticationTokenToken},gpgkey:{armored_key:this.userPublicArmoredKey},user:{locale:this.locale},locale:this.locale}}toAbortRecoverDto(){return{authentication_token:{token:this.authenticationTokenToken}}}toAccountRecoveryRequestDto(){return{authentication_token:{token:this.authenticationTokenToken},fingerprint:this.userKeyFingerprint,user_id:this.userId,armored_key:this.userPublicArmoredKey}}get authenticationTokenToken(){return this._props.authentication_token_token||null}get user(){return this._user||null}set user(e){if(!(e&&e instanceof sr))throw new TypeError("Failed to assert the parameter is a valid UserEntity");this._user=e}get accountRecoveryUserSetting(){return this._account_recovery_user_setting||null}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,security_token:!0,authentication_token_token:!0,user:!0}}static get ENTITY_NAME(){return"AccountRecover"}static get TYPE_ACCOUNT_RECOVER(){return"account-recover"}}const Nu=ku;class Pu extends Eu{constructor(e){Pu.marshal(e),super(se.validate(Pu.ENTITY_NAME,e,Pu.getSchema())),this._props.account_recovery_request&&(this._account_recovery_request=new Xt(this._props.account_recovery_request),delete this._props.account_recovery_request)}static marshal(e){Object.assign(e,{type:Pu.TYPE_ACCOUNT_ACCOUNT_RECOVERY})}static getSchema(){const e=Eu.getSchema(),t=Ru.getSchema();return{type:"object",required:["type","domain","user_id","authentication_token_token","account_recovery_request_id"],properties:{...e.properties,type:{type:"string",pattern:`^${Pu.TYPE_ACCOUNT_ACCOUNT_RECOVERY}$`},account_recovery_request_id:{type:"string",format:"uuid"},authentication_token_token:t.properties.token,account_recovery_request:Xt.getSchema()}}}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,delete t.authentication_token_token,delete t.account_recovery_request_id,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.authentication_token_token&&(t.authentication_token_token=this.authenticationTokenToken),e.account_recovery_request_id&&(t.account_recovery_request_id=this.accountRecoveryRequestId),e.security_token&&this._security_token&&(t.security_token=this._security_token.toDto()),e.accountRecoveryRequest&&this._account_recovery_request&&(t.account_recovery_request=this._account_recovery_request.toDto(Xt.ALL_CONTAIN_OPTIONS)),t):t}toAbortRecoverDto(){return{authentication_token:{token:this.authenticationTokenToken}}}toCompleteRecoverDto(){return{authenticationtoken:{token:this.authenticationTokenToken},authentication_token:{token:this.authenticationTokenToken},gpgkey:{armored_key:this.userPublicArmoredKey},user:{locale:this.locale},locale:this.locale,account_recovery_request_id:this.accountRecoveryRequestId}}get authenticationTokenToken(){return this._props.authentication_token_token||null}get accountRecoveryRequestId(){return this._props.account_recovery_request_id||null}set accountRecoveryRequestId(e){se.validateProp("account_recovery_request_id",e,Pu.getSchema().properties.account_recovery_request_id),this._props.account_recovery_request_id=e}get accountRecoveryRequest(){return this._account_recovery_request||null}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,authentication_token_token:!0,account_recovery_request_id:!0,security_token:!0,account_recovery_request:!0}}static get ENTITY_NAME(){return"AccountAccountRecovery"}static get TYPE_ACCOUNT_ACCOUNT_RECOVERY(){return"account-account-recovery"}}const Uu=Pu;const xu=class{constructor(e,t,r,s){this.worker=e,this.requestId=r,this.account=s,this.accountModel=new _u(t),this.accountRecoveryModel=new oi(t),this.accountRecoveryRequestService=new zs(t)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=this.account.toAccountRecoveryRequestDto(),t=new Ou(e),r=await this.accountRecoveryRequestService.create(t),s=this.account.toDto(Nu.ALL_CONTAIN_OPTIONS);s.account_recovery_request_id=r.id;const i=new Uu(s);await Tu.deleteByUserIdAndType(i.userId,Uu.TYPE_ACCOUNT_ACCOUNT_RECOVERY),await Tu.add(i)}};const Mu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.account=s}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t={name:"Account recovery request key",email:this.account?.username,passphrase:e?.passphrase,keySize:4096,date:await Zi.getDate(this.apiClientOptions)},r=new Fs(t),s=await to.generateKeyPair(r),i=await M(s.publicKey.armoredKey);this.account.userPrivateArmoredKey=s.privateKey.armoredKey,this.account.userPublicArmoredKey=s.publicKey.armoredKey,this.account.userKeyFingerprint=i.getFingerprint().toUpperCase()}};const Lu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=r,this.runtimeMemory=s,this.runtimeMemory.passphrase=null}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=this.account?.userPrivateArmoredKey;if(!t)throw new Error("An account user private key is required.");if("string"!=typeof e)throw new TypeError("The passphrase should be a string.");const r=await M(t);await Ii.decrypt(r,e),this.runtimeMemory.passphrase=e}};const Du=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r,this.legacyAuthModel=new At}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await M(e);O(t),await this._assertImportKeyOwnedByUser(t.getFingerprint().toUpperCase()),this.account.userPrivateArmoredKey=t.armor(),this.account.userPublicArmoredKey=t.toPublic().armor()}async _assertImportKeyOwnedByUser(e){const t=this.account.domain,r=this.account.serverPublicArmoredKey;if(!r)throw new Error("The server public key should have been provided before importing a private key");try{await this.legacyAuthModel.verify(t,r,e)}catch(e){throw console.error(e),new le(w.t("This key does not match any account."))}}};const Fu=class{constructor(e){this.setupService=new ri(e),this.userService=new Re(e)}async startSetup(e,t){let r,s,i,o;if(!J().isUUID(e))throw new TypeError("userId should be a valid uuid.");if(!J().isUUID(t))throw new TypeError("authenticationTokenToken should be a valid uuid.");try{const r=await this.setupService.findSetupInfo(e,t);i=r?.user,o=r?.account_recovery_organization_policy}catch(r){const s=r.data&&r.data.code;if(404!==s&&500!==s)throw r;i=await this.setupService.findLegacySetupInfo(e,t)}return i&&(r=new sr(i)),o&&(s=new Gs(o)),{user:r,accountRecoveryOrganizationPolicy:s}}async startRecover(e,t){let r,s,i,o;if(!J().isUUID(e))throw new TypeError("userId should be a valid uuid.");if(!J().isUUID(t))throw new TypeError("authenticationTokenToken should be a valid uuid.");try{const r=await this.setupService.findRecoverInfo(e,t);i=r?.user,o=r?.account_recovery_organization_policy}catch(r){const s=r.data&&r.data.code;if(404!==s&&500!==s)throw r;i=await this.setupService.findLegacyRecoverInfo(e,t)}return i&&(r=new sr(i)),o&&(s=new Gs(o)),{user:r,accountRecoveryOrganizationPolicy:s}}async completeSetup(e){const t=e.toCompleteSetupDto();await this.setupService.complete(e.userId,t)}async completeRecover(e){const t=e.toCompleteRecoverDto();await this.setupService.completeRecover(e.userId,t)}async abortRecover(e){const t=e.toAbortRecoverDto();await this.setupService.abort(e.userId,t)}};const qu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.authModel=new Lo(r),this.setupModel=new Fu(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this._findAndSetAccountServerPublicKey(),await this._findAndSetAccountUserMeta()}catch(e){this._handleUnexpectedError(e)}}async _findAndSetAccountServerPublicKey(){const e=await this.authModel.getServerKey(),t=await M(e.armored_key);k(t),this.account.serverPublicArmoredKey=t.armor()}async _findAndSetAccountUserMeta(){const{user:e}=await this.setupModel.startRecover(this.account.userId,this.account.authenticationTokenToken);this.account.username=e?.username,this.account.firstName=e?.profile?.firstName,this.account.lastName=e?.profile?.lastName,e?.locale&&(this.account.locale=e.locale),e?.accountRecoveryUserSetting?.status===tr.STATUS_APPROVED&&(this.account.hasApprovedAccountRecoveryUserSetting=!0),this.account.user=e}_handleUnexpectedError(e){throw gi.get("RecoverBootstrap",this.worker.tab.id).port.emit("passbolt.recover-bootstrap.remove-iframe"),console.error(e),e}};class Ku extends Eu{constructor(e){Ku.marshal(e),super(se.validate(Ku.ENTITY_NAME,e,Ku.getSchema()))}static marshal(e){Object.assign(e,{type:Ku.TYPE_ACCOUNT})}static getSchema(){return{type:"object",required:["type","domain","user_id","username","first_name","last_name","user_public_armored_key","user_private_armored_key","server_public_armored_key","security_token"],properties:{...Eu.getSchema().properties,type:{type:"string",pattern:`^${Ku.TYPE_ACCOUNT}$`}}}}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.security_token&&this._security_token&&(t.security_token=this._security_token.toDto()),t):t}toLegacyUserDto(){return{id:this.userId,username:this.username,firstname:this.firstName,lastname:this.lastName,locale:this.locale}}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,security_token:!0}}static get ENTITY_NAME(){return"Account"}static get TYPE_ACCOUNT(){return"Account"}}const $u=Ku;const ju=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.accountModel=new _u(r),this.setupModel=new Fu(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=new $u(this.account.toDto(Nu.ALL_CONTAIN_OPTIONS));await this.setupModel.completeRecover(this.account),await this.accountModel.add(e),Qd.pageMods.WebIntegration._pageMod||Qd.pageMods.WebIntegration.init(),Qd.pageMods.AuthBootstrap.init(),Qd.pageMods.PublicWebsiteSignIn._pageMod||Qd.pageMods.PublicWebsiteSignIn.init()}};const Bu=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await M(e);I(t);const r=await de.getKeyInfo(t);if(r.isValid||console.warn("The private key should be a valid openpgp key."),r.revoked)throw new Error(w.t("The private key should not be revoked."));if(r.isExpired)throw new Error(w.t("The private key should not be expired."))}};const Gu=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.recoverModel=new Fu(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.recoverModel.abortRecover(this.account)}};const Yu=class{constructor(e,t,r,s,i){this.worker=e,this.requestId=t,this.account=s,this.authModel=new Lo(r),this.runtimeMemory=i,this.updateSsoCredentialsService=new Xn(r),this.checkPassphraseService=new kn(new ge)}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e=!1){if(void 0===this.runtimeMemory.passphrase)throw new Error("A passphrase is required.");if("string"!=typeof this.runtimeMemory.passphrase)throw new Error("The passphrase should be a string.");if(void 0!==e&&"boolean"!=typeof e)throw new Error("The rememberMe should be a boolean.");await this.checkPassphraseService.checkPassphrase(this.runtimeMemory.passphrase),await this.updateSsoCredentialsService.forceUpdateSsoKit(this.runtimeMemory.passphrase),await this.authModel.login(this.runtimeMemory.passphrase,e),await this.redirectToApp()}async redirectToApp(){const e=this.account.domain;u.tabs.update(this.worker.tab.id,{url:e})}};class zu extends Te{constructor(e){super(e,zu.RESOURCE_NAME)}static get RESOURCE_NAME(){return"account/settings"}async findAll(){return this.apiClient.findAll().body}async findAllThemes(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/themes`);return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}async updateTheme(e){const t={value:e},r=this.apiClient.buildBody(t),s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/themes`);return(await this.apiClient.fetchAndHandleResponse("POST",s,r)).body}async updateLocale(e){const t={value:e},r=this.apiClient.buildBody(t),s=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/locales`);return(await this.apiClient.fetchAndHandleResponse("POST",s,r)).body}}const Vu=zu;class Hu extends X{constructor(e){super(se.validate(Hu.ENTITY_NAME,e,Hu.getSchema()))}static getSchema(){return{type:"object",required:["locale"],properties:{locale:{type:"string",pattern:/^[a-z]{2}-[A-Z]{2}$/},label:{type:"string"}}}}get locale(){return this._props.locale}get label(){return this._props.label}static get ENTITY_NAME(){return"Locale"}}const Wu=Hu;class Ju extends Ct{constructor(e){super(se.validate(Ju.ENTITY_NAME,e,Ju.getSchema())),this._props.forEach((e=>{this._items.push(new Wu(e))})),this._props=null}static getSchema(){return{type:"array",items:Wu.getSchema()}}get locales(){return this._items}push(e){if(!e||"object"!=typeof e)throw new TypeError("LocalesCollection push parameter should be an object.");e instanceof Wu&&(e=e.toDto());const t=new Wu(e);super.push(t)}static get ENTITY_NAME(){return"Locales"}}const Qu=Ju;class Zu{static get DEFAULT_LOCALE(){return new Wu({locale:"en-UK",label:"English"})}static get DEFAULT_SUPPORTED_LOCALES(){return new Qu([Zu.DEFAULT_LOCALE])}constructor(e){this.accountSettingsService=new Vu(e),this.organizationSettingsModel=new st(e)}async initializeI18next(e){const t=(await this.getSupportedOrganizationLocales()).locales.map((e=>e.locale));w.init(e.locale,t)}async getOrganizationLocale(){const e=await this.organizationSettingsModel.getOrFind();return this.getSupportedLocale(e.locale)}async getSupportedOrganizationLocales(){const e=await this.organizationSettingsModel.getOrFind();if(e.isPluginEnabled("locale")){const t=e.getPluginSettings("locale");return new Qu(t.options||[])}return Zu.DEFAULT_SUPPORTED_LOCALES}async getSupportedLocale(e){return(await this.getSupportedOrganizationLocales()).locales.find((t=>t.locale===e))}async getLocaleWithSimilarLanguage(e){const t=e.split("-")[0];return(await this.getSupportedOrganizationLocales()).locales.find((e=>t===e.locale.split("-")[0]))}async updateUserLocale(e){await this.accountSettingsService.updateLocale(e.locale),z("user.settings.locale",e.locale)}}const Xu=Zu;const ep=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.localeModel=new Xu(r),this.account=s}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this.localeModel.getSupportedLocale(e.locale);if(!t)throw new Error("Unsupported locale.");this.account.locale=t.locale,await this.localeModel.initializeI18next(t)}};const tp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.organizationSettingsModel=new st(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.organizationSettingsModel.getOrFind(!0)}};const rp=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.account=s,this.localeModel=new Xu(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){let e;this.account.locale&&(e=await this.localeModel.getSupportedLocale(this.account.locale));const t=e||await this.localeModel.getOrganizationLocale()||Xu.DEFAULT_LOCALE;return this.localeModel.initializeI18next(t),t}};const sp=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return-1!==this.worker.tab.url.indexOf("first-install")}};const ip=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return"lost-passphrase"===new URL(this.worker.tab.url).searchParams.get("case")}};const op=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(e){try{this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){this.account.securityToken=new wu(e)}};const np=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return!0===this.account?.user?.accountRecoveryUserSetting?.isApproved}},ap={listen:(e,t,r)=>{const s={};e.port.on("passbolt.recover.first-install",(async t=>{const r=new sp(e,t);await r._exec()})),e.port.on("passbolt.recover.lost-passphrase-case",(async t=>{const r=new ip(e,t);await r._exec()})),e.port.on("passbolt.organization-settings.get",(async r=>{const s=new tp(e,r,t);await s._exec()})),e.port.on("passbolt.recover.start",(async s=>{const i=new qu(e,s,t,r);await i._exec()})),e.port.on("passbolt.locale.get",(async s=>{const i=new rp(e,s,t,r);await i._exec()})),e.port.on("passbolt.locale.update-user-locale",(async(s,i)=>{const o=new ep(e,s,t,r);await o._exec(i)})),e.port.on("passbolt.recover.has-user-enabled-account-recovery",(async t=>{const s=new np(e,t,r);await s._exec()})),e.port.on("passbolt.recover.import-key",(async(t,s)=>{const i=new Du(e,t,r);await i._exec(s)})),e.port.on("passbolt.recover.verify-passphrase",(async(t,i)=>{const o=new Lu(e,t,r,s);await o._exec(i)})),e.port.on("passbolt.recover.set-security-token",(async(t,s)=>{const i=new op(e,t,r);await i._exec(s)})),e.port.on("passbolt.recover.complete",(async s=>{const i=new ju(e,s,t,r);await i._exec()})),e.port.on("passbolt.recover.sign-in",(async(i,o)=>{const n=new Yu(e,i,t,r,s);await n._exec(o)})),e.port.on("passbolt.recover.generate-account-recovery-request-key",(async(s,i)=>{const o=new Mu(e,s,t,r);await o._exec(i)})),e.port.on("passbolt.recover.initiate-account-recovery-request",(async s=>{const i=new xu(e,t,s,r);await i._exec()})),e.port.on("passbolt.keyring.get-key-info",(async(t,r)=>{const s=new Zc(e,t);await s._exec(r)})),e.port.on("passbolt.recover.validate-private-key",(async(t,r)=>{const s=new Bu(e,t);await s._exec(r)})),e.port.on("passbolt.recover.request-help-credentials-lost",(async s=>{const i=new Gu(e,s,t,r);await i._exec()}))}};const cp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.resourceModel=new Ns(r),this.folderModel=new Sa(r),this.keyring=new ge,this.progressService=new ji(this.worker,w.t("Creating password"))}async main(e,t){let r,s=new Ar(e);const i=s.folderParentId?10:2;try{const e=await Li.get(this.worker);r=await Mo.getKey(e)}catch(e){throw console.error(e),e}try{this.progressService.start(i,w.t("Initializing"));const e=await this.resourceModel.serializePlaintextDto(s.resourceTypeId,t);await this.progressService.finishStep(w.t("Encrypting secret"),!0);const o=Ye.getInstance().get().id,n=this.keyring.findPublic(o).armoredKey,a=await M(n),c=await ye.encrypt(e,a,[r]);s.secrets=new vr([{data:c}]),await this.progressService.finishStep(w.t("Creating password"),!0),s=await this.resourceModel.create(s),s.folderParentId&&await this.handleCreateInFolder(s,r)}catch(e){throw console.error(e),await this.progressService.close(),e}return await this.progressService.finishStep(w.t("Done!"),!0),await this.progressService.close(),s}async handleCreateInFolder(e,t){await this.progressService.finishStep(w.t("Calculate permissions"),!0);const r=await this.folderModel.findForShare(e.folderParentId),s=await this.resourceModel.calculatePermissionsChangesForCreate(e,r);if(s.length){const r=3*s.length+2+this.progressService.progress;this.progressService.updateGoals(r),await this.progressService.finishStep(w.t("Synchronizing keys"),!0),await this.keyring.sync(),await this.progressService.finishStep(w.t("Start sharing"),!0);const i=[e.toDto({secrets:!0})];await pc.bulkShareResources(i,s.toDto(),t,(async e=>await this.progressService.finishStep(e))),await this.resourceModel.updateLocalStorage()}}};const up=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.resourceModel=new Ns(r),this.userModel=new Gn(r),this.keyring=new ge,this.progressService=new ji(this.worker,w.t("Updating password"))}async main(e,t){const r=new Ar(e);return null===t?await this.updateResourceMetaOnly(r):await this.updateResourceAndSecret(r,t)}async updateResourceMetaOnly(e){this.progressService.start(1,w.t("Updating password"));const t=await this.resourceModel.update(e);return await this.progressService.finishStep(w.t("Done!"),!0),await this.progressService.close(),t}async updateResourceAndSecret(e,t){const r=await this.getPrivateKey();try{this.progressService.start(4,w.t("Updating password"));const s=await this.userModel.findAllIdsForResourceUpdate(e.id),i=s.length+3;this.progressService.updateGoals(i),await this.progressService.finishStep(w.t("Synchronizing keyring"),!0),await this.keyring.sync();const o=await this.resourceModel.serializePlaintextDto(e.resourceTypeId,t);e.secrets=await this.encryptSecrets(o,s,r),await this.progressService.finishStep(w.t("Saving resource"),!0);const n=await this.resourceModel.update(e);return await this.progressService.finishStep(w.t("Done!"),!0),await this.progressService.close(),n}catch(e){throw await this.progressService.close(),e}}async getPrivateKey(){try{const e=await Li.get(this.worker);return Mo.getKey(e)}catch(e){throw console.error(e),e}}async encryptSecrets(e,t,r){const s=[];for(let i=0;i<t.length;i++)if(Object.prototype.hasOwnProperty.call(t,i)){const o=t[i],n=this.keyring.findPublic(o).armoredKey,a=await M(n),c=await ye.encrypt(e,a,[r]);s.push({user_id:o,data:c}),await this.progressService.finishStep(w.t("Encrypting"),!0)}return new vr(s)}},pp={listen:function(e){e.port.on("passbolt.resources.update-local-storage",(async t=>{Le.write({level:"debug",message:"ResourceEvent listen passbolt.resources.update-local-storage"});try{const r=await Ye.getInstance().getApiClientOptions();new Ns(r).updateLocalStorage(),e.port.emit(t,"SUCCESS")}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.resources.find-all",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Ns(s),{contains:o,filters:n,orders:a}=r,c=await i.findAll(o,n,a);e.port.emit(t,"SUCCESS",c)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.resources.find-permissions",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Ns(s),o=await i.findResourcePermissions(r);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.resources.create",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new cp(e,t,i),n=await o.main(r,s);e.port.emit(t,"SUCCESS",n)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.resources.delete-all",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Ns(s);await i.bulkDelete(r),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.resources.update",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new up(e,t,i),n=await o.main(r,s);e.port.emit(t,"SUCCESS",n)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}},lp={listen:function(e){e.port.on("passbolt.resource-type.get-all",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new fs(r),i=await s.getOrFindAll();e.port.emit(t,"SUCCESS",i)}catch(r){e.port.emit(t,"ERROR",r)}}))}};class dp extends Te{constructor(e){super(e,dp.RESOURCE_NAME)}static get RESOURCE_NAME(){return"roles"}async findAll(){const e=await this.apiClient.findAll();return e.body&&e.body.length?e.body:[]}}const hp=dp;const gp=class{constructor(e){this.roleService=new hp(e)}async updateLocalStorage(){const e=await this.roleService.findAll(),t=new as(e);return await ls.set(t),t}async getOrFindAll(){const e=await ls.get();return void 0!==e?new as(e):this.updateLocalStorage()}},yp={listen:function(e){e.port.on("passbolt.role.get-all",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new gp(r),i=await s.getOrFindAll();e.port.emit(t,"SUCCESS",i)}catch(r){e.port.emit(t,"ERROR",r)}}))}};class _p extends Error{constructor(e){super(e=e||w.t("The external service is unavailable")),this.name="ExternalServiceUnavailableError"}}const mp=_p;class wp extends Error{constructor(e){super(e=e||w.t("The external service raised an error")),this.name="ExternalServiceError"}}const fp=wp;const Ep=class{static async checkIfPasswordIsPowned(e){if("string"!=typeof e){const e=new Error("Input password must be a string.");return Promise.reject(e)}const t=new L.Z("SHA-1","TEXT");t.update(e);const r=t.getHash("HEX"),s=r.substr(0,5),i=r.substr(5),o="https://api.pwnedpasswords.com/range/"+s;let n;try{n=await fetch(o)}catch(e){throw new mp("pwnedpasswords API service is not available")}if(200!==n.status)throw new fp(`Failed to request pwnedpasswords API: ${n.status}`);return(await n.text()).split("\n").map((e=>e.split(":"))).filter((e=>e[0].toLowerCase()===i)).map((e=>Number(e[1]))).shift()||0}};const Sp=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{const t=await this.exec(e);this.worker.port.emit(this.requestId,"SUCCESS",t)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){return Ep.checkIfPasswordIsPowned(e)}},vp={listen:function(e){e.port.on("passbolt.secret.decrypt",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions();let o=!0;s&&Object.prototype.hasOwnProperty.call(s,"showProgress")&&(o=s.showProgress);const n=new su(e,t,i),{plaintext:a}=await n.main(r,o);e.port.emit(t,"SUCCESS",a)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.secrets.powned-password",(async(t,r)=>{const s=new Sp(e,t);await s._exec(r)}))}};const bp=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=r,this.runtimeMemory=s}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){let t;t=e===tr.STATUS_APPROVED?await this.buildApprovedUserSetting():await this.buildRejectedUserSetting(),this.account.accountRecoveryUserSetting=t}async buildApprovedUserSetting(){if(!this?.runtimeMemory?.passphrase)throw new Error("A passphrase is required.");const e=await M(this.account.userPrivateArmoredKey),t=await Ii.decrypt(e,this.runtimeMemory.passphrase),r=this.runtimeMemory.accountRecoveryOrganizationPolicy;return oo.build(this.account,t,r)}async buildRejectedUserSetting(){const e={user_id:this.account.userId,status:tr.STATUS_REJECTED};return new tr(e)}};const Ap=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r,this.legacyAuthModel=new At}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await M(e);O(t);const r=t.getFingerprint().toUpperCase();await this._assertImportKeyNotUsed(r),this.account.userKeyFingerprint=r,this.account.userPrivateArmoredKey=t.armor(),this.account.userPublicArmoredKey=t.toPublic().armor()}async _assertImportKeyNotUsed(e){const t=this.account.domain,r=this.account.serverPublicArmoredKey;if(!r)throw new Error("The server public key should have been provided before importing a private key");let s=!1;try{await this.legacyAuthModel.verify(t,r,e),s=!0}catch(e){}if(s)throw new le(w.t("This key is already used by another user."))}};const Tp=class{constructor(e,t,r,s,i){this.worker=e,this.requestId=t,this.account=s,this.authModel=new Lo(r),this.setupModel=new Fu(r),this.runtimeMemory=i}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this._findAndSetAccountSetupServerPublicKey(),await this._findAndSetAccountSetupMeta()}catch(e){this._handleUnexpectedError(e)}}async _findAndSetAccountSetupServerPublicKey(){const e=await this.authModel.getServerKey(),t=await M(e.armored_key);k(t),this.account.serverPublicArmoredKey=t.armor()}async _findAndSetAccountSetupMeta(){const{user:e,accountRecoveryOrganizationPolicy:t}=await this.setupModel.startSetup(this.account.userId,this.account.authenticationTokenToken);this.account.username=e?.username,this.account.firstName=e?.profile.firstName,this.account.lastName=e?.profile.lastName,this.account.user=e,t&&(this.runtimeMemory.accountRecoveryOrganizationPolicy=t)}_handleUnexpectedError(e){throw gi.get("SetupBootstrap",this.worker.tab.id).port.emit("passbolt.setup-bootstrap.remove-iframe"),e}};const Ip=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){if(!this.account?.userPrivateArmoredKey)throw new Error("An account user private armored key is required.");const e=this.account.userPrivateArmoredKey;await ho.saveFile("passbolt-recovery-kit.asc",e,"text/plain",this.worker.tab.id)}};class Rp extends Eu{constructor(e){Rp.marshal(e),super(se.validate(Rp.ENTITY_NAME,e,Rp.getSchema())),this._props.account_recovery_user_setting&&(this._account_recovery_user_setting=new tr(this._props.account_recovery_user_setting),delete this._props.account_recovery_user_setting)}static marshal(e){Object.assign(e,{type:Rp.TYPE_ACCOUNT_SETUP})}static getSchema(){const e=Eu.getSchema(),t=Ru.getSchema();return{type:"object",required:["type","domain","user_id","authentication_token_token"],properties:{...e.properties,type:{type:"string",pattern:`^${Rp.TYPE_ACCOUNT_SETUP}$`},authentication_token_token:t.properties.token,user:sr.getSchema(),account_recovery_user_setting:tr.getSchema()}}}toDto(e={}){const t=Object.assign({},this._props);return delete t.user_private_armored_key,delete t.authentication_token_token,e?(e.user_private_armored_key&&(t.user_private_armored_key=this.userPrivateArmoredKey),e.authentication_token_token&&(t.authentication_token_token=this.authenticationTokenToken),e.security_token&&this._security_token&&(t.security_token=this._security_token.toDto()),e.user&&this._user&&(t.user=this._user.toDto(sr.ALL_CONTAIN_OPTIONS)),t):t}toCompleteSetupDto(){return{authenticationtoken:{token:this.authenticationTokenToken},authentication_token:{token:this.authenticationTokenToken},gpgkey:{armored_key:this.userPublicArmoredKey},user:{locale:this.locale},locale:this.locale,account_recovery_user_setting:this.accountRecoveryUserSetting?.toDto(tr.ALL_CONTAIN_OPTIONS)}}get authenticationTokenToken(){return this._props.authentication_token_token||null}get user(){return this._user||null}set user(e){if(!(e&&e instanceof sr))throw new TypeError("Failed to assert the parameter is a valid UserEntity");this._user=e}get accountRecoveryUserSetting(){return this._account_recovery_user_setting||null}set accountRecoveryUserSetting(e){if(!(e&&e instanceof tr))throw new TypeError("Failed to assert the parameter is a valid AccountRecoveryUserSettingEntity");this._account_recovery_user_setting=e}static get ALL_CONTAIN_OPTIONS(){return{user_private_armored_key:!0,security_token:!0,authentication_token_token:!0,user:!0}}static get ENTITY_NAME(){return"AccountSetup"}static get TYPE_ACCOUNT_SETUP(){return"account-setup"}}const Cp=Rp;const Op=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.accountModel=new _u(r),this.setupModel=new Fu(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){const e=new $u(this.account.toDto(Cp.ALL_CONTAIN_OPTIONS));await this.setupModel.completeSetup(this.account),await this.accountModel.add(e),this.initPagemods()}initPagemods(){Qd.pageMods.WebIntegration._pageMod||Qd.pageMods.WebIntegration.init(),Qd.pageMods.AuthBootstrap.init(),Qd.pageMods.PublicWebsiteSignIn._pageMod||Qd.pageMods.PublicWebsiteSignIn.init()}};class kp{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await M(e);O(t),I(t);const r=await de.getKeyInfo(t);if(!r.isValid)throw new Error(w.t("The private key should be a valid openpgp key."));if(r.revoked)throw new Error(w.t("The private key should not be revoked."));if(r.isExpired)throw new Error(w.t("The private key should not be expired."));if("Infinity"!==r.expires)throw new Error(w.t("The private key should not have an expiry date."));if(r.algorithm===Fs.TYPE_RSA){if(r.length<Fs.DEFAULT_KEY_SIZE)throw new Error(w.t("An RSA key should have a length of {{size}} bits minimum.",{size:Fs.DEFAULT_KEY_SIZE}))}else{if(!r.curve)throw new Error(w.t("The private key should use a supported algorithm: RSA, ECDSA OR EDDSA."));if(!kp._isCurveSupported(r.curve))throw new Error(w.t("An ECC key should be based on a supported curve."))}}static _isCurveSupported(e){return["p256","p384","p521","secp256k1","ed25519","curve25519","brainpoolP256r1","brainpoolP384r1","brainpoolP512r1"].indexOf(e)>-1}}const Np=kp;const Pp=class{constructor(e,t,r,s,i){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.account=s,this.runtimeMemory=i,this.runtimeMemory.passphrase=null}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=await this._buildGenerateKeyPairOptionsEntity(e.passphrase),r=await to.generateKeyPair(t),s=await M(r.publicKey.armoredKey);this.account.userKeyFingerprint=s.getFingerprint().toUpperCase(),this.account.userPrivateArmoredKey=r.privateKey.armoredKey,this.account.userPublicArmoredKey=r.publicKey.armoredKey,this.runtimeMemory.passphrase=e.passphrase}async _buildGenerateKeyPairOptionsEntity(e){return new Fs({name:`${this.account.firstName} ${this.account.lastName}`,email:this.account.username,passphrase:e,date:await Zi.getDate(this.apiClientOptions)})}};const Up=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.localeModel=new Xu(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){if(!this.account.locale){const e=await this.localeModel.getSupportedLocale(navigator.language)||await this.localeModel.getLocaleWithSimilarLanguage(navigator.language)||await this.localeModel.getOrganizationLocale()||Xu.DEFAULT_LOCALE;this.account.locale=e.locale}const e=new Wu({locale:this.account.locale});return this.localeModel.initializeI18next(e),e}};const xp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.runtimeMemory=r}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.runtimeMemory.accountRecoveryOrganizationPolicy}},Mp={listen:function(e,t,r){const s={};e.port.on("passbolt.setup.is-first-install",(async t=>{const r=new sp(e,t);await r._exec()})),e.port.on("passbolt.organization-settings.get",(async r=>{const s=new tp(e,r,t);await s._exec()})),e.port.on("passbolt.setup.start",(async i=>{const o=new Tp(e,i,t,r,s);await o._exec()})),e.port.on("passbolt.setup.get-and-init-locale",(async s=>{const i=new Up(e,s,t,r);await i._exec()})),e.port.on("passbolt.setup.update-locale",(async(s,i)=>{const o=new ep(e,s,t,r);await o._exec(i)})),e.port.on("passbolt.setup.generate-key",(async(i,o)=>{const n=new Pp(e,i,t,r,s);await n._exec(o)})),e.port.on("passbolt.setup.download-recovery-kit",(async t=>{const s=new Ip(e,t,r);await s._exec()})),e.port.on("passbolt.setup.get-account-recovery-organization-policy",(async t=>{const r=new xp(e,t,s);await r._exec()})),e.port.on("passbolt.setup.set-account-recovery-user-setting",(async(t,i)=>{const o=new bp(e,t,r,s);await o._exec(i)})),e.port.on("passbolt.setup.import-key",(async(t,s)=>{const i=new Ap(e,t,r);await i._exec(s)})),e.port.on("passbolt.setup.verify-passphrase",(async(t,i)=>{const o=new Lu(e,t,r,s);await o._exec(i)})),e.port.on("passbolt.setup.set-security-token",(async(t,s)=>{const i=new op(e,t,r);await i._exec(s)})),e.port.on("passbolt.setup.complete",(async i=>{const o=new Op(e,i,t,r,s);await o._exec()})),e.port.on("passbolt.keyring.get-key-info",(async(t,r)=>{const s=new Zc(e,t);await s._exec(r)})),e.port.on("passbolt.setup.sign-in",(async(i,o)=>{const n=new Yu(e,i,t,r,s);await n._exec(o)})),e.port.on("passbolt.setup.validate-private-key",(async(t,r)=>{const s=new Np(e,t);await s._exec(r)}))}};const Lp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.clientOptions=r,this.resourceModel=new Ns(r),this.progressService=new ji(this.worker)}async main(e,t){const r=new ge;let s;const i=3*e.length+1;try{const e=await Li.get(this.worker);s=await Mo.getKey(e)}catch(e){throw console.error(e),e}try{this.progressService.title=w.t("Share {{count}} password",{count:e.length}),this.progressService.start(i,w.t("Initialize")),await this.progressService.finishStep(w.t("Synchronizing keys"),!0),await r.sync(),await pc.bulkShareResources(e,t,s,(async e=>{await this.progressService.finishStep(e)})),await this.resourceModel.updateLocalStorage();const o=e.map((e=>e.id));return await this.progressService.finishStep(w.t("Done!"),!0),await this.progressService.close(),o}catch(e){throw console.error(e),await this.progressService.close(),e}}};const Dp=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.folderModel=new Sa(r),this.resourceModel=new Ns(r),this.keyring=new ge,this.folders=null,this.folder=null,this.subFolders=null,this.resources=null,this.originalChanges=null,this.foldersChanges=new bs([]),this.resourcesChanges=new bs([]),this.passphrase=null,this.privateKey=null,this.progressService=new ji(this.worker)}async main(e,t){this.assertValidParameters(e,t);try{await this.getPassphrase()}catch(e){throw this.cleanup(),e}try{this.progressService.title=w.t("Sharing folder {{name}}",{name:this.folder.name}),this.progressService.start(null,w.t("Initializing ...")),await this.findAllForShare(),this.progressService.updateGoals(this.getGoals()),await this.progressService.finishStep(w.t("Calculating changes..."),!0),this.calculateChanges(),await this.share(),await this.progressService.finishStep(w.t("Done"),!0),await this.progressService.close(),this.cleanup()}catch(e){throw await this.progressService.close(),this.cleanup(),e}}assertValidParameters(e,t){if(!e||e.length>1)throw new Error("Sharing multiple folders at once is not supported");if(!t||!t.length)throw new Error("ShareFoldersController, invalid request changes can not be empty.");if(this.folders=e,this.folder=e.items[0],this.originalChanges=t,!this.folder.isOwner())throw new Error(w.t("The folder cannot be shared. Insufficient rights."))}async getPassphrase(){const e=await Li.get(this.worker);this.privateKey=await Mo.getKey(e)}async findAllForShare(){this.subFolders=await this.folderModel.getAllChildren([this.folder.id]),this.resources=await this.resourceModel.getAllByParentIds([this.folder.id,...this.subFolders.ids]),this.resources=this.resources.getAllWhereOwner(),this.subFolders=this.subFolders.getAllWhereOwner(),this.resources.length&&(this.resources=await this.resourceModel.findAllForShare(this.resources.ids)),this.subFolders.length&&(this.subFolders=await this.folderModel.findAllForShare(this.subFolders.ids))}getGoals(){return 3+2*this.subFolders.length+4*this.resources.length}calculateChanges(){this.foldersChanges.merge(this.originalChanges);for(const e of this.subFolders)this.foldersChanges.merge(bs.reuseChanges(e.permission.aco,e.id,e.permissions,this.originalChanges,this.folder.permissions));for(const e of this.resources)this.resourcesChanges.merge(bs.reuseChanges(e.permission.aco,e.id,e.permissions,this.originalChanges,this.folder.permissions))}async share(){if(this.foldersChanges.length){const e=new zr([this.folder]);e.merge(this.subFolders),await pc.bulkShareFolders(e,this.foldersChanges,this.folderModel,(async e=>{await this.progressService.finishStep(e)}))}if(this.resourcesChanges.length){const e=this.resources.toDto({secrets:!0}),t=this.resourcesChanges.toDto();await this.progressService.finishStep(w.t("Synchronizing keys"),!0),await this.keyring.sync(),await pc.bulkShareResources(e,t,this.privateKey,(async e=>{await this.progressService.finishStep(e)})),await this.resourceModel.updateLocalStorage()}}cleanup(){this.privateKey=null}},Fp={listen:function(e){e.port.on("passbolt.share.search-aros",(async(t,r,s)=>{let i;try{i=await pc.searchAros(r)}catch(o){s.resourcesIds&&1===s.resourcesIds.length?i=await pc.searchResourceAros(s.resourcesIds[0],r):e.port.emit(t,"ERROR",o)}e.port.emit(t,"SUCCESS",i)})),e.port.on("passbolt.share.get-resources",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Ns(s),o=await i.findAllForShare(r);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.share.get-folders",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Sa(s),o=await i.findAllForShare(r);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.share.resources.save",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Lp(e,t,i);await o.main(r,s),e.port.emit(t,"SUCCESS")}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.share.folders.save",(async(t,r,s)=>{try{const i=new zr(r),o=new bs(s),n=await Ye.getInstance().getApiClientOptions(),a=new Dp(e,t,n);await a.main(i,o),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};class qp extends Te{constructor(e){super(e,qp.RESOURCE_NAME)}static get RESOURCE_NAME(){return"ee/subscription"}async find(){return(await this.apiClient.get("key")).body}async update(e){return(await this.apiClient.update("key",e)).body}}const Kp=qp;class $p extends X{constructor(e){super(se.validate($p.ENTITY_NAME,e,$p.getSchema()))}static getSchema(){return{type:"object",required:["subscription_id","users","expiry","created","data"],properties:{customer_id:{type:"string"},subscription_id:{type:"string"},users:{type:"integer"},email:{type:"string",format:"email"},created:{type:"string"},expiry:{type:"string"},data:{type:"string"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}static get ENTITY_NAME(){return"Subscription"}}const jp=$p;class Bp extends Error{constructor(e,t={}){super(e),this.name="PassboltSubscriptionError",this.subscription=t}}const Gp=Bp;const Yp=class{constructor(e){this.subscriptionService=new Kp(e)}async find(){try{const e=await this.subscriptionService.find();return new jp(e)}catch(e){if(e.data&&402===e.data.code){const t=new jp(e.data.body);throw new Gp(e.message,t)}throw e}}async update(e){try{const t=await this.subscriptionService.update(e.toDto());return new jp(t)}catch(e){if(e.data&&402===e.data.code){const t=new jp(e.data.body);throw new Gp(e.message,t)}throw e}}};class zp extends X{constructor(e){super(se.validate(zp.ENTITY_NAME,e,zp.getSchema()))}static getSchema(){return{type:"object",required:["data"],properties:{data:{type:"string"}}}}toDto(){return Object.assign({},this._props)}toJSON(){return this.toDto()}get data(){return this._props.data}set data(e){se.validateProp("data",e,zp.getSchema().properties.data),this._props.data=e}static get ENTITY_NAME(){return"UpdateSubscription"}}const Vp=zp;const Hp=class{constructor(e,t){this.worker=e,this.subscriptionModel=new Yp(t)}async getSubscription(){return await this.subscriptionModel.find()}async updateSubscription(e){const t=new Vp(e);return await this.subscriptionModel.update(t)}},Wp={listen:function(e){e.port.on("passbolt.subscription.get",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Hp(e,r);try{const r=await s.getSubscription();e.port.emit(t,"SUCCESS",r)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.subscription.update",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Hp(e,s);try{const s=await i.updateSubscription(r);e.port.emit(t,"SUCCESS",s)}catch(r){e.port.emit(t,"ERROR",r)}}))}},Jp={listen:function(e){e.port.on("passbolt.active-tab.get-url",(async(t,r)=>{const s=r?await ru.getById(r):await ru.getCurrent();s?e.port.emit(t,"SUCCESS",s.url):e.port.emit(t,"ERROR",new Error(w.t("Unable to retrieve the active tab info.")))}))}};const Qp=class{constructor(e,t){this.worker=e,this.resourceModel=new Ns(t),this.tagModel=new Fc(t),this.progressService=new ji(this.worker,w.t("Adding tag..."))}async addTagResources(e,t){const r=2+e.length;this.progressService.start(r,w.t("Initialize"));try{const r=await this._keepResourcesTagNotPresent(e,t.id);r.length>0&&await this._taggingResources(r,t),await this.progressService.finishStep(w.t("Done!"),!0),await this.progressService.close()}catch(e){throw await this.progressService.close(),e}}async _keepResourcesTagNotPresent(e,t){await this.progressService.finishStep(w.t("Preparing..."),!0);return(await this.resourceModel.getAllByIds(e)).filterByTagNotPresent(t).map((e=>e.id))}async _taggingResources(e,t){await this.progressService.finishStep(w.t("Updating resource"),!0);const r=new wr([t]),s=e.length;let i=0;await this.tagModel.bulkTagResources(e,r,{successCallback:()=>this._handleTagResourceSuccess(s,++i),errorCallback:()=>this._handleTagResourceError(s,++i)})}async _handleTagResourceSuccess(e,t){await this.progressService.finishStep(w.t(`Tagging passwords ${t}/${e}`))}async _handleTagResourceError(e,t){await this.progressService.finishStep(w.t(`Tagging passwords ${t}/${e}`))}},Zp={listen:function(e){e.port.on("passbolt.tags.find-all",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new Fc(r),i=await s.findAll();e.port.emit(t,"SUCCESS",i)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.tags.update-resource-tags",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Fc(i),n=new wr(s),a=await o.updateResourceTags(r,n);e.port.emit(t,"SUCCESS",a)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.tags.add-resources-tag",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Qp(e,s);await i.addTagResources(r.resources,r.tag),e.port.emit(t,"SUCCESS")}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.tags.update",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Fc(s),o=new _r(r),n=await i.update(o);e.port.emit(t,"SUCCESS",n)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.tags.delete",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Fc(s);await i.delete(r),e.port.emit(t,"SUCCESS")}catch(r){e.port.emit(t,"ERROR",r)}}))}};class Xp extends X{constructor(e){super(se.validate(Xp.ENTITY_NAME,e,Xp.getSchema()))}static getSchema(){return{type:"object",required:["id","name","preview"],properties:{id:{type:"string",format:"uuid"},name:{type:"string",pattern:/^[a-zA-Z0-9-_]*$/},preview:{type:"string",format:"x-url"}}}}get id(){return this._props.id}get name(){return this._props.name}get preview(){return this._props.preview}static get ENTITY_NAME(){return"Theme"}}const el=Xp;class tl extends Ct{constructor(e){super(se.validate(tl.ENTITY_NAME,e,tl.getSchema())),this._props.forEach((e=>{this.push(new el(e))})),this._props=null}static getSchema(){return{type:"array",items:el.getSchema()}}get themes(){return this._items}assertUniqueId(e){if(!e.id)return;const t=this.items.findIndex((t=>t.id===e.id));if(-1!==t)throw new jt(t,tl.RULE_UNIQUE_ID,`Theme id ${e.id} already exists.`)}assertUniqueName(e){if(!e.name)return;const t=this.items.findIndex((t=>t.name===e.name));if(-1!==t)throw new jt(t,tl.RULE_UNIQUE_NAME,`Theme name ${e.name} already exists.`)}push(e){if(!e||"object"!=typeof e)throw new TypeError("ThemesCollection push parameter should be an object.");e instanceof el&&(e=e.toDto());const t=new el(e);this.assertUniqueId(t),this.assertUniqueName(t),super.push(t)}static get ENTITY_NAME(){return"Themes"}static get RULE_UNIQUE_ID(){return"unique_id"}static get RULE_UNIQUE_NAME(){return"unique_name"}}const rl=tl;const sl=class{constructor(e){this.accountSettingsService=new Vu(e)}async findAll(){const e=await this.accountSettingsService.findAllThemes();return new rl(e)}async change(e){await this.accountSettingsService.updateTheme(e.name),z("user.settings.theme",e.name)}};class il extends X{constructor(e){super(se.validate(il.ENTITY_NAME,e,il.getSchema()))}static getSchema(){return{type:"object",required:["name"],properties:{name:el.getSchema().properties.name}}}get name(){return this._props.name}static get ENTITY_NAME(){return"ChangeTheme"}}const ol=il,nl={listen:async function(e){e.port.on("passbolt.themes.find-all",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new sl(r),i=await s.findAll();e.port.emit(t,"SUCCESS",i)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.themes.change",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new sl(s),o=new ol({name:r});await i.change(o),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const al=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.apiClientOptions=r,this.accountModel=new _u(r),this.organisationSettingsModel=new st(r),this.ssoKitServerPartModel=new jo(r)}async _exec(e,t){try{await this.exec(e,t),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e,t){if("string"!=typeof e||"string"!=typeof t)throw new Error("The old and new passphrase have to be string");const r=(await this.organisationSettingsModel.getOrFind()).isPluginEnabled("sso"),s=await this.accountModel.rotatePrivateKeyPassphrase(e,t);r&&await this.regenerateSsoKit(t),await this.accountModel.updatePrivateKey(s),await Be.flushPassphrase(),Be.isSessionKeptUntilLogOut()&&await Be.set(t),await ho.saveFile("passbolt-recovery-kit.asc",s,"text/plain",this.worker.tab.id)}async regenerateSsoKit(e){let t;try{t=await Wo.get()}catch(e){return void console.log(e)}if(!t)return;t.isRegistered()&&await this.deleteServerPartSsoKit(t.id);const r=await Xo.generateSsoKits(e,t.provider),s=await this.ssoKitServerPartModel.setupSsoKit(r.serverPart);r.clientPart.id=s.id,await Wo.save(r.clientPart)}async deleteServerPartSsoKit(e){try{await this.ssoKitServerPartModel.deleteSsoKit(e)}catch(e){if(!(e instanceof Se&&404===e?.data?.code))throw e}}};const cl=function(e,t,r){t=t||"",r=r||512;const s=atob(e),i=[];for(let e=0;e<s.length;e+=r){const t=s.slice(e,e+r),o=new Array(t.length);for(let e=0;e<t.length;e++)o[e]=t.charCodeAt(e);const n=new Uint8Array(o);i.push(n)}return new Blob(i,{type:t})};class ul extends X{constructor(e){super(se.validate(ul.ENTITY_NAME,e,ul.getSchema())),this.file=e.file}static createFromFileBase64(e){if(!e||"object"!=typeof e)throw new TypeError("AvatarUpdateEntity createFromFileBase64 parameter should be an object.");const t=e.filename,r=e.fileBase64,s=e.mimeType,i=cl(r,s);return new ul({file:i,filename:t,mimeType:s})}static getSchema(){return{type:"object",required:["file","filename","mime"],properties:{file:{type:"blob"},filename:{type:"string"},mimeType:{type:"string"}}}}get file(){return this._props.file}set file(e){this._props.file=e}get filename(){return this._props.filename}get mimeType(){return this._props.mimeType}static get ENTITY_NAME(){return"AvatarUpdate"}}const pl=ul,ll={listen:function(e){e.port.on("passbolt.user.get",((t,r)=>{try{const s=Ye.getInstance().get(r);e.port.emit(t,"SUCCESS",s)}catch(r){e.port.emit(t,"ERROR",r.message)}})),e.port.on("passbolt.users.get-all",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new Gn(r),i=await s.getOrFindAll();e.port.emit(t,"SUCCESS",i)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.create",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Gn(s),o=new sr(r),n=await i.create(o);e.port.emit(t,"SUCCESS",n)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.find-logged-in-user",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new Gn(r),i=Ye.getInstance().get().id,o={profile:!0,role:!0,account_recovery_user_setting:!0},n=await s.findOne(i,o,!0);e.port.emit(t,"SUCCESS",n)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.update",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Gn(s),o=new sr(r),n=await i.update(o,!0);e.port.emit(t,"SUCCESS",n)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.update-avatar",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Gn(i),n=pl.createFromFileBase64(s),a=await o.updateAvatar(r,n,!0);e.port.emit(t,"SUCCESS",a)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.update-security-token",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new _u(s),o=new wu(r);await i.changeSecurityToken(o),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.user.update-private-key",(async(t,r,s)=>{const i=await Ye.getInstance().getApiClientOptions(),o=new al(e,t,i);await o._exec(r,s)})),e.port.on("passbolt.users.delete-dry-run",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Gn(i),n=s?new Bn(s):null;await o.deleteDryRun(r,n),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.delete",(async(t,r,s)=>{try{const i=await Ye.getInstance().getApiClientOptions(),o=new Gn(i),n=s?new Bn(s):null;await o.delete(r,n),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.update-local-storage",(async t=>{try{const r=new Gn(await Ye.getInstance().getApiClientOptions());await r.updateLocalStorage(),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.users.resend-invite",(async(t,r)=>{try{const s=new Gn(await Ye.getInstance().getApiClientOptions());await s.resendInvite(r),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}},dl={listen:function(e){e.port.on("passbolt.organization-settings.get",(async(t,r=!0)=>{try{const s=await Ye.getInstance().getApiClientOptions({requireCsrfToken:!1}),i=new st(s),o=await i.getOrFind(r);e.port.emit(t,"SUCCESS",o)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const hl=class{constructor(e,t){this.worker=e,this.localeModel=new Xu(t)}async getLocale(){let e;const t=await Y("user.settings.locale");t&&(e=new Wu({locale:t}));const r=e||await this.localeModel.getOrganizationLocale()||Xu.DEFAULT_LOCALE;return this.localeModel.initializeI18next(r),r}},gl={listen:function(e){e.port.on("passbolt.locale.get",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new hl(e,r);try{const r=await s.getLocale();e.port.emit(t,"SUCCESS",r)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.locale.update-user-locale",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Xu(s);try{const s=new Wu(r);await i.updateUserLocale(s),e.port.emit(t,"SUCCESS")}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};class yl extends Te{constructor(e){super(e,yl.RESOURCE_NAME)}static get RESOURCE_NAME(){return"password-generator"}async find(){const e=this.apiClient.buildUrl(`${this.apiClient.baseUrl}/settings`);return(await this.apiClient.fetchAndHandleResponse("GET",e)).body}}const _l=yl;class ml extends X{constructor(e){super(se.validate(ml.ENTITY_NAME,e,ml.getSchema()))}static getSchema(){return{type:"object",required:[],properties:{default_generator:{type:"string"},generators:{type:"object"}}}}get default_generator(){return this._props.default_generator}get generators(){return this._props.generators}static get ENTITY_NAME(){return"PasswordGenerator"}}const wl=ml,fl=[{name:"Password",type:"password",default_options:{length:18,look_alike:!0,min_length:8,max_length:128},masks:[{name:"upper",label:"A-Z",characters:["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"],active:!0},{name:"lower",label:"a-z",characters:["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],active:!0},{name:"digit",label:"0-9",characters:["0","1","2","3","4","5","6","7","8","9"],active:!0},{name:"special_char1",label:"# $ % & @ ^ ~",characters:["#","$","%","&","@","^","~"],active:!0},{name:"parenthesis",label:"{ [ ( | ) ] ] }",characters:["{","(","[","|","]",")","}"],active:!0},{name:"special_char2",label:". , : ;",characters:[".",",",":",";"],active:!0},{name:"special_char3",label:"' \" `",characters:["'",'"',"`"],active:!0},{name:"special_char4",label:"/ \\ _ -",characters:["/","\\","_","-"],active:!0},{name:"special_char5",label:"< * + ! ? =",characters:["<","*","+","!","?","="],active:!0},{name:"emoji",label:"😘",characters:["😀","😁","😂","😃","😄","😅","😆","😇","😈","😉","😊","😋","😌","😍","😎","😏","😐","😑","😒","😓","😔","😕","😖","😗","😘","😙","😚","😛","😜","😝","😞","😟","😠","😡","😢","😣","😤","😥","😦","😧","😨","😩","😪","😫","😬","😭","😮","😯","😰","😱","😲","😳","😴","😵","😶","😷","😸","😹","😺","😻","😼","😽","😾","😿","🙀","🙁","🙂","🙃","🙄","🙅","🙆","🙇","🙈","🙉","🙊","🙋","🙌","🙍","🙎","🙏"]}]},{name:"Passphrase",type:"passphrase",default_options:{word_count:9,word_case:"lowercase",min_word:4,max_word:40,separator:" "}}];const El=class{constructor(e){this.passwordGeneratorService=new _l(e)}async updateLocalStorage(){let e={};try{e=await this.passwordGeneratorService.find(),e=Object.assign({},e,{generators:fl})}catch(t){if(!(t instanceof Se&&t.data&&404===t.data.code))throw t;{const t="password";e=Object.assign({},{default_generator:t},{generators:fl})}}return await gs.set(e),new wl(e)}async getOrFindAll(){const e=await gs.get();return void 0!==e?new wl(e):this.updateLocalStorage()}},Sl={listen:function(e){e.port.on("passbolt.password-generator.settings",(async t=>{try{const r=await Ye.getInstance().getApiClientOptions(),s=new El(r),i=await s.getOrFindAll();e.port.emit(t,"SUCCESS",i)}catch(r){e.port.emit(t,"ERROR",r)}}))}};class vl extends Te{constructor(e){super(e,vl.RESOURCE_NAME)}static get RESOURCE_NAME(){return"mobile/transfers"}async get(e){this.assertValidId(e);return(await this.apiClient.get(e)).body}async create(e){this.assertNonEmptyData(e);return(await this.apiClient.create(e)).body}async update(e,t){this.assertValidId(e),this.assertNonEmptyData(t);return(await this.apiClient.update(e,t)).body}}const bl=vl;class Al extends X{constructor(e){super(se.validate(Al.ENTITY_NAME,e,Al.getSchema())),this._props.authentication_token&&(this._authentication_token=new Ru(this._props.authentication_token),delete this._props.authentication_token)}static getSchema(){return{type:"object",required:["total_pages"],properties:{id:{type:"string",format:"uuid"},user_id:{type:"string",format:"uuid"},hash:{type:"string"},current_page:{type:"integer"},total_pages:{type:"integer"},status:{type:"string",enum:[Al.TRANSFER_STATUS_START,Al.TRANSFER_STATUS_COMPLETE,Al.TRANSFER_STATUS_IN_PROGRESS,Al.TRANSFER_STATUS_ERROR,Al.TRANSFER_STATUS_CANCEL]},created:{type:"string",format:"date-time"},modified:{type:"string",format:"date-time"},authentication_token:Ru.getSchema()}}}toDto(e){const t=Object.assign({},this._props);return e?(this._authentication_token&&e.authentication_token&&(t.authentication_token=this._authentication_token.toDto()),t):t}toJSON(){return this.toDto(Al.ALL_CONTAIN_OPTIONS)}static get ALL_CONTAIN_OPTIONS(){return{authentication_token:!0}}get id(){return this._props.id}get created(){return this._props.created||null}get modified(){return this._props.modified||null}static get ENTITY_NAME(){return"transfer"}static get TRANSFER_STATUS_START(){return"start"}static get TRANSFER_STATUS_IN_PROGRESS(){return"in progress"}static get TRANSFER_STATUS_COMPLETE(){return"complete"}static get TRANSFER_STATUS_CANCEL(){return"cancel"}static get TRANSFER_STATUS_ERROR(){return"error"}}const Tl=Al;const Il=class{constructor(e){this.mobileTransferService=new bl(e)}async get(e){const t=await this.mobileTransferService.get(e);return new Tl(t)}async create(e){const t=await this.mobileTransferService.create(e.toDto());return new Tl(t)}async update(e){const t=await this.mobileTransferService.update(e.id,e.toDto());return new Tl(t)}},Rl={listen:function(e){e.port.on("passbolt.mobile.transfer.get",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Il(s),o=await i.get(r);e.port.emit(t,"SUCCESS",o)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.mobile.transfer.create",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Il(s),o=new Tl(r),n=await i.create(o);e.port.emit(t,"SUCCESS",n)}catch(r){e.port.emit(t,"ERROR",r)}})),e.port.on("passbolt.mobile.transfer.update",(async(t,r)=>{try{const s=await Ye.getInstance().getApiClientOptions(),i=new Il(s),o=new Tl(r),n=await i.update(o);e.port.emit(t,"SUCCESS",n)}catch(r){e.port.emit(t,"ERROR",r)}}))}};const Cl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.accountRecoveryModel=new oi(r),this.account=s}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){try{await this.accountRecoveryModel.continue(this.account.userId,this.account.authenticationTokenToken)}catch(e){throw gi.get("AccountRecoveryBootstrap",this.worker.tab.id).port.emit("passbolt.account-recovery-bootstrap.remove-iframe"),e}}};const Ol=class{static async decrypt(e,t,r,s,i){let o;const n=await U(e.data),a=await _e.decrypt(n,t);try{o=JSON.parse(a)}catch(e){throw new Error("Unable to parse the decrypted response data.")}const c=new Fi(o);if(c.privateKeyUserId!==r)throw new Error("The user id contained in the response data does not match the verification user id.");if(c.domain!==s)throw new Error("The domain contained in the private key password data does not match the expected target domain.");if(i&&c.privateKeyFingerprint!==i.getFingerprint().toUpperCase())throw new Error("The response data fingerprint should match the verification fingerprint.");return c}};const kl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.accountRecoveryModel=new oi(r),this.setupModel=new Fu(r),this.accountModel=new _u(r),this.updateSsoCredentialsService=new Xn(r)}async _exec(){try{await this.exec.apply(this,arguments),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){if(void 0===e)throw new Error("A passphrase is required.");if("string"!=typeof e)throw new Error("The passphrase should be a string.");const t=await this._findAndAssertRequest(),r=await this._recoverPrivateKey(t.accountRecoveryPrivateKey,t.accountRecoveryResponses.items[0],e);await this._completeRecover(r);const s=await this._addRecoveredAccountToStorage(this.account);this._updateWorkerAccount(s),this._initPagemod(),await this._refreshSsoKit(e)}async _findAndAssertRequest(){const e=await this.accountRecoveryModel.findRequestByIdAndUserIdAndAuthenticationToken(this.account.accountRecoveryRequestId,this.account.userId,this.account.authenticationTokenToken);if(e.id!==this.account.accountRecoveryRequestId)throw new Error("The account recovery request id should match the request id associated to the account being recovered.");if(!e.accountRecoveryPrivateKey)throw new Error("The account recovery request should have a private key.");if(!e.accountRecoveryResponses)throw new Error("The account recovery request should have a collection of responses.");if(1!==e.accountRecoveryResponses.length)throw new Error("The account recovery request responses should contain exactly one response.");return e}async _recoverPrivateKey(e,t,r){const s=await M(this.account.userPrivateArmoredKey),i=await Ii.decrypt(s,r),o=await Ol.decrypt(t,i,this.account.userId,this.account.domain),n=await U(e.data),a=await _e.decryptSymmetrically(n,o.privateKeySecret),c=await M(a);return gu.encrypt(c,r)}async _completeRecover(e){O(e),this.account.userPrivateArmoredKey=e.armor(),this.account.userPublicArmoredKey=e.toPublic().armor(),await this.setupModel.completeRecover(this.account)}async _addRecoveredAccountToStorage(e){const t=new $u(e.toDto(Uu.ALL_CONTAIN_OPTIONS));return await this.accountModel.add(t),await Tu.deleteByUserIdAndType(t.userId,Uu.TYPE_ACCOUNT_ACCOUNT_RECOVERY),t}_updateWorkerAccount(e){this.account.userPublicArmoredKey=e.userPublicArmoredKey,this.account.userPrivateArmoredKey=e.userPrivateArmoredKey}_initPagemod(){Qd.pageMods.WebIntegration._pageMod||Qd.pageMods.WebIntegration.init(),Qd.pageMods.AuthBootstrap.init(),Qd.pageMods.PublicWebsiteSignIn._pageMod||Qd.pageMods.PublicWebsiteSignIn.init()}async _refreshSsoKit(e){await Wo.flush(),await this.updateSsoCredentialsService.updateSsoKitIfNeeded(e)}};const Nl=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){const t=this.account?.userPrivateArmoredKey;if(!t)throw new Error("An account user private key is required.");if("string"!=typeof e)throw new TypeError("The passphrase should be a string.");const r=await M(t);await Ii.decrypt(r,e)}};const Pl=class{constructor(e,t,r,s){this.worker=e,this.requestId=t,this.account=s,this.setupModel=new Fu(r),this.userModel=new Gn(r)}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){await this.setupModel.abortRecover(this.account),await Tu.deleteByUserIdAndType(this.account.userId,Uu.TYPE_ACCOUNT_ACCOUNT_RECOVERY),await this.userModel.requestHelpCredentialsLost(this.account)}};const Ul=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){return this.account.toDto({security_token:!0})}},xl={listen:function(e,t,r){e.port.on("passbolt.organization-settings.get",(async r=>{const s=new tp(e,r,t);await s._exec()})),e.port.on("passbolt.locale.get",(async s=>{const i=new rp(e,s,t,r);await i._exec()})),e.port.on("passbolt.addon.get-version",(async t=>{const r=new ya(e,t);await r._exec()})),e.port.on("passbolt.account-recovery.continue",(async s=>{const i=new Cl(e,s,t,r);await i._exec()})),e.port.on("passbolt.account-recovery.get-account",(async t=>{const s=new Ul(e,t,r);await s._exec()})),e.port.on("passbolt.account-recovery.verify-passphrase",(async(t,s)=>{const i=new Nl(e,t,r);await i._exec(s)})),e.port.on("passbolt.account-recovery.recover-account",(async(s,i)=>{const o=new kl(e,s,t,r);await o._exec(i)})),e.port.on("passbolt.account-recovery.sign-in",(async(s,i,o)=>{const n=new ea(e,s,t,r);await n._exec(i,o,!0)})),e.port.on("passbolt.account-recovery.request-help-credentials-lost",(async s=>{const i=new Pl(e,s,t,r);await i._exec()})),e.port.on("passbolt.account-recovery.download-recovery-kit",(async t=>{const s=new Ip(e,t,r);await s._exec()})),e.port.on("passbolt.locale.update-user-locale",(async(s,i)=>{const o=new ep(e,s,t,r);await o._exec(i)}))}};const Ml=class{constructor(e,t){this.worker=e,this.resourceModel=new Ns(t)}async checkStatus(e){try{const t=new At,r=await t.checkAuthStatus({requestApi:!1});this.worker.port.emit(e,"SUCCESS",r)}catch(t){this.worker.port.emit(e,"SUCCESS",{isAuthenticated:!1})}}async countSuggestedResourcesCount(e){try{const t=await this.resourceModel.countSuggestedResources(this.worker.tab.url);this.worker.port.emit(e,"SUCCESS",t)}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t)}}async execute(e){try{const t=new At,r=await t.checkAuthStatus({requestApi:!1});if(r.isAuthenticated)r.isMfaRequired?(u.tabs.create({url:Ye.getInstance().settings.getDomain(),active:!0}),this.worker.port.emit(e,"SUCCESS")):gi.get("WebIntegration",this.worker.tab.id).port.emit("passbolt.in-form-menu.open");else{const t=[{name:"uiMode",value:"detached"},{name:"feature",value:"login"}];await Oi.openInDetachedMode(t),this.worker.port.emit(e,"SUCCESS")}}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t)}}};const Ll=class{constructor(e){this.worker=e,this.bindCallbacks()}bindCallbacks(){this.handleUserLoggedOut=this.handleUserLoggedOut.bind(this),this.handleUserLoggedIn=this.handleUserLoggedIn.bind(this),this.handleRemoveListener=this.handleRemoveListener.bind(this)}startListen(){self.addEventListener("passbolt.auth.after-logout",this.handleUserLoggedOut),self.addEventListener("passbolt.auth.after-login",this.handleUserLoggedIn),this.worker.port._port.onDisconnect.addListener(this.handleRemoveListener)}async handleUserLoggedIn(){this.worker.port.emit("passbolt.auth.after-login")}handleUserLoggedOut(){this.worker.port.emit("passbolt.auth.after-logout")}handleRemoveListener(){self.removeEventListener("passbolt.auth.after-logout",this.handleUserLoggedOut),self.removeEventListener("passbolt.auth.after-login",this.handleUserLoggedIn)}},Dl={listen:function(e){new Ll(e).startListen(),e.port.on("passbolt.in-form-cta.check-status",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Ml(e,r);await s.checkStatus(t)})),e.port.on("passbolt.in-form-cta.suggested-resources",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Ml(e,r);await s.countSuggestedResourcesCount(t)})),e.port.on("passbolt.in-form-cta.execute",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Ml(e,r);await s.execute(t)}))}};const Fl=class{constructor(e,t){this.worker=e,this.resourceModel=new Ns(t),this.apiClientOptions=t}async getInitialConfiguration(e){try{const t=await gi.get("WebIntegration",this.worker.tab.id).port.request("passbolt.web-integration.last-performed-call-to-action-input"),r=await this.resourceModel.findSuggestedResources(this.worker.tab.url),s=new El(this.apiClientOptions),i=await s.getOrFindAll(),o=e=>e.type===i.default_generator,n=i.generators.find(o),a={inputType:t.type,inputValue:t.value,suggestedResources:r,secretGeneratorConfiguration:n};this.worker.port.emit(e,"SUCCESS",a)}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t)}}async createNewCredentials(e){const t=[{name:"uiMode",value:"detached"},{name:"feature",value:"create-new-credentials"},{name:"tabId",value:this.worker.tab.id}];await Oi.openInDetachedMode(t),gi.get("WebIntegration",this.worker.tab.id).port.emit("passbolt.in-form-menu.close"),this.worker.port.emit(e,"SUCCESS")}async saveCredentials(e){const{username:t,password:r}=await gi.get("WebIntegration",this.worker.tab.id).port.request("passbolt.web-integration.get-credentials"),s=await ru.getCurrent(),i=s.title,o=s.url.substr(0,Ar.URI_MAX_LENGTH),n=new Ra({name:i,username:t,uri:o,secret_clear:r});await nu.set(n);const a=[{name:"uiMode",value:"detached"},{name:"feature",value:"save-credentials"},{name:"tabId",value:this.worker.tab.id}];await Oi.openInDetachedMode(a),this.worker.port.emit(e,"SUCCESS"),gi.get("WebIntegration",this.worker.tab.id).port.emit("passbolt.in-form-menu.close")}async useSuggestedResource(e,t){const r=gi.get("WebIntegration",this.worker.tab.id);try{const s=await Li.requestFromQuickAccess(),i=await this.resourceModel.findForDecrypt(t),o=await Mo.getKey(s),n=await U(i.secret.data);let a=await _e.decrypt(n,o);a=await this.resourceModel.deserializePlaintext(i.resourceTypeId,a);const{username:c}=i,u=a?.password||a;r.port.emit("passbolt.web-integration.fill-credentials",{username:c,password:u}),this.worker.port.emit(e,"SUCCESS"),r.port.emit("passbolt.in-form-menu.close")}catch(t){console.error(t),this.worker.port.emit(e,"ERROR",t),r.port.emit("passbolt.in-form-menu.close")}}async browseCredentials(e){const t=[{name:"uiMode",value:"detached"},{name:"feature",value:"browse-credentials"},{name:"tabId",value:this.worker.tab.id}];await Oi.openInDetachedMode(t),gi.get("WebIntegration",this.worker.tab.id).port.emit("passbolt.in-form-menu.close"),this.worker.port.emit(e,"SUCCESS")}fillPassword(e,t){gi.get("WebIntegration",this.worker.tab.id).port.emit("passbolt.web-integration.fill-password",t),this.worker.port.emit(e,"SUCCESS")}close(e){gi.get("WebIntegration",this.worker.tab.id).port.emit("passbolt.in-form-menu.close"),this.worker.port.emit(e,"SUCCESS")}},ql={listen:function(e){e.port.on("passbolt.in-form-menu.init",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Fl(e,r);await s.getInitialConfiguration(t)})),e.port.on("passbolt.in-form-menu.create-new-credentials",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Fl(e,r);await s.createNewCredentials(t)})),e.port.on("passbolt.in-form-menu.save-credentials",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Fl(e,r);await s.saveCredentials(t)})),e.port.on("passbolt.in-form-menu.use-suggested-resource",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions(),i=new Fl(e,s);await i.useSuggestedResource(t,r)})),e.port.on("passbolt.in-form-menu.browse-credentials",(async t=>{const r=await Ye.getInstance().getApiClientOptions();new Fl(e,r).browseCredentials(t)})),e.port.on("passbolt.in-form-menu.fill-password",(async(t,r)=>{const s=await Ye.getInstance().getApiClientOptions();new Fl(e,s).fillPassword(t,r)})),e.port.on("passbolt.in-form-menu.close",(async t=>{const r=await Ye.getInstance().getApiClientOptions();new Fl(e,r).close(t)})),e.port.on("passbolt.locale.get",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new hl(e,r);try{const r=await s.getLocale();e.port.emit(t,"SUCCESS",r)}catch(r){console.error(r),e.port.emit(t,"ERROR",r)}}))}};const Kl=class{constructor(e){this.worker=e}async autosave(e){const t=new URL(e.url),r={name:e.name,uri:`${t.protocol}//${t.host}${t.pathname}`,username:e.username,secret_clear:e.password},s=new Ra(r);await nu.set(s),Oi.openInDetachedMode([{name:"uiMode",value:"detached"},{name:"feature",value:"autosave-credentials"}])}},$l={listen:function(e){e.port.on("passbolt.web-integration.autosave",(async t=>{const r=new Kl(e);await r.autosave(t)}))}};const jl=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.account=r}async _exec(){try{await this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){chrome.tabs.update(this.worker.tab.id,{url:this.account.domain})}},Bl={listen:function(e,t){e.port.on("passbolt.extension.sign-in-url",(async r=>{const s=new jl(e,r,t);await s._exec()}))}};const Gl=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(e){try{await this.exec(e),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(e){await navigator.clipboard.writeText(e)}},Yl={listen:function(e){e.port.on("passbolt.clipboard.copy",(async(t,r)=>{const s=new Gl(e,t,r);await s._exec(r)}))}};function zl(e){window.portname=e}const Vl=class{constructor(e,t=0){this.tabId=e,this.frameId=t}injectJs(e){0!==e.length&&u.scripting.executeScript({files:e,target:{tabId:this.tabId,frameId:this.frameId},world:"ISOLATED"})}injectCss(e){0!==e.length&&u.scripting.insertCSS({files:e,target:{tabId:this.tabId,frameId:this.frameId}})}injectPortname(e){u.scripting.executeScript({func:zl,args:[e],target:{tabId:this.tabId,frameId:this.frameId},world:"ISOLATED"})}};var Hl=r(4586);const Wl=class{constructor(e){if(!e)throw Error("A port is required.");this._listeners={},this._port=e,this._port.onMessage.addListener((e=>{this._onMessage(e)}))}_onMessage(e){const t=JSON.parse(e),r=t[0];if(Array.isArray(this._listeners[r])){const e=this._listeners[r];for(let s=0;s<e.length;s++){const i=e[s],o=Array.prototype.slice.call(t,1);i.callback.apply(this,o),i.once&&(this._listeners[r].splice(s,1),0===this._listeners[r].length&&delete this._listeners[r],s--)}}}_addListener(e,t,r){Array.isArray(this._listeners[e])||(this._listeners[e]=[]),this._listeners[e].push({name:e,callback:t,once:r})}on(e,t){this._addListener(e,t,!1)}once(e,t){this._addListener(e,t,!0)}emit(...e){const t=JSON.stringify(e);Le.write({level:"debug",message:`Port emit @ message: ${t}`}),this._port.postMessage(t)}async emitQuiet(...e){const t=JSON.stringify(e);this._port.postMessage(t)}request(e,...t){const r=(0,Hl.Z)(),s=[e,r].concat(t);return new Promise(((e,t)=>{this.once(r,((r,...s)=>{"SUCCESS"===r?e.apply(null,s):"ERROR"===r&&t.apply(null,s)})),this.emit.apply(this,s)}))}disconnect(){this._port.disconnect()}},Jl=function(e){this._tab=e,this.id=e.id,this.url=e.url,this.callbacks={};const t=this;this._onTabUpdated=function(e,r,s){t.id==e&&"complete"==r.status&&t.triggerEvent("ready",s)},chrome.tabs.onUpdated.addListener(this._onTabUpdated),this._onTabRemoved=function(r){t.id==r&&t.triggerEvent("removed",e)},chrome.tabs.onRemoved.addListener(this._onTabRemoved)};Jl.prototype.destroy=function(){chrome.tabs.onUpdated.removeListener(this._onTabUpdated),chrome.tabs.onRemoved.removeListener(this._onTabRemoved)},Jl.prototype.on=function(e,t){this.callbacks[e]=t},Jl.prototype.removeListener=function(e){delete this.callbacks[e]},Jl.prototype.triggerEvent=function(e){if(void 0!==this.callbacks[e]){const t=Array.prototype.slice.call(arguments,1);this.callbacks[e].apply(this,t)}};const Ql=Jl,Zl=function(e,t,r,s){this.port=new Wl(e),this.callbacks={},this.iframe=r,this.pageMod=s;const i=this;t&&(this.tab=new Ql(t),this.tab.on("removed",(()=>{i.destroy("tab was closed")}))),r&&(this.onPortDisconnect=function(){i.port._port.onDisconnect.removeListener(i.onPortDisconnect),i.destroy("iframe got unloaded")},i.port._port.onDisconnect.addListener(i.onPortDisconnect))};Zl.prototype.on=function(e,t){this.callbacks[e]=t},Zl.prototype.triggerEvent=function(e){void 0!==this.callbacks[e]&&this.callbacks[e].apply()},Zl.prototype.destroy=function(e){Le.write({level:"debug",message:`sdk/worker::destroy ${this.tab&&this.tab.id?`(tab: ${this.tab.id})`:""} : ${e}`}),this.triggerEvent("detach"),this.iframe&&this.port._port.onDisconnect.removeListener(this.onPortDisconnect),this.tab&&this.tab.destroy(),delete this.port,delete this.tab};const Xl=Zl;const ed=class{constructor(e){if(void 0===e)throw new TypeError("Invalid pagemod. No argument provided");this.args=e,this._ports={},this._listeners=[],this.__init()}destroy(){void 0!==this._listeners["chrome.tabs.onRemoved"]&&(chrome.tabs.onRemoved.removeListener(this._listeners["chrome.tabs.onRemoved"]),chrome.tabs.onReplaced.removeListener(this._listeners["chrome.tabs.onReplaced"]),chrome.tabs.onUpdated.removeListener(this._listeners["chrome.tabs.onUpdated"])),void 0!==this._listeners["chrome.runtime.onConnect"]&&chrome.runtime.onConnect.removeListener(this._listeners["chrome.runtime.onConnect"]),this._ports={},this._listeners=[]}__init(){if(!(this.args.include instanceof RegExp)){if(this.args.include.startsWith("about:blank"))return void this.__onIframeConnectInit();if(this.args.include.startsWith(chrome.runtime.getURL("")))return void this.__onContentConnectInit();this.args.include=new RegExp(this.args.include)}this._listeners["chrome.tabs.onUpdated"]=async(e,t,r)=>{void 0===r.url&&"complete"===t?.status&&(r=await u.tabs.get(e)),this.__onTabUpdated(e,t,r)},chrome.tabs.onUpdated.addListener(this._listeners["chrome.tabs.onUpdated"]),this._listeners["chrome.tabs.onReplaced"]=(e,t)=>{chrome.tabs.get(e,(r=>{chrome.tabs.get(t,(s=>{Le.write({level:"debug",message:`sdk/pageMod::__init ${this.args.name} processing chrome.tabs.onReplaced ${e} ${t} ${r.url} ${s.url}`})})),this.__onTabUpdated(r.id,{status:"complete"},r)}))},chrome.tabs.onReplaced.addListener(this._listeners["chrome.tabs.onReplaced"]),void 0!==this.args.attachTo&&chrome.tabs.query({},(e=>{e.forEach((e=>{this.__onAttachExistingTab(e,this.args.attachTo.reload)}))})),this._listeners["chrome.tabs.onRemoved"]=e=>{Le.write({level:"debug",message:`sdk/pagemod::__init::onRemovedListener tab:${e}`}),e in this._ports&&delete this._ports[e]},chrome.tabs.onRemoved.addListener(this._listeners["chrome.tabs.onRemoved"])}__initConnectListener(e,t,r){void 0===r&&(r=!1),this._listeners["chrome.runtime.onConnect"]=async s=>{if(s.name===e){if(!r&&!this.__checkUrl(s.sender.tab.url))return void(gi.exists(this.args.name,s.sender.tab.id)&&gi.get(this.args.name,s.sender.tab.id).destroy("destroying worker because url changed"));if(void 0===t||t===s.sender.tab.id){this._ports[s.sender.tab.id]=s;const e=new Xl(s,s.sender.tab,r,this);await this.args.onAttach(e),e.port.emit("passbolt.port.ready")}}},chrome.runtime.onConnect.addListener(this._listeners["chrome.runtime.onConnect"])}__onIframeConnectInit(){let e=this.args.include.split("passbolt=")[1];e=e.replace("*",""),this.portname=e,Le.write({level:"debug",message:`sdk/pageMod::__onIframeConnectInit ${this.args.name} iframe opening port on ${this.portname}`}),this.__initConnectListener(this.portname,void 0,!0)}__onContentConnectInit(){let e=this.args.include;const t=chrome.runtime.getURL("/data/");e=e.replace(t,"").replace(".html",""),this.portname=e,Le.write({level:"debug",message:`sdk/pageMod::__onContentConnectInit ${this.args.name} content opening port on ${this.portname}`}),this.__initConnectListener(this.portname)}__onAttachExistingTab(e,t){(e?.url?.startsWith("http://")||e?.url?.startsWith("https://"))&&(void 0===t&&(t=!0),this.__checkUrl(e.url)&&(t?(Le.write({level:"debug",message:`Attaching pagemod on an existing tab, reload the tab @ tab:${e.id}, pagemod: ${this.args.name}, url:${e.url}, function: PageMod.__onAttachExistingTab()`}),chrome.tabs.reload(e.id)):(Le.write({level:"debug",message:`Attaching pagemod on an existing tab, reinsert the CS @ tab:${e.id}, pagemod: ${this.args.name}, url:${e.url}, function: PageMod.__onAttachExistingTab()`}),this.__onTabUpdated(e.id,{status:"complete"},e))))}__onTabUpdated(e,t,r){if(void 0===t.status)return;if("complete"!==t.status)return;if(void 0!==t.url)return;if("about:blank"===r.url)return;if(!r?.url?.startsWith("http://")&&!r?.url?.startsWith("https://"))return;if(!this.__checkUrl(r.url))return;if(Le.write({level:"debug",message:`sdk/pageMod::__onTabUpdated ${this.args.name} processing chrome.tabs.onUpdated ${e} ${t.status} ${t.url} ${r.url}`}),this.portname=`port-${K(e.toString())}`,e in this._ports)try{return void this._ports[e].postMessage(JSON.stringify("passbolt.port.check"))}catch(e){}else this.__initConnectListener(this.portname,e);const s=new Vl(e);s.injectPortname(this.portname);const i=this.args.contentScriptFile.slice();if(s.injectJs(i),void 0!==this.args.contentStyleFile){const e=this.args.contentStyleFile.slice();e.length>0&&s.injectCss(e)}}__checkUrl(e){return e.match(this.args.include)}},td=function(){};td._pageMod=void 0,td.init=function(){void 0!==td._pageMod&&(td._pageMod.destroy(),td._pageMod=void 0);const e=Ye.getInstance().settings.getDomain().replace(/\W/g,"\\$&");td._pageMod=new ed({name:"WebIntegration",include:new RegExp(`^((?!${e}).)*$`),contentScriptWhen:"ready",contentStyleFile:[],contentScriptFile:["contentScripts/js/dist/browser-integration/vendors.js","contentScripts/js/dist/browser-integration/browser-integration.js"],attachTo:{existing:!0,reload:!1},onAttach:function(e){gi.add("WebIntegration",e),Qd.events.config.listen(e),Qd.events.webIntegration.listen(e),Qd.events.organizationSettings.listen(e)}})};const rd=td;const sd=class{static getRegex(){return`^${Ye.getInstance().settings.getDomain().replace(/\W/g,"\\$&")}/?(/app.*)?(#.*)?$`}static parse(e){if(!new RegExp(this.getRegex()).test(e))throw new Error("Cannot parse application url. The url does not match the pattern.");e=e.replace(/\/*$/g,"");try{new URL(e)}catch(e){throw new Error("Cannot parse application url. The domain is not valid.")}}},id=function(){};id._pageMod=null,id.exists=function(){return null!==id._pageMod},id.destroy=function(){id.exists()&&(id._pageMod.destroy(),id._pageMod=null)},id.initPageMod=function(){return new ed({name:"AppBoostrap",include:new RegExp(sd.getRegex()),contentScriptWhen:"ready",contentStyleFile:["webAccessibleResources/css/themes/default/ext_external.min.css"],contentScriptFile:["contentScripts/js/dist/vendors.js","contentScripts/js/dist/app.js"],attachTo:{existing:!0,reload:!0},onAttach:async function(e){const t=new At;await t.isAuthenticated()&&!await t.isMfaRequired()?(Qd.events.appBootstrap.listen(e),gi.add("AppBootstrap",e)):console.error("Can not attach application if user is not logged in.")}})},id.init=function(){return new Promise((e=>{Ye.getInstance().isValid()&&(id.destroy(),id._pageMod=id.initPageMod(),e())}))};const od=id;const nd=class{static async get(){const e=new ge,t=await Ye.getInstance().get(),r=e.findPublic(K(t.settings.domain)),s=e.findPublic(t.id),i=e.findPrivate(),o={domain:t.settings.domain,user_id:t.id,username:t.username,first_name:t.firstname,last_name:t.lastname,server_public_armored_key:r.armoredKey,user_key_fingerprint:s.fingerprint.toUpperCase(),user_public_armored_key:s.armoredKey,user_private_armored_key:i.armoredKey,security_token:t.settings.securityToken};return new $u(o)}};const ad=class{async main(){const e=Ye.getInstance();await this._syncUserSettings(e),await this._syncSsoKit(e)}async _syncUserSettings(e){try{await e.settings.sync()}catch(t){e.settings.setDefaults()}}async _syncSsoKit(e){try{const t=await Zo.getAndFlush();if(!t)return;const r=new jo(await e.getApiClientOptions()),s=await r.setupSsoKit(t);await Wo.updateLocalKitIdWith(s.id)}catch(e){console.error(e),await Wo.flush(),await Zo.flush()}}},cd=function(){};cd._pageMod=null,cd.init=function(){cd._pageMod&&(cd._pageMod.destroy(),cd._pageMod=null),cd._pageMod=new ed({name:"App",include:"about:blank?passbolt=passbolt-iframe-app",contentScriptWhen:"end",contentScriptFile:[],onAttach:async function(e){const t=new At;if(!await t.isAuthenticated()||await t.isMfaRequired())return void console.error("Can not attach application if user is not logged in.");const r=new ad;let s;await r.main();try{s=await nd.get()}catch(e){console.error("appPagemod::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}Qd.events.appBootstrap.listen(e),Qd.events.app.listen(e,s),Qd.events.auth.listen(e),Qd.events.config.listen(e),Qd.events.folder.listen(e),Qd.events.resource.listen(e),Qd.events.resourceType.listen(e),Qd.events.role.listen(e),Qd.events.keyring.listen(e),Qd.events.secret.listen(e),Qd.events.organizationSettings.listen(e),Qd.events.share.listen(e),Qd.events.subscription.listen(e),Qd.events.user.listen(e),Qd.events.group.listen(e),Qd.events.comment.listen(e),Qd.events.tag.listen(e),Qd.events.favorite.listen(e),Qd.events.importResources.listen(e),Qd.events.exportResources.listen(e),Qd.events.actionLogs.listen(e),Qd.events.multiFactorAuthentication.listen(e),Qd.events.theme.listen(e),Qd.events.locale.listen(e),Qd.events.passwordGenerator.listen(e),Qd.events.mobile.listen(e),Qd.events.clipboard.listen(e),Qd.events.mfaPolicy.listen(e),gi.add("App",e)}})};const ud=cd;const pd=class{static get regex(){const e=Ye.getInstance().settings.getDomain().replace(/\W/g,"\\$&");return new RegExp(`^${e}/auth/login/?(#.*)?(\\?.*)?$`)}static test(e){return this.regex.test(e)}},ld=function(){};ld._pageMod=void 0,ld.init=function(){void 0!==ld._pageMod&&(ld._pageMod.destroy(),ld._pageMod=void 0),ld._pageMod=new ed({name:"AuthBootstrap",include:pd.regex,contentScriptWhen:"ready",contentStyleFile:["webAccessibleResources/css/themes/default/ext_external.min.css"],contentScriptFile:["contentScripts/js/dist/vendors.js","contentScripts/js/dist/login.js"],attachTo:{existing:!0,reload:!0},onAttach:async function(e){await Be.flush(),gi.add("AuthBootstrap",e)}})};const dd=ld,hd=function(){};hd._pageMod=void 0,hd.init=function(){void 0!==hd._pageMod&&(hd._pageMod.destroy(),hd._pageMod=void 0),hd._pageMod=new ed({name:"Auth",include:"about:blank?passbolt=passbolt-iframe-login",contentScriptWhen:"ready",contentScriptFile:[],onAttach:async function(e){let t;gi.add("Auth",e);try{t=await nd.get()}catch(e){console.error("authPagemod::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}Qd.events.user.listen(e),Qd.events.keyring.listen(e),Qd.events.auth.listen(e,t),Qd.events.config.listen(e),Qd.events.organizationSettings.listen(e),Qd.events.locale.listen(e)}})};const gd=hd,yd=function(){};yd._pageMod=void 0,yd.init=function(){void 0!==yd._pageMod&&(yd._pageMod.destroy(),yd._pageMod=void 0);const e="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}";yd._pageMod=new ed({name:"SetupBootstrap",include:new RegExp(`.*/setup/(install|start)/${e}/${e}`),contentScriptWhen:"ready",contentStyleFile:["webAccessibleResources/css/themes/default/ext_external.min.css"],contentScriptFile:["contentScripts/js/dist/vendors.js","contentScripts/js/dist/setup.js"],onAttach:function(e){gi.add("SetupBootstrap",e)}})};const _d=yd;const md=class{static parse(e){const t="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}",r=new RegExp(`(.*)/setup/(install|start)/(${t})/(${t})`);if(!r.test(e))throw new Error("Cannot parse setup url. The url does not match the pattern.");const s=e.match(r);let[,i]=s;const[,,,o,n]=s;i=i.replace(/\/*$/g,"");try{new URL(i)}catch(e){throw new Error("Cannot parse setup url. The domain is not valid.")}return{domain:i,user_id:o,authentication_token_token:n}}};const wd=class{static buildFromSetupUrl(e){if("string"!=typeof e)throw new TypeError("Url should be a valid string.");const t=md.parse(e);return new Cp(t)}};const fd=class{static async build(e){const t=(new Oe).setBaseUrl(e.domain),r=new Re(t);return t.setCsrfToken(await r.findCsrfToken()),t}},Ed=function(){};Ed._pageMod=void 0,Ed.init=function(){void 0!==Ed._pageMod&&(Ed._pageMod.destroy(),Ed._pageMod=void 0),Ed._pageMod=new ed({name:"Setup",include:"about:blank?passbolt=passbolt-iframe-setup",contentScriptWhen:"ready",contentScriptFile:[],onAttach:async function(e){let t,r;try{t=wd.buildFromSetupUrl(e.tab.url),r=await fd.build(t)}catch(e){return void console.error(e)}Qd.events.config.listen(e),Qd.events.setup.listen(e,r,t),Qd.events.secret.listen(e)}})};const Sd=Ed,vd=function(){};vd._pageMod=void 0,vd.init=function(){void 0!==vd._pageMod&&(vd._pageMod.destroy(),vd._pageMod=void 0);const e="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}";vd._pageMod=new ed({name:"RecoverBootstrap",include:new RegExp(`(.*)/setup/recover/(${e})/(${e})`),contentScriptWhen:"ready",contentStyleFile:["webAccessibleResources/css/themes/default/ext_external.min.css"],contentScriptFile:["contentScripts/js/dist/vendors.js","contentScripts/js/dist/recover.js"],onAttach:function(e){gi.add("RecoverBootstrap",e)}})};const bd=vd;const Ad=class{static parse(e){const t="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}",r=new RegExp(`(.*)/account-recovery/continue/(${t})/(${t})`);if(!r.test(e))throw new Error("Cannot parse account recovery url. The url does not match the pattern.");const s=e.match(r);let[,i]=s;const[,,o,n]=s;i=i.replace(/\/*$/g,"");try{new URL(i)}catch(e){throw new Error("Cannot parse account recovery url. The domain is not valid.")}return{domain:i,user_id:o,authentication_token_token:n}}};const Td=class{static async getAccountMatchingContinueUrl(e){const{domain:t,user_id:r,authentication_token_token:s}=Ad.parse(e),i=await Tu.getAccountByUserIdAndType(r,Uu.TYPE_ACCOUNT_ACCOUNT_RECOVERY);if(!i)throw new Error("No account found for the given user in the local storage.");const o=new Uu(i);if(o.domain!==t||o.authenticationTokenToken!==s||o.userId!==r)throw new Error("The account found in the local storage does not match the account recovery request url parameters.");return o}},Id=function(){};Id._pageMod=void 0,Id.init=function(){void 0!==Id._pageMod&&(Id._pageMod.destroy(),Id._pageMod=void 0);const e="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}";Id._pageMod=new ed({name:"AccountRecoveryBootstrap",include:new RegExp(`(.*)/account-recovery/continue/(${e})/(${e})`),contentScriptWhen:"ready",contentStyleFile:[],contentScriptFile:["contentScripts/js/dist/vendors.js","contentScripts/js/dist/account-recovery.js"],onAttach:async function(e){try{await Td.getAccountMatchingContinueUrl(e.tab.url)}catch(t){return console.error(t),void e.port.disconnect()}gi.add("AccountRecoveryBootstrap",e)}})};const Rd=Id,Cd=function(){};Cd._pageMod=void 0,Cd.init=function(){void 0!==Cd._pageMod&&(Cd._pageMod.destroy(),Cd._pageMod=void 0),Cd._pageMod=new ed({name:"AccountRecovery",include:"about:blank?passbolt=passbolt-iframe-account-recovery",contentScriptWhen:"ready",contentScriptFile:[],onAttach:async function(e){let t;try{t=await Td.getAccountMatchingContinueUrl(e.tab.url)}catch(t){return console.error(t),void e.port.disconnect()}const r=await fd.build(t);Qd.events.accountRecovery.listen(e,r,t)}})};const Od=Cd;const kd=new class{constructor(){this._worker=null,this.handleOnConnect=this.handleOnConnect.bind(this)}init(){chrome.runtime.onConnect.addListener(this.handleOnConnect)}async handleOnConnect(e){if("quickaccess"===e.name){let t;this._worker=new Xl(e,e.sender.tab);try{t=await nd.get()}catch(e){console.error("quickAccessPagemod::attach legacy account cannot be retrieved, please contact your administrator."),console.error(e)}Qd.events.auth.listen(this._worker,t),Qd.events.config.listen(this._worker),Qd.events.keyring.listen(this._worker),Qd.events.quickAccess.listen(this._worker),Qd.events.group.listen(this._worker),Qd.events.tag.listen(this._worker),Qd.events.resource.listen(this._worker),Qd.events.secret.listen(this._worker),Qd.events.organizationSettings.listen(this._worker),Qd.events.tab.listen(this._worker),Qd.events.locale.listen(this._worker),Qd.events.passwordGenerator.listen(this._worker),gi.add("QuickAccess",this._worker),this._worker.port.emit("passbolt.port.ready")}}},Nd=function(){};Nd._pageMod=void 0,Nd.init=function(){void 0!==Nd._pageMod&&(Nd._pageMod.destroy(),Nd._pageMod=void 0),Nd._pageMod=new ed({name:"File",include:"about:blank?passbolt=passbolt-iframe-file",contentScriptFile:[],contentScriptWhen:"ready",onAttach:function(e){gi.add("FileIframe",e)}})};const Pd=Nd,Ud=function(){};Ud._pageMod=void 0,Ud.init=function(){void 0!==Ud._pageMod&&(Ud._pageMod.destroy(),Ud._pageMod=void 0),Ud._pageMod=new ed({name:"InFormCallToAction",include:"about:blank?passbolt=passbolt-iframe-in-form-call-to-action",contentScriptWhen:"ready",contentScriptFile:[],onAttach:function(e){Qd.events.informCallToAction.listen(e)}})};const xd=Ud,Md=function(){};Md._pageMod=void 0,Md.init=function(){void 0!==Md._pageMod&&(Md._pageMod.destroy(),Md._pageMod=void 0),Md._pageMod=new ed({name:"InFormMenu",include:"about:blank?passbolt=passbolt-iframe-in-form-menu",contentScriptWhen:"ready",contentScriptFile:[],onAttach:function(e){Qd.events.informMenu.listen(e)}})};const Ld=Md;const Dd=class{static get regex(){return new RegExp("^https://(www|signup).passbolt.com(/.*|#.*)?$")}},Fd=function(){};Fd._pageMod=void 0,Fd.init=function(){void 0!==Fd._pageMod&&(Fd._pageMod.destroy(),Fd._pageMod=void 0),Fd._pageMod=new ed({name:"PublicWebsiteSignIn",include:Dd.regex,contentScriptWhen:"ready",contentStyleFile:[],contentScriptFile:["contentScripts/js/dist/public-website-sign-in/public-website-sign-in.js"],attachTo:{existing:!0,reload:!1},onAttach:async function(e){let t;gi.add("PublicWebsiteSignIn",e);try{t=await nd.get()}catch(e){return console.error("PublicWebsiteSignIn::attach legacy account cannot be retrieved, please contact your administrator."),void console.error(e)}Qd.events.publicWebsiteSignIn.listen(e,t)}})};const qd=Fd;const Kd=class{static parse(e){const t="[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[0-5][a-fA-F0-9]{3}-[089aAbB][a-fA-F0-9]{3}-[a-fA-F0-9]{12}",r=new RegExp(`(.*)/(setup/recover|setup/recover/start)/(${t})/(${t})`);if(!r.test(e))throw new Error("Cannot parse recover url. The url does not match the pattern.");const s=e.match(r);let[,i]=s;const[,,,o,n]=s;i=i.replace(/\/*$/g,"");try{new URL(i)}catch(e){throw new Error("Cannot parse recover url. The domain is not valid.")}return{domain:i,user_id:o,authentication_token_token:n}}};const $d=class{static buildFromRecoverUrl(e){if("string"!=typeof e)throw new TypeError("Url should be a valid string.");const t=Kd.parse(e);return new Nu(t)}},jd=function(){};jd._pageMod=void 0,jd.init=function(){void 0!==jd._pageMod&&(jd._pageMod.destroy(),jd._pageMod=void 0),jd._pageMod=new ed({name:"Setup",include:"about:blank?passbolt=passbolt-iframe-recover",contentScriptWhen:"ready",contentScriptFile:[],onAttach:async function(e){let t,r;try{t=$d.buildFromRecoverUrl(e.tab.url),r=await fd.build(t)}catch(e){return void console.error(e)}Qd.events.config.listen(e),Qd.events.recover.listen(e,r,t),Qd.events.secret.listen(e)}})};const Bd=jd;const Gd=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{this.exec(),this.worker.port.emit(this.requestId,"SUCCESS")}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}async exec(){uo.postponeMFAPolicy()}};const Yd=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new du(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return this.multiFactorAuthenticationModel.getPolicy()}};const zd=class{constructor(e,t,r){this.worker=e,this.requestId=t,this.multiFactorAuthenticationModel=new du(r)}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return this.multiFactorAuthenticationModel.getMfaSettings()}};const Vd=class{constructor(e,t){this.worker=e,this.requestId=t}async _exec(){try{const e=await this.exec();this.worker.port.emit(this.requestId,"SUCCESS",e)}catch(e){console.error(e),this.worker.port.emit(this.requestId,"ERROR",e)}}exec(){return uo.hasPostponedMFAPolicy()}},Hd={listen:function(e){e.port.on("passbolt.mfa-policy.has-user-postponed-user-setting-invitation",(async t=>{const r=new Vd(e,t);await r._exec()})),e.port.on("passbolt.mfa-policy.postpone-user-setting-invitation",(async t=>{const r=new Gd(e,t);await r._exec()})),e.port.on("passbolt.mfa-policy.get-policy",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new Yd(e,t,r);await s._exec()})),e.port.on("passbolt.mfa-policy.get-mfa-settings",(async t=>{const r=await Ye.getInstance().getApiClientOptions(),s=new zd(e,t,r);await s._exec()}))}},Wd={};Wd.app=tn,Wd.appBootstrap=rn,Wd.actionLogs=Sn,Wd.auth=ra,Wd.comment=ga,Wd.config=_a,Wd.exportResources=Za,Wd.favorite=rc,Wd.folder=gc,Wd.group=Mc,Wd.importResources=Jc,Wd.keyring=tu,Wd.quickAccess=au,Wd.multiFactorAuthentication=hu,Wd.recover=ap,Wd.resource=pp,Wd.resourceType=lp,Wd.role=yp,Wd.secret=vp,Wd.setup=Mp,Wd.share=Fp,Wd.subscription=Wp,Wd.tab=Jp,Wd.tag=Zp,Wd.theme=nl,Wd.user=ll,Wd.organizationSettings=dl,Wd.locale=gl,Wd.passwordGenerator=Sl,Wd.mobile=Rl,Wd.accountRecovery=xl,Wd.informCallToAction=Dl,Wd.informMenu=ql,Wd.webIntegration=$l,Wd.publicWebsiteSignIn=Bl,Wd.mfaPolicy=Hd,Wd.clipboard=Yl;const Jd={};Jd.WebIntegration=rd,Jd.AppBoostrap=od,Jd.App=ud,Jd.AuthBootstrap=dd,Jd.Auth=gd,Jd.SetupBootstrap=_d,Jd.Setup=Sd,Jd.RecoverBootstrap=bd,Jd.Recover=Bd,Jd.AccountRecoveryBootstrap=Rd,Jd.AccountRecovery=Od,Jd.QuickAccess=kd,Jd.File=Pd,Jd.InFormMenuCTA=xd,Jd.InFormMenu=Ld,Jd.PublicWebsiteSignIn=qd;const Qd={events:Wd,callbacks:{},pageMods:Jd};i.init().then((()=>{!async function(){Le.init(),G(),Ye.init(),Lr.init(),jr.init(),Wr.init(),He.init(),es.init(),os.init(),ls.init(),gs.init(),uo.init(),await Be.init(),await Zo.init(),h.vc.allowInsecureDecryptionWithSigningKeys=!0,new Ls;const e=Qd.pageMods;if(Ye.getInstance().isValid()){e.WebIntegration.init(),e.AuthBootstrap.init(),e.PublicWebsiteSignIn.init();const t=new At;try{if(await t.isAuthenticated()){await e.AppBoostrap.init(),t.startCheckAuthStatusLoop();const r=new Event("passbolt.auth.after-login");self.dispatchEvent(r)}}catch(e){}}e.SetupBootstrap.init(),e.Setup.init(),e.RecoverBootstrap.init(),e.Recover.init(),e.AccountRecoveryBootstrap.init(),e.AccountRecovery.init(),e.File.init(),e.Auth.init(),e.QuickAccess.init(),e.InFormMenuCTA.init(),e.InFormMenu.init(),e.App.init()}()}))},9170:()=>{}},i={};function o(e){var t=i[e];if(void 0!==t)return t.exports;var r=i[e]={exports:{}};return s[e].call(r.exports,r,r.exports,o),r.exports}o.m=s,e=[],o.O=(t,r,s,i)=>{if(!r){var n=1/0;for(p=0;p<e.length;p++){for(var[r,s,i]=e[p],a=!0,c=0;c<r.length;c++)(!1&i||n>=i)&&Object.keys(o.O).every((e=>o.O[e](r[c])))?r.splice(c--,1):(a=!1,i<n&&(n=i));if(a){e.splice(p--,1);var u=s();void 0!==u&&(t=u)}}return t}i=i||0;for(var p=e.length;p>0&&e[p-1][2]>i;p--)e[p]=e[p-1];e[p]=[r,s,i]},o.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return o.d(t,{a:t}),t},r=Object.getPrototypeOf?e=>Object.getPrototypeOf(e):e=>e.__proto__,o.t=function(e,s){if(1&s&&(e=this(e)),8&s)return e;if("object"==typeof e&&e){if(4&s&&e.__esModule)return e;if(16&s&&"function"==typeof e.then)return e}var i=Object.create(null);o.r(i);var n={};t=t||[null,r({}),r([]),r(r)];for(var a=2&s&&e;"object"==typeof a&&!~t.indexOf(a);a=r(a))Object.getOwnPropertyNames(a).forEach((t=>n[t]=()=>e[t]));return n.default=()=>e,o.d(i,n),i},o.d=(e,t)=>{for(var r in t)o.o(t,r)&&!o.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},o.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),o.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),o.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{var e={826:0};o.O.j=t=>0===e[t];var t=(t,r)=>{var s,i,[n,a,c]=r,u=0;if(n.some((t=>0!==e[t]))){for(s in a)o.o(a,s)&&(o.m[s]=a[s]);if(c)var p=c(o)}for(t&&t(r);u<n.length;u++)i=n[u],o.o(e,i)&&e[i]&&e[i][0](),e[i]=0;return o.O(p)},r=self.backgroundPageIndexChunkLoadingGlobal=self.backgroundPageIndexChunkLoadingGlobal||[];r.forEach(t.bind(null,0)),r.push=t.bind(null,r.push.bind(r))})();var n=o.O(void 0,[216],(()=>o(5571)));n=o.O(n)})();